#!/usr/bin/python

from locust import HttpLocust, TaskSet
from lxml import etree
import uuid
import json
import os
import random

# CHART DATA.
WORLD_POP_DATA = {
    'datasource': '2__table',
    'viz_type': 'area',
    'slice_id': 48,
    'url_params': {},
    'granularity_sqla': 'year',
    'time_grain_sqla': 'P1D',
    'time_range': '1980-01-01 : now',
    'metrics': ['sum__SP_POP_TOTL'],
    'adhoc_filters': [],
    'groupby': ['region'],
    'limit': '25',
    'timeseries_limit_metric': None,
    'order_desc': True,
    'contribution': False,
    'row_limit': 50000,
    'show_brush': 'auto',
    'show_legend': True,
    'line_interpolation': 'linear',
    'stacked_style': 'stack',
    'color_scheme': 'bnbColors',
    'rich_tooltip': True,
    'show_controls': False,
    'x_axis_label': '',
    'bottom_margin': 'auto',
    'x_ticks_layout': 'auto',
    'x_axis_format': 'smart_date',
    'x_axis_showminmax': False,
    'y_axis_format': '.3s',
    'y_axis_bounds': [None, None],
    'y_log_scale': False,
    'rolling_type': 'None',
    'comparison_type': 'values',
    'resample_how': None,
    'resample_rule': None,
    'resample_fillmethod': None,
    'annotation_layers': []
}

SANKEY_DATA = {
    'datasource': '1__table',
    'viz_type': 'sankey',
    'url_params': {},
    'granularity_sqla': None,
    'time_grain_sqla': 'P1D',
    'time_range': 'Last week',
    'groupby': ['source', 'target'],
    'metric': 'sum__value',
    'adhoc_filters': [],
    'row_limit': '5000',
    'color_scheme': 'bnbColors'
}

CALENDAR_DATA = {
    'datasource': '7__table',
    'viz_type': 'cal_heatmap',
    'url_params': {},
    'granularity_sqla': 'day',
    'time_grain_sqla': 'P1D',
    'time_range': '1 year ago : now',
    'domain_granularity': 'month',
    'subdomain_granularity': 'day',
    'metrics': ['count'],
    'adhoc_filters': [],
    'linear_color_scheme': 'blue_white_yellow',
    'cell_size': 10,
    'cell_padding': 2,
    'cell_radius': 0,
    'steps': 10,
    'y_axis_format': '.3s',
    'x_axis_time_format': 'smart_date',
    'show_legend': True,
    'show_values': False,
    'show_metric_name': True
}

CHART_DATA = {
    'world_pop': WORLD_POP_DATA,
    'sankey': SANKEY_DATA,
    'calendar': CALENDAR_DATA,
}


# UTILITIES.
def create_uuid():
    return uuid.uuid4().hex


def _get(l, url, csrf=None):
    if not csrf:
        csrf = l.csrf

    data = {
        'csrf_token': csrf,
    }
    l.client.get(url, data=data)


def _post(l, url, data,
          params=None,
          headers=None):
    if not data:
        data = {}
    data['csrf_token'] = l.csrf
    l.client.post(url, data=data,
                  params=params)


# ENDPOINTS.
def index(l):
    _get(l, "/")


def welcome_page(l):
    _get(l, '/superset/welcome')


def see_dashboards(l):
    '''
    Lists all out the dashboards.
    '''
    _get(l, '/dashboard/list/')


def _create_chart(s, form_data, title, csrf,
                  dashboard_name=None, new_dashboard=False):
    '''
    Helper function that Creates a chart in superset.
    Pass in form data that describes the chart.
    '''
    params = [
        ('action', 'saveas'),
        ('slice_name', title),


    ]
    # Make a new dashboard.
    if dashboard_name and new_dashboard:
        params.append(('add_to_dash', 'new'))
        params.append(('new_dashboard_name', dashboard_name))
        params.append(('goto_dash', 'true'))
    # Add to an existing dashboard.
    elif dashboard_name:
        params.append(('save_to_dashboard_id', dashboard_name))
        params.append(('add_to_dash', 'existing'))
        params.append(('goto_dash', 'true'))
    # Don't use a dashboard.
    else:
        params.append(('add_to_dash', 'noSave'))
        params.append(('goto_dash', 'false'))

    if 'slice_id' in form_data:
        form_data.pop('slice_id')
    data = {
        'form_data': json.dumps(form_data),
        'csrf_token': csrf
    }

    response = s.post('/superset/explore/',
                      params=params,
                      cookies=s.cookies.get_dict(),
                      data=data)
    return response


def create_dashboard(l):
    '''
    Creates a dashboard with charts.
    '''
    dashboard_name = "{} Dashboard".format(create_uuid())
    responses = []
    new_dashboard = True
    for name, form_data in CHART_DATA.items():
        res = _create_chart(l.client, form_data,
                            'sankey', l.csrf,
                            dashboard_name, new_dashboard=new_dashboard)
        if new_dashboard:
            try:
                dashboard = res.json()['dashboard']
            except json.decoder.JSONDecodeError as e:
                return
            dashboard_name = os.path.basename(os.path.normpath(dashboard))
            new_dashboard = False
        responses.append(res)


def create_random_chart(l):
    '''
    Randomly chooses one of the chart fn available to create a chart.
    '''

    name, form_data = random.choice(list(CHART_DATA.items()))
    _create_chart(l.client, form_data, name)


def see_charts(l):
    '''
    Calls the command to list all charts.
    '''
    _get(l, "/chart/list/")


def see_tables(l):
    '''
    Lists out all the tables.
    '''
    _get(l, "/tablemodelview/list/")


def run_sql_command(l):
    '''
    Runs a sql command on the database.
    Randomly chooses a sql command function
    then runs it.
    '''
    sql_command = '''
        SELECT created_on,
               changed_on,
               id,
               dashboard_title,
               position_json,
               created_by_fk,
               changed_by_fk,
               css,
               description,
               slug,
               json_metadata
        FROM public.dashboards
        LIMIT 100
        OFFSET 0
    '''
    data = {
        'client_id': create_uuid()[:10],
        'database_id': '1',
        'json': 'true',
        'runAsync': 'false',
        'schema': '',
        'sql': sql_command,
        'sql_editor_id': 'PmulpZH5KD',
        'tab': 'Untitled Query',
        'tmp_table_name': '',
        'select_as_cta': 'false',
        'templateParams': '{}',
    }

    headers = {
        'Accept': 'application/json, text/javascript, */*; q=0.01',
    }
    _post(l, '/superset/sql_json/', data, headers=headers)


def save_sql_command(l):
    '''
    Saves a sql command.
    '''
    sql_command = '''
        SELECT created_on,
               changed_on,
               id,
               dashboard_title,
               position_json,
               created_by_fk,
               changed_by_fk,
               css,
               description,
               slug,
               json_metadata
        FROM public.dashboards
        LIMIT 100
        OFFSET 0
    '''
    data = {
        'label': 'Steph Query',
        'description': '',
        'db_id': '1',
        'schema': '',
        'sql': sql_command
    }
    _post(l, '/savedqueryviewapi/api/create', data)


def see_searched_sql_queries(l):
    '''
    Sees all sql queries that have been run before.
    '''
    _get(l, "/superset/sqllab#search")


def logout(l):
    _get(l, '/logout/', csrf=None)


def get_csrf(response):
    if response.status_code == 200:
        tree = etree.HTML(response.content)
        csrf = tree.xpath('//input[@name="csrf_token"]/@value')[0]
        return csrf
    return None


def on_start(l):
    # Get the csrf.
    response = l.client.get('/login',
                            cookies=l.client.cookies)
    l.csrf = get_csrf(response)
    assert l.csrf

    data = {
        'csrf_token': l.csrf,
        'username': 'admin',
        'password': 'admin'
    }

    # Login using the post request.
    response = _post(l, '/login/', data=data)


class WriterUserBehavior(TaskSet):
    '''
    User that creates many dashboards.
    '''

    def on_start(self):
        on_start(self)

    def on_stop(self):
        logout(self)

    tasks = {
        see_dashboards: 5,
        create_random_chart: 2,
        see_charts: 5,
        see_tables: 5,
        save_sql_command: 2,
        run_sql_command: 4,
        see_searched_sql_queries: 3,
        create_dashboard: 1,
    }


class ReaderUserBehavior(TaskSet):
    '''
    User that doesn't write anything, but reads
    everything.
    '''

    def on_start(self):
        on_start(self)

    def on_stop(self):
        logout(self)

    tasks = {
        index: 1,
        welcome_page: 1,
        see_dashboards: 3,
        see_charts: 3,
        see_tables: 3,
        see_searched_sql_queries: 1,
    }

{{.Users}}
