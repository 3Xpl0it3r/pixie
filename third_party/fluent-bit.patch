diff --git a/src/flb_parser_logfmt.c b/src/flb_parser_logfmt.c
index 0103775c..ab438503 100644
--- a/src/flb_parser_logfmt.c
+++ b/src/flb_parser_logfmt.c
@@ -213,7 +213,7 @@ static int logfmt_parser(struct flb_parser *parser,
                         }
                     }
                 }
-                else {
+                else if (value_len > 0) {
                     (*map_size)++;
                 }
             }
diff --git a/lib/flb_libco/settings.h b/lib/flb_libco/settings.h
index 15d35d98..fa10ca14 100644
--- a/lib/flb_libco/settings.h
+++ b/lib/flb_libco/settings.h
@@ -11,6 +11,7 @@
 #ifdef _WIN32
 #define LIBCO_MPROTECT
 #endif
+#define LIBCO_MPROTECT
 
 /*[amd64]:
    Win64 only: provides a substantial speed-up, but will thrash XMM regs
diff --git a/plugins/filter_grep/grep.h b/plugins/filter_grep/grep.h
index 922430e8..69800d0d 100644
--- a/plugins/filter_grep/grep.h
+++ b/plugins/filter_grep/grep.h
@@ -35,11 +35,16 @@ struct grep_ctx {
 
 struct grep_rule {
     int type;
-    int field_len;
-    char *field;
+    struct mk_list path;
     char *regex_pattern;
     struct flb_regex *regex;
     struct mk_list _head;
 };
 
+struct grep_path_component {
+    int field_len;
+    char *field;
+    struct mk_list _head;
+};
+
 #endif
diff --git a/plugins/filter_grep/grep.c b/plugins/filter_grep/grep.c
index 691bd9bc..83724492 100644
--- a/plugins/filter_grep/grep.c
+++ b/plugins/filter_grep/grep.c
@@ -37,11 +37,19 @@ static void delete_rules(struct grep_ctx *ctx)
 {
     struct mk_list *tmp;
     struct mk_list *head;
+    struct mk_list *path_head;
+    struct mk_list *path_tmp;
     struct grep_rule *rule;
+    struct grep_path_component *p;
 
     mk_list_foreach_safe(head, tmp, &ctx->rules) {
         rule = mk_list_entry(head, struct grep_rule, _head);
-        flb_free(rule->field);
+        mk_list_foreach_safe(path_head, path_tmp, &rule->path) {
+            p = mk_list_entry(path_head, struct grep_path_component, _head);
+            flb_free(p->field);
+            mk_list_del(&p->_head);
+            flb_free(p);
+        }
         flb_free(rule->regex_pattern);
         flb_regex_destroy(rule->regex);
         mk_list_del(&rule->_head);
@@ -56,6 +64,10 @@ static int set_rules(struct grep_ctx *ctx, struct flb_filter_instance *f_ins)
     struct flb_split_entry *sentry;
     struct flb_kv *kv;
     struct grep_rule *rule;
+    struct mk_list *split_head;
+    struct grep_path_component *p;
+    int split_size;
+    int i;
 
     /* Iterate all filter properties */
     mk_list_foreach(head, &f_ins->properties) {
@@ -83,24 +95,34 @@ static int set_rules(struct grep_ctx *ctx, struct flb_filter_instance *f_ins)
         }
 
         /* As a value we expect a pair of field name and a regular expression */
-        split = flb_utils_split(kv->val, ' ', 1);
-        if (mk_list_size(split) != 2) {
+        split = flb_utils_split(kv->val, ' ', 6);
+        if (mk_list_size(split) < 2) {
             flb_error("[filter_grep] invalid regex, expected field and regular expression");
             delete_rules(ctx);
             flb_free(rule);
             flb_utils_split_free(split);
             return -1;
+        } 
+
+        mk_list_init(&rule->path);
+
+        split_size = mk_list_size(split);
+        i = 0;
+        mk_list_foreach(split_head, split) {
+            sentry = mk_list_entry(split_head, struct flb_split_entry, _head);
+            if (i < split_size - 1) {
+                // Handle field path entry.
+                p = flb_malloc(sizeof(struct grep_path_component)); 
+                p->field = flb_strndup(sentry->value, sentry->len);
+                p->field_len = sentry->len;
+                mk_list_add(&p->_head, &rule->path);
+            } else {
+                // Handle regular expression.
+                rule->regex_pattern = flb_strndup(sentry->value, sentry->len);
+            }
+            i++;
         }
 
-        /* Get first value (field) */
-        sentry = mk_list_entry_first(split, struct flb_split_entry, _head);
-        rule->field = flb_strndup(sentry->value, sentry->len);
-        rule->field_len = sentry->len;
-
-        /* Get remaining content (regular expression) */
-        sentry = mk_list_entry_last(split, struct flb_split_entry, _head);
-        rule->regex_pattern = flb_strndup(sentry->value, sentry->len);
-
         /* Release split */
         flb_utils_split_free(split);
 
@@ -121,16 +143,56 @@ static int set_rules(struct grep_ctx *ctx, struct flb_filter_instance *f_ins)
     return 0;
 }
 
-/* Given a msgpack record, do some filter action based on the defined rules */
-static inline int grep_filter_data(msgpack_object map, struct grep_ctx *ctx)
+static int find_val_at_path(msgpack_object map, struct mk_list *path, struct mk_list *head, msgpack_object **val)
 {
     int i;
     int klen;
-    int vlen;
     const char *key;
+    msgpack_object *k;
+    struct grep_path_component *p;
+
+    if (path == head) {
+        *val = &map;
+        return 0;
+    }
+
+    if (map.type != MSGPACK_OBJECT_MAP) {
+        return -1;
+    }
+
+    p = mk_list_entry(path, struct grep_path_component, _head);
+
+    for (i = 0; i < map.via.map.size; i++) {
+        k = &map.via.map.ptr[i].key;
+
+        if (k->type != MSGPACK_OBJECT_BIN &&
+            k->type != MSGPACK_OBJECT_STR) {
+            continue;
+        }
+
+        if (k->type == MSGPACK_OBJECT_STR) {
+            key  = k->via.str.ptr;
+            klen = k->via.str.size;
+        }
+        else {
+            key = k->via.bin.ptr;
+            klen = k->via.bin.size;
+        }
+
+        if (p->field_len == klen && strncmp(key, p->field, klen) == 0) {
+            return find_val_at_path(map.via.map.ptr[i].val, path->next, head, val);
+        }
+    }
+    return -1;
+}
+
+/* Given a msgpack record, do some filter action based on the defined rules */
+static inline int grep_filter_data(msgpack_object map, struct grep_ctx *ctx)
+{
+    int key_not_found;
+    int vlen;
     const char *val;
     ssize_t ret;
-    msgpack_object *k;
     msgpack_object *v;
     struct mk_list *head;
     struct grep_rule *rule;
@@ -139,34 +201,11 @@ static inline int grep_filter_data(msgpack_object map, struct grep_ctx *ctx)
     mk_list_foreach(head, &ctx->rules) {
         rule = mk_list_entry(head, struct grep_rule, _head);
 
-        /* Lookup target key/value */
-        for (i = 0; i < map.via.map.size; i++) {
-            k = &map.via.map.ptr[i].key;
-
-            if (k->type != MSGPACK_OBJECT_BIN &&
-                k->type != MSGPACK_OBJECT_STR) {
-                continue;
-            }
-
-            if (k->type == MSGPACK_OBJECT_STR) {
-                key  = k->via.str.ptr;
-                klen = k->via.str.size;
-            }
-            else {
-                key = k->via.bin.ptr;
-                klen = k->via.bin.size;
-            }
-
-            if (rule->field_len == klen &&
-                strncmp(key, rule->field, klen) == 0) {
-                break;
-            }
-
-            k = NULL;
-        }
+        /* Lookup target key/val */
+        key_not_found = find_val_at_path(map, rule->path.next, &rule->path, &v);
 
         /* If the key don't exists, take an action */
-        if (!k) {
+        if (key_not_found) {
             if (rule->type == GREP_REGEX) {
                 return GREP_RET_EXCLUDE;
             }
@@ -175,9 +214,6 @@ static inline int grep_filter_data(msgpack_object map, struct grep_ctx *ctx)
             }
         }
 
-        /* Based on the value of the key, do the regex */
-        v = &map.via.map.ptr[i].val;
-
         /* a value must be a string */
         if (v->type == MSGPACK_OBJECT_STR) {
             val  = v->via.str.ptr;