// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/platform_dependent/smoke_test/proto/host_system_info.proto

package host_system_info // import "pixielabs.ai/platform_dependent/smoke-test"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type OS int32

const (
	UNKNOWN_OS OS = 0
	LINUX      OS = 1
	WINDOWS    OS = 2
	DARWIN     OS = 3
	IOS        OS = 4
	ANDROID    OS = 5
)

var OS_name = map[int32]string{
	0: "UNKNOWN_OS",
	1: "LINUX",
	2: "WINDOWS",
	3: "DARWIN",
	4: "IOS",
	5: "ANDROID",
}
var OS_value = map[string]int32{
	"UNKNOWN_OS": 0,
	"LINUX":      1,
	"WINDOWS":    2,
	"DARWIN":     3,
	"IOS":        4,
	"ANDROID":    5,
}

func (OS) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{0}
}

type OSArchitecture int32

const (
	UNKNOWN_ARCHITECTURE OSArchitecture = 0
	x86_64               OSArchitecture = 1
	i386                 OSArchitecture = 2
	i586                 OSArchitecture = 3
)

var OSArchitecture_name = map[int32]string{
	0: "UNKNOWN_ARCHITECTURE",
	1: "x86_64",
	2: "i386",
	3: "i586",
}
var OSArchitecture_value = map[string]int32{
	"UNKNOWN_ARCHITECTURE": 0,
	"x86_64":               1,
	"i386":                 2,
	"i586":                 3,
}

func (OSArchitecture) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{1}
}

type TestStatus int32

const (
	UNKNOWN       TestStatus = 0
	FAIL          TestStatus = 1
	PASS          TestStatus = 2
	FAILED_TO_RUN TestStatus = 3
)

var TestStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "FAIL",
	2: "PASS",
	3: "FAILED_TO_RUN",
}
var TestStatus_value = map[string]int32{
	"UNKNOWN":       0,
	"FAIL":          1,
	"PASS":          2,
	"FAILED_TO_RUN": 3,
}

func (TestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{2}
}

type Processor struct {
	ID                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	VendorID             string   `protobuf:"bytes,2,opt,name=vendor_id,json=vendorId,proto3" json:"vendor_id,omitempty"`
	Model                int64    `protobuf:"varint,3,opt,name=model,proto3" json:"model,omitempty"`
	ModelName            string   `protobuf:"bytes,4,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty"`
	Flags                []string `protobuf:"bytes,5,rep,name=flags" json:"flags,omitempty"`
	Cores                int64    `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	MHz                  float64  `protobuf:"fixed64,7,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize            int64    `protobuf:"varint,8,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	PhysicalID           int64    `protobuf:"varint,9,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	CoreID               int64    `protobuf:"varint,10,opt,name=core_id,json=coreId,proto3" json:"core_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Processor) Reset()      { *m = Processor{} }
func (*Processor) ProtoMessage() {}
func (*Processor) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{0}
}
func (m *Processor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Processor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Processor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Processor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Processor.Merge(dst, src)
}
func (m *Processor) XXX_Size() int {
	return m.Size()
}
func (m *Processor) XXX_DiscardUnknown() {
	xxx_messageInfo_Processor.DiscardUnknown(m)
}

var xxx_messageInfo_Processor proto.InternalMessageInfo

func (m *Processor) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Processor) GetVendorID() string {
	if m != nil {
		return m.VendorID
	}
	return ""
}

func (m *Processor) GetModel() int64 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *Processor) GetModelName() string {
	if m != nil {
		return m.ModelName
	}
	return ""
}

func (m *Processor) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Processor) GetCores() int64 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Processor) GetMHz() float64 {
	if m != nil {
		return m.MHz
	}
	return 0
}

func (m *Processor) GetCacheSize() int64 {
	if m != nil {
		return m.CacheSize
	}
	return 0
}

func (m *Processor) GetPhysicalID() int64 {
	if m != nil {
		return m.PhysicalID
	}
	return 0
}

func (m *Processor) GetCoreID() int64 {
	if m != nil {
		return m.CoreID
	}
	return 0
}

type CPUInfo struct {
	Processors           []*Processor `protobuf:"bytes,1,rep,name=processors" json:"processors,omitempty"`
	Error                string       `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CPUInfo) Reset()      { *m = CPUInfo{} }
func (*CPUInfo) ProtoMessage() {}
func (*CPUInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{1}
}
func (m *CPUInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CPUInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUInfo.Merge(dst, src)
}
func (m *CPUInfo) XXX_Size() int {
	return m.Size()
}
func (m *CPUInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CPUInfo proto.InternalMessageInfo

func (m *CPUInfo) GetProcessors() []*Processor {
	if m != nil {
		return m.Processors
	}
	return nil
}

func (m *CPUInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type MemInfo struct {
	MemTotal             uint64   `protobuf:"varint,1,opt,name=mem_total,json=memTotal,proto3" json:"mem_total,omitempty"`
	MemFree              uint64   `protobuf:"varint,2,opt,name=mem_free,json=memFree,proto3" json:"mem_free,omitempty"`
	MemAvailable         uint64   `protobuf:"varint,3,opt,name=mem_available,json=memAvailable,proto3" json:"mem_available,omitempty"`
	Buffers              uint64   `protobuf:"varint,4,opt,name=buffers,proto3" json:"buffers,omitempty"`
	Cached               uint64   `protobuf:"varint,5,opt,name=cached,proto3" json:"cached,omitempty"`
	SwapCached           uint64   `protobuf:"varint,6,opt,name=swap_cached,json=swapCached,proto3" json:"swap_cached,omitempty"`
	Active               uint64   `protobuf:"varint,7,opt,name=active,proto3" json:"active,omitempty"`
	Error                string   `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemInfo) Reset()      { *m = MemInfo{} }
func (*MemInfo) ProtoMessage() {}
func (*MemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{2}
}
func (m *MemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemInfo.Merge(dst, src)
}
func (m *MemInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemInfo proto.InternalMessageInfo

func (m *MemInfo) GetMemTotal() uint64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *MemInfo) GetMemFree() uint64 {
	if m != nil {
		return m.MemFree
	}
	return 0
}

func (m *MemInfo) GetMemAvailable() uint64 {
	if m != nil {
		return m.MemAvailable
	}
	return 0
}

func (m *MemInfo) GetBuffers() uint64 {
	if m != nil {
		return m.Buffers
	}
	return 0
}

func (m *MemInfo) GetCached() uint64 {
	if m != nil {
		return m.Cached
	}
	return 0
}

func (m *MemInfo) GetSwapCached() uint64 {
	if m != nil {
		return m.SwapCached
	}
	return 0
}

func (m *MemInfo) GetActive() uint64 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *MemInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SystemInfo struct {
	CpuInfo              *CPUInfo `protobuf:"bytes,1,opt,name=cpu_info,json=cpuInfo" json:"cpu_info,omitempty"`
	MemInfo              *MemInfo `protobuf:"bytes,2,opt,name=mem_info,json=memInfo" json:"mem_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SystemInfo) Reset()      { *m = SystemInfo{} }
func (*SystemInfo) ProtoMessage() {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{3}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(dst, src)
}
func (m *SystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

func (m *SystemInfo) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *SystemInfo) GetMemInfo() *MemInfo {
	if m != nil {
		return m.MemInfo
	}
	return nil
}

type LinuxOSInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PrettyName           string   `protobuf:"bytes,2,opt,name=pretty_name,json=prettyName,proto3" json:"pretty_name,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	ID                   string   `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	VersionID            string   `protobuf:"bytes,5,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
	VersionCodename      string   `protobuf:"bytes,6,opt,name=version_codename,json=versionCodename,proto3" json:"version_codename,omitempty"`
	BuildID              string   `protobuf:"bytes,7,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	IDLike               []string `protobuf:"bytes,8,rep,name=id_like,json=idLike" json:"id_like,omitempty"`
	CpeName              string   `protobuf:"bytes,9,opt,name=cpe_name,json=cpeName,proto3" json:"cpe_name,omitempty"`
	HomeUrl              string   `protobuf:"bytes,10,opt,name=home_url,json=homeUrl,proto3" json:"home_url,omitempty"`
	SupportUrl           string   `protobuf:"bytes,11,opt,name=support_url,json=supportUrl,proto3" json:"support_url,omitempty"`
	BugReportUrl         string   `protobuf:"bytes,12,opt,name=bug_report_url,json=bugReportUrl,proto3" json:"bug_report_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinuxOSInfo) Reset()      { *m = LinuxOSInfo{} }
func (*LinuxOSInfo) ProtoMessage() {}
func (*LinuxOSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{4}
}
func (m *LinuxOSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinuxOSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinuxOSInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinuxOSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinuxOSInfo.Merge(dst, src)
}
func (m *LinuxOSInfo) XXX_Size() int {
	return m.Size()
}
func (m *LinuxOSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LinuxOSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LinuxOSInfo proto.InternalMessageInfo

func (m *LinuxOSInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LinuxOSInfo) GetPrettyName() string {
	if m != nil {
		return m.PrettyName
	}
	return ""
}

func (m *LinuxOSInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LinuxOSInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *LinuxOSInfo) GetVersionID() string {
	if m != nil {
		return m.VersionID
	}
	return ""
}

func (m *LinuxOSInfo) GetVersionCodename() string {
	if m != nil {
		return m.VersionCodename
	}
	return ""
}

func (m *LinuxOSInfo) GetBuildID() string {
	if m != nil {
		return m.BuildID
	}
	return ""
}

func (m *LinuxOSInfo) GetIDLike() []string {
	if m != nil {
		return m.IDLike
	}
	return nil
}

func (m *LinuxOSInfo) GetCpeName() string {
	if m != nil {
		return m.CpeName
	}
	return ""
}

func (m *LinuxOSInfo) GetHomeUrl() string {
	if m != nil {
		return m.HomeUrl
	}
	return ""
}

func (m *LinuxOSInfo) GetSupportUrl() string {
	if m != nil {
		return m.SupportUrl
	}
	return ""
}

func (m *LinuxOSInfo) GetBugReportUrl() string {
	if m != nil {
		return m.BugReportUrl
	}
	return ""
}

type KernelInfo struct {
	KernelVersion        string   `protobuf:"bytes,1,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	MajorVersion         uint64   `protobuf:"varint,2,opt,name=major_version,json=majorVersion,proto3" json:"major_version,omitempty"`
	MinorVersion         uint64   `protobuf:"varint,3,opt,name=minor_version,json=minorVersion,proto3" json:"minor_version,omitempty"`
	PatchNumber          uint64   `protobuf:"varint,4,opt,name=patch_number,json=patchNumber,proto3" json:"patch_number,omitempty"`
	PreRelease           string   `protobuf:"bytes,5,opt,name=pre_release,json=preRelease,proto3" json:"pre_release,omitempty"`
	Build                string   `protobuf:"bytes,6,opt,name=build,proto3" json:"build,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KernelInfo) Reset()      { *m = KernelInfo{} }
func (*KernelInfo) ProtoMessage() {}
func (*KernelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{5}
}
func (m *KernelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KernelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KernelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *KernelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KernelInfo.Merge(dst, src)
}
func (m *KernelInfo) XXX_Size() int {
	return m.Size()
}
func (m *KernelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KernelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KernelInfo proto.InternalMessageInfo

func (m *KernelInfo) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *KernelInfo) GetMajorVersion() uint64 {
	if m != nil {
		return m.MajorVersion
	}
	return 0
}

func (m *KernelInfo) GetMinorVersion() uint64 {
	if m != nil {
		return m.MinorVersion
	}
	return 0
}

func (m *KernelInfo) GetPatchNumber() uint64 {
	if m != nil {
		return m.PatchNumber
	}
	return 0
}

func (m *KernelInfo) GetPreRelease() string {
	if m != nil {
		return m.PreRelease
	}
	return ""
}

func (m *KernelInfo) GetBuild() string {
	if m != nil {
		return m.Build
	}
	return ""
}

type HostInfo struct {
	OS            OS             `protobuf:"varint,1,opt,name=os,proto3,enum=host_system_info.OS" json:"os,omitempty"`
	KernelVersion *KernelInfo    `protobuf:"bytes,2,opt,name=kernel_version,json=kernelVersion" json:"kernel_version,omitempty"`
	OsArch        OSArchitecture `protobuf:"varint,3,opt,name=os_arch,json=osArch,proto3,enum=host_system_info.OSArchitecture" json:"os_arch,omitempty"`
	// Types that are valid to be assigned to OSDetails:
	//	*HostInfo_LinuxOSInfo
	OSDetails            isHostInfo_OSDetails `protobuf_oneof:"OSDetails"`
	HostName             string               `protobuf:"bytes,5,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	HostEnv              string               `protobuf:"bytes,6,opt,name=host_env,json=hostEnv,proto3" json:"host_env,omitempty"`
	Error                string               `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *HostInfo) Reset()      { *m = HostInfo{} }
func (*HostInfo) ProtoMessage() {}
func (*HostInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{6}
}
func (m *HostInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HostInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostInfo.Merge(dst, src)
}
func (m *HostInfo) XXX_Size() int {
	return m.Size()
}
func (m *HostInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HostInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HostInfo proto.InternalMessageInfo

type isHostInfo_OSDetails interface {
	isHostInfo_OSDetails()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostInfo_LinuxOSInfo struct {
	LinuxOSInfo *LinuxOSInfo `protobuf:"bytes,4,opt,name=linux_os_info,json=linuxOsInfo,oneof"`
}

func (*HostInfo_LinuxOSInfo) isHostInfo_OSDetails() {}

func (m *HostInfo) GetOSDetails() isHostInfo_OSDetails {
	if m != nil {
		return m.OSDetails
	}
	return nil
}

func (m *HostInfo) GetOS() OS {
	if m != nil {
		return m.OS
	}
	return UNKNOWN_OS
}

func (m *HostInfo) GetKernelVersion() *KernelInfo {
	if m != nil {
		return m.KernelVersion
	}
	return nil
}

func (m *HostInfo) GetOsArch() OSArchitecture {
	if m != nil {
		return m.OsArch
	}
	return UNKNOWN_ARCHITECTURE
}

func (m *HostInfo) GetLinuxOSInfo() *LinuxOSInfo {
	if x, ok := m.GetOSDetails().(*HostInfo_LinuxOSInfo); ok {
		return x.LinuxOSInfo
	}
	return nil
}

func (m *HostInfo) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *HostInfo) GetHostEnv() string {
	if m != nil {
		return m.HostEnv
	}
	return ""
}

func (m *HostInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HostInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HostInfo_OneofMarshaler, _HostInfo_OneofUnmarshaler, _HostInfo_OneofSizer, []interface{}{
		(*HostInfo_LinuxOSInfo)(nil),
	}
}

func _HostInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HostInfo)
	// OSDetails
	switch x := m.OSDetails.(type) {
	case *HostInfo_LinuxOSInfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LinuxOSInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HostInfo.OSDetails has unexpected type %T", x)
	}
	return nil
}

func _HostInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HostInfo)
	switch tag {
	case 4: // OSDetails.linux_os_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LinuxOSInfo)
		err := b.DecodeMessage(msg)
		m.OSDetails = &HostInfo_LinuxOSInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HostInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HostInfo)
	// OSDetails
	switch x := m.OSDetails.(type) {
	case *HostInfo_LinuxOSInfo:
		s := proto.Size(x.LinuxOSInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CheckInfo struct {
	TestKernelVersion    TestStatus `protobuf:"varint,1,opt,name=test_kernel_version,json=testKernelVersion,proto3,enum=host_system_info.TestStatus" json:"test_kernel_version,omitempty"`
	TestOS               TestStatus `protobuf:"varint,2,opt,name=test_os,json=testOs,proto3,enum=host_system_info.TestStatus" json:"test_os,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CheckInfo) Reset()      { *m = CheckInfo{} }
func (*CheckInfo) ProtoMessage() {}
func (*CheckInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{7}
}
func (m *CheckInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckInfo.Merge(dst, src)
}
func (m *CheckInfo) XXX_Size() int {
	return m.Size()
}
func (m *CheckInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CheckInfo proto.InternalMessageInfo

func (m *CheckInfo) GetTestKernelVersion() TestStatus {
	if m != nil {
		return m.TestKernelVersion
	}
	return UNKNOWN
}

func (m *CheckInfo) GetTestOS() TestStatus {
	if m != nil {
		return m.TestOS
	}
	return UNKNOWN
}

type BCCCheckInfo struct {
	TestCPUDistribution  TestStatus `protobuf:"varint,1,opt,name=test_cpu_distribution,json=testCpuDistribution,proto3,enum=host_system_info.TestStatus" json:"test_cpu_distribution,omitempty"`
	Status               TestStatus `protobuf:"varint,2,opt,name=status,proto3,enum=host_system_info.TestStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BCCCheckInfo) Reset()      { *m = BCCCheckInfo{} }
func (*BCCCheckInfo) ProtoMessage() {}
func (*BCCCheckInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_host_system_info_e977840cab36d05c, []int{8}
}
func (m *BCCCheckInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BCCCheckInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BCCCheckInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BCCCheckInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BCCCheckInfo.Merge(dst, src)
}
func (m *BCCCheckInfo) XXX_Size() int {
	return m.Size()
}
func (m *BCCCheckInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BCCCheckInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BCCCheckInfo proto.InternalMessageInfo

func (m *BCCCheckInfo) GetTestCPUDistribution() TestStatus {
	if m != nil {
		return m.TestCPUDistribution
	}
	return UNKNOWN
}

func (m *BCCCheckInfo) GetStatus() TestStatus {
	if m != nil {
		return m.Status
	}
	return UNKNOWN
}

func init() {
	proto.RegisterType((*Processor)(nil), "host_system_info.Processor")
	proto.RegisterType((*CPUInfo)(nil), "host_system_info.CPUInfo")
	proto.RegisterType((*MemInfo)(nil), "host_system_info.MemInfo")
	proto.RegisterType((*SystemInfo)(nil), "host_system_info.SystemInfo")
	proto.RegisterType((*LinuxOSInfo)(nil), "host_system_info.LinuxOSInfo")
	proto.RegisterType((*KernelInfo)(nil), "host_system_info.KernelInfo")
	proto.RegisterType((*HostInfo)(nil), "host_system_info.HostInfo")
	proto.RegisterType((*CheckInfo)(nil), "host_system_info.CheckInfo")
	proto.RegisterType((*BCCCheckInfo)(nil), "host_system_info.BCCCheckInfo")
	proto.RegisterEnum("host_system_info.OS", OS_name, OS_value)
	proto.RegisterEnum("host_system_info.OSArchitecture", OSArchitecture_name, OSArchitecture_value)
	proto.RegisterEnum("host_system_info.TestStatus", TestStatus_name, TestStatus_value)
}
func (x OS) String() string {
	s, ok := OS_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OSArchitecture) String() string {
	s, ok := OSArchitecture_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TestStatus) String() string {
	s, ok := TestStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Processor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Processor)
	if !ok {
		that2, ok := that.(Processor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.VendorID != that1.VendorID {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.ModelName != that1.ModelName {
		return false
	}
	if len(this.Flags) != len(that1.Flags) {
		return false
	}
	for i := range this.Flags {
		if this.Flags[i] != that1.Flags[i] {
			return false
		}
	}
	if this.Cores != that1.Cores {
		return false
	}
	if this.MHz != that1.MHz {
		return false
	}
	if this.CacheSize != that1.CacheSize {
		return false
	}
	if this.PhysicalID != that1.PhysicalID {
		return false
	}
	if this.CoreID != that1.CoreID {
		return false
	}
	return true
}
func (this *CPUInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPUInfo)
	if !ok {
		that2, ok := that.(CPUInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Processors) != len(that1.Processors) {
		return false
	}
	for i := range this.Processors {
		if !this.Processors[i].Equal(that1.Processors[i]) {
			return false
		}
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *MemInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MemInfo)
	if !ok {
		that2, ok := that.(MemInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemTotal != that1.MemTotal {
		return false
	}
	if this.MemFree != that1.MemFree {
		return false
	}
	if this.MemAvailable != that1.MemAvailable {
		return false
	}
	if this.Buffers != that1.Buffers {
		return false
	}
	if this.Cached != that1.Cached {
		return false
	}
	if this.SwapCached != that1.SwapCached {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *SystemInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemInfo)
	if !ok {
		that2, ok := that.(SystemInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CpuInfo.Equal(that1.CpuInfo) {
		return false
	}
	if !this.MemInfo.Equal(that1.MemInfo) {
		return false
	}
	return true
}
func (this *LinuxOSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxOSInfo)
	if !ok {
		that2, ok := that.(LinuxOSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PrettyName != that1.PrettyName {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.VersionID != that1.VersionID {
		return false
	}
	if this.VersionCodename != that1.VersionCodename {
		return false
	}
	if this.BuildID != that1.BuildID {
		return false
	}
	if len(this.IDLike) != len(that1.IDLike) {
		return false
	}
	for i := range this.IDLike {
		if this.IDLike[i] != that1.IDLike[i] {
			return false
		}
	}
	if this.CpeName != that1.CpeName {
		return false
	}
	if this.HomeUrl != that1.HomeUrl {
		return false
	}
	if this.SupportUrl != that1.SupportUrl {
		return false
	}
	if this.BugReportUrl != that1.BugReportUrl {
		return false
	}
	return true
}
func (this *KernelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KernelInfo)
	if !ok {
		that2, ok := that.(KernelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KernelVersion != that1.KernelVersion {
		return false
	}
	if this.MajorVersion != that1.MajorVersion {
		return false
	}
	if this.MinorVersion != that1.MinorVersion {
		return false
	}
	if this.PatchNumber != that1.PatchNumber {
		return false
	}
	if this.PreRelease != that1.PreRelease {
		return false
	}
	if this.Build != that1.Build {
		return false
	}
	return true
}
func (this *HostInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostInfo)
	if !ok {
		that2, ok := that.(HostInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OS != that1.OS {
		return false
	}
	if !this.KernelVersion.Equal(that1.KernelVersion) {
		return false
	}
	if this.OsArch != that1.OsArch {
		return false
	}
	if that1.OSDetails == nil {
		if this.OSDetails != nil {
			return false
		}
	} else if this.OSDetails == nil {
		return false
	} else if !this.OSDetails.Equal(that1.OSDetails) {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if this.HostEnv != that1.HostEnv {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *HostInfo_LinuxOSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostInfo_LinuxOSInfo)
	if !ok {
		that2, ok := that.(HostInfo_LinuxOSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LinuxOSInfo.Equal(that1.LinuxOSInfo) {
		return false
	}
	return true
}
func (this *CheckInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckInfo)
	if !ok {
		that2, ok := that.(CheckInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TestKernelVersion != that1.TestKernelVersion {
		return false
	}
	if this.TestOS != that1.TestOS {
		return false
	}
	return true
}
func (this *BCCCheckInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BCCCheckInfo)
	if !ok {
		that2, ok := that.(BCCCheckInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TestCPUDistribution != that1.TestCPUDistribution {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *Processor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&host_system_info.Processor{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "VendorID: "+fmt.Sprintf("%#v", this.VendorID)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "ModelName: "+fmt.Sprintf("%#v", this.ModelName)+",\n")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "Cores: "+fmt.Sprintf("%#v", this.Cores)+",\n")
	s = append(s, "MHz: "+fmt.Sprintf("%#v", this.MHz)+",\n")
	s = append(s, "CacheSize: "+fmt.Sprintf("%#v", this.CacheSize)+",\n")
	s = append(s, "PhysicalID: "+fmt.Sprintf("%#v", this.PhysicalID)+",\n")
	s = append(s, "CoreID: "+fmt.Sprintf("%#v", this.CoreID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPUInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&host_system_info.CPUInfo{")
	if this.Processors != nil {
		s = append(s, "Processors: "+fmt.Sprintf("%#v", this.Processors)+",\n")
	}
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MemInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&host_system_info.MemInfo{")
	s = append(s, "MemTotal: "+fmt.Sprintf("%#v", this.MemTotal)+",\n")
	s = append(s, "MemFree: "+fmt.Sprintf("%#v", this.MemFree)+",\n")
	s = append(s, "MemAvailable: "+fmt.Sprintf("%#v", this.MemAvailable)+",\n")
	s = append(s, "Buffers: "+fmt.Sprintf("%#v", this.Buffers)+",\n")
	s = append(s, "Cached: "+fmt.Sprintf("%#v", this.Cached)+",\n")
	s = append(s, "SwapCached: "+fmt.Sprintf("%#v", this.SwapCached)+",\n")
	s = append(s, "Active: "+fmt.Sprintf("%#v", this.Active)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&host_system_info.SystemInfo{")
	if this.CpuInfo != nil {
		s = append(s, "CpuInfo: "+fmt.Sprintf("%#v", this.CpuInfo)+",\n")
	}
	if this.MemInfo != nil {
		s = append(s, "MemInfo: "+fmt.Sprintf("%#v", this.MemInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinuxOSInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&host_system_info.LinuxOSInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PrettyName: "+fmt.Sprintf("%#v", this.PrettyName)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "VersionID: "+fmt.Sprintf("%#v", this.VersionID)+",\n")
	s = append(s, "VersionCodename: "+fmt.Sprintf("%#v", this.VersionCodename)+",\n")
	s = append(s, "BuildID: "+fmt.Sprintf("%#v", this.BuildID)+",\n")
	s = append(s, "IDLike: "+fmt.Sprintf("%#v", this.IDLike)+",\n")
	s = append(s, "CpeName: "+fmt.Sprintf("%#v", this.CpeName)+",\n")
	s = append(s, "HomeUrl: "+fmt.Sprintf("%#v", this.HomeUrl)+",\n")
	s = append(s, "SupportUrl: "+fmt.Sprintf("%#v", this.SupportUrl)+",\n")
	s = append(s, "BugReportUrl: "+fmt.Sprintf("%#v", this.BugReportUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KernelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&host_system_info.KernelInfo{")
	s = append(s, "KernelVersion: "+fmt.Sprintf("%#v", this.KernelVersion)+",\n")
	s = append(s, "MajorVersion: "+fmt.Sprintf("%#v", this.MajorVersion)+",\n")
	s = append(s, "MinorVersion: "+fmt.Sprintf("%#v", this.MinorVersion)+",\n")
	s = append(s, "PatchNumber: "+fmt.Sprintf("%#v", this.PatchNumber)+",\n")
	s = append(s, "PreRelease: "+fmt.Sprintf("%#v", this.PreRelease)+",\n")
	s = append(s, "Build: "+fmt.Sprintf("%#v", this.Build)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&host_system_info.HostInfo{")
	s = append(s, "OS: "+fmt.Sprintf("%#v", this.OS)+",\n")
	if this.KernelVersion != nil {
		s = append(s, "KernelVersion: "+fmt.Sprintf("%#v", this.KernelVersion)+",\n")
	}
	s = append(s, "OsArch: "+fmt.Sprintf("%#v", this.OsArch)+",\n")
	if this.OSDetails != nil {
		s = append(s, "OSDetails: "+fmt.Sprintf("%#v", this.OSDetails)+",\n")
	}
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "HostEnv: "+fmt.Sprintf("%#v", this.HostEnv)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostInfo_LinuxOSInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&host_system_info.HostInfo_LinuxOSInfo{` +
		`LinuxOSInfo:` + fmt.Sprintf("%#v", this.LinuxOSInfo) + `}`}, ", ")
	return s
}
func (this *CheckInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&host_system_info.CheckInfo{")
	s = append(s, "TestKernelVersion: "+fmt.Sprintf("%#v", this.TestKernelVersion)+",\n")
	s = append(s, "TestOS: "+fmt.Sprintf("%#v", this.TestOS)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BCCCheckInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&host_system_info.BCCCheckInfo{")
	s = append(s, "TestCPUDistribution: "+fmt.Sprintf("%#v", this.TestCPUDistribution)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringHostSystemInfo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Processor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Processor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.ID))
	}
	if len(m.VendorID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.VendorID)))
		i += copy(dAtA[i:], m.VendorID)
	}
	if m.Model != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Model))
	}
	if len(m.ModelName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.ModelName)))
		i += copy(dAtA[i:], m.ModelName)
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Cores != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Cores))
	}
	if m.MHz != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MHz))))
		i += 8
	}
	if m.CacheSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.CacheSize))
	}
	if m.PhysicalID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.PhysicalID))
	}
	if m.CoreID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.CoreID))
	}
	return i, nil
}

func (m *CPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Processors) > 0 {
		for _, msg := range m.Processors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHostSystemInfo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *MemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemTotal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Buffers))
	}
	if m.Cached != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.SwapCached))
	}
	if m.Active != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Active))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.CpuInfo.Size()))
		n1, err := m.CpuInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MemInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MemInfo.Size()))
		n2, err := m.MemInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *LinuxOSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxOSInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PrettyName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.PrettyName)))
		i += copy(dAtA[i:], m.PrettyName)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.VersionID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.VersionID)))
		i += copy(dAtA[i:], m.VersionID)
	}
	if len(m.VersionCodename) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.VersionCodename)))
		i += copy(dAtA[i:], m.VersionCodename)
	}
	if len(m.BuildID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.BuildID)))
		i += copy(dAtA[i:], m.BuildID)
	}
	if len(m.IDLike) > 0 {
		for _, s := range m.IDLike {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CpeName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.CpeName)))
		i += copy(dAtA[i:], m.CpeName)
	}
	if len(m.HomeUrl) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.HomeUrl)))
		i += copy(dAtA[i:], m.HomeUrl)
	}
	if len(m.SupportUrl) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.SupportUrl)))
		i += copy(dAtA[i:], m.SupportUrl)
	}
	if len(m.BugReportUrl) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.BugReportUrl)))
		i += copy(dAtA[i:], m.BugReportUrl)
	}
	return i, nil
}

func (m *KernelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KernelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KernelVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.KernelVersion)))
		i += copy(dAtA[i:], m.KernelVersion)
	}
	if m.MajorVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MajorVersion))
	}
	if m.MinorVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.MinorVersion))
	}
	if m.PatchNumber != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.PatchNumber))
	}
	if len(m.PreRelease) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.PreRelease)))
		i += copy(dAtA[i:], m.PreRelease)
	}
	if len(m.Build) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Build)))
		i += copy(dAtA[i:], m.Build)
	}
	return i, nil
}

func (m *HostInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OS != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.OS))
	}
	if m.KernelVersion != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.KernelVersion.Size()))
		n3, err := m.KernelVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.OsArch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.OsArch))
	}
	if m.OSDetails != nil {
		nn4, err := m.OSDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.HostEnv) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.HostEnv)))
		i += copy(dAtA[i:], m.HostEnv)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *HostInfo_LinuxOSInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LinuxOSInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.LinuxOSInfo.Size()))
		n5, err := m.LinuxOSInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *CheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TestKernelVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.TestKernelVersion))
	}
	if m.TestOS != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.TestOS))
	}
	return i, nil
}

func (m *BCCCheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BCCCheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TestCPUDistribution != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.TestCPUDistribution))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHostSystemInfo(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func encodeVarintHostSystemInfo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Processor) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.ID))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if m.Model != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Model))
	}
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovHostSystemInfo(uint64(l))
		}
	}
	if m.Cores != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Cores))
	}
	if m.MHz != 0 {
		n += 9
	}
	if m.CacheSize != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.CacheSize))
	}
	if m.PhysicalID != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.PhysicalID))
	}
	if m.CoreID != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.CoreID))
	}
	return n
}

func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Processors) > 0 {
		for _, e := range m.Processors {
			l = e.Size()
			n += 1 + l + sovHostSystemInfo(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *MemInfo) Size() (n int) {
	var l int
	_ = l
	if m.MemTotal != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.MemTotal))
	}
	if m.MemFree != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.MemFree))
	}
	if m.MemAvailable != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Buffers))
	}
	if m.Cached != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.SwapCached))
	}
	if m.Active != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Active))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	var l int
	_ = l
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if m.MemInfo != nil {
		l = m.MemInfo.Size()
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *LinuxOSInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.PrettyName)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.VersionID)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.VersionCodename)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.BuildID)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if len(m.IDLike) > 0 {
		for _, s := range m.IDLike {
			l = len(s)
			n += 1 + l + sovHostSystemInfo(uint64(l))
		}
	}
	l = len(m.CpeName)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.HomeUrl)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.SupportUrl)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.BugReportUrl)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *KernelInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if m.MajorVersion != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.MajorVersion))
	}
	if m.MinorVersion != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.MinorVersion))
	}
	if m.PatchNumber != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.PatchNumber))
	}
	l = len(m.PreRelease)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.Build)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *HostInfo) Size() (n int) {
	var l int
	_ = l
	if m.OS != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.OS))
	}
	if m.KernelVersion != nil {
		l = m.KernelVersion.Size()
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	if m.OsArch != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.OsArch))
	}
	if m.OSDetails != nil {
		n += m.OSDetails.Size()
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.HostEnv)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}

func (m *HostInfo_LinuxOSInfo) Size() (n int) {
	var l int
	_ = l
	if m.LinuxOSInfo != nil {
		l = m.LinuxOSInfo.Size()
		n += 1 + l + sovHostSystemInfo(uint64(l))
	}
	return n
}
func (m *CheckInfo) Size() (n int) {
	var l int
	_ = l
	if m.TestKernelVersion != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.TestKernelVersion))
	}
	if m.TestOS != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.TestOS))
	}
	return n
}

func (m *BCCCheckInfo) Size() (n int) {
	var l int
	_ = l
	if m.TestCPUDistribution != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.TestCPUDistribution))
	}
	if m.Status != 0 {
		n += 1 + sovHostSystemInfo(uint64(m.Status))
	}
	return n
}

func sovHostSystemInfo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHostSystemInfo(x uint64) (n int) {
	return sovHostSystemInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Processor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Processor{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`VendorID:` + fmt.Sprintf("%v", this.VendorID) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`ModelName:` + fmt.Sprintf("%v", this.ModelName) + `,`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`Cores:` + fmt.Sprintf("%v", this.Cores) + `,`,
		`MHz:` + fmt.Sprintf("%v", this.MHz) + `,`,
		`CacheSize:` + fmt.Sprintf("%v", this.CacheSize) + `,`,
		`PhysicalID:` + fmt.Sprintf("%v", this.PhysicalID) + `,`,
		`CoreID:` + fmt.Sprintf("%v", this.CoreID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPUInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPUInfo{`,
		`Processors:` + strings.Replace(fmt.Sprintf("%v", this.Processors), "Processor", "Processor", 1) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemInfo{`,
		`MemTotal:` + fmt.Sprintf("%v", this.MemTotal) + `,`,
		`MemFree:` + fmt.Sprintf("%v", this.MemFree) + `,`,
		`MemAvailable:` + fmt.Sprintf("%v", this.MemAvailable) + `,`,
		`Buffers:` + fmt.Sprintf("%v", this.Buffers) + `,`,
		`Cached:` + fmt.Sprintf("%v", this.Cached) + `,`,
		`SwapCached:` + fmt.Sprintf("%v", this.SwapCached) + `,`,
		`Active:` + fmt.Sprintf("%v", this.Active) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SystemInfo{`,
		`CpuInfo:` + strings.Replace(fmt.Sprintf("%v", this.CpuInfo), "CPUInfo", "CPUInfo", 1) + `,`,
		`MemInfo:` + strings.Replace(fmt.Sprintf("%v", this.MemInfo), "MemInfo", "MemInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinuxOSInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinuxOSInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PrettyName:` + fmt.Sprintf("%v", this.PrettyName) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`VersionID:` + fmt.Sprintf("%v", this.VersionID) + `,`,
		`VersionCodename:` + fmt.Sprintf("%v", this.VersionCodename) + `,`,
		`BuildID:` + fmt.Sprintf("%v", this.BuildID) + `,`,
		`IDLike:` + fmt.Sprintf("%v", this.IDLike) + `,`,
		`CpeName:` + fmt.Sprintf("%v", this.CpeName) + `,`,
		`HomeUrl:` + fmt.Sprintf("%v", this.HomeUrl) + `,`,
		`SupportUrl:` + fmt.Sprintf("%v", this.SupportUrl) + `,`,
		`BugReportUrl:` + fmt.Sprintf("%v", this.BugReportUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KernelInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KernelInfo{`,
		`KernelVersion:` + fmt.Sprintf("%v", this.KernelVersion) + `,`,
		`MajorVersion:` + fmt.Sprintf("%v", this.MajorVersion) + `,`,
		`MinorVersion:` + fmt.Sprintf("%v", this.MinorVersion) + `,`,
		`PatchNumber:` + fmt.Sprintf("%v", this.PatchNumber) + `,`,
		`PreRelease:` + fmt.Sprintf("%v", this.PreRelease) + `,`,
		`Build:` + fmt.Sprintf("%v", this.Build) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostInfo{`,
		`OS:` + fmt.Sprintf("%v", this.OS) + `,`,
		`KernelVersion:` + strings.Replace(fmt.Sprintf("%v", this.KernelVersion), "KernelInfo", "KernelInfo", 1) + `,`,
		`OsArch:` + fmt.Sprintf("%v", this.OsArch) + `,`,
		`OSDetails:` + fmt.Sprintf("%v", this.OSDetails) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`HostEnv:` + fmt.Sprintf("%v", this.HostEnv) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostInfo_LinuxOSInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostInfo_LinuxOSInfo{`,
		`LinuxOSInfo:` + strings.Replace(fmt.Sprintf("%v", this.LinuxOSInfo), "LinuxOSInfo", "LinuxOSInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckInfo{`,
		`TestKernelVersion:` + fmt.Sprintf("%v", this.TestKernelVersion) + `,`,
		`TestOS:` + fmt.Sprintf("%v", this.TestOS) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BCCCheckInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BCCCheckInfo{`,
		`TestCPUDistribution:` + fmt.Sprintf("%v", this.TestCPUDistribution) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringHostSystemInfo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Processor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Processor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Processor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MHz", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MHz = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalID", wireType)
			}
			m.PhysicalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreID", wireType)
			}
			m.CoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoreID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processors = append(m.Processors, &Processor{})
			if err := m.Processors[len(m.Processors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			m.MemTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			m.MemFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAvailable", wireType)
			}
			m.MemAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemAvailable |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffers", wireType)
			}
			m.Buffers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buffers |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			m.Cached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cached |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCached", wireType)
			}
			m.SwapCached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapCached |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Active |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemInfo == nil {
				m.MemInfo = &MemInfo{}
			}
			if err := m.MemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxOSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxOSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxOSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrettyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrettyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCodename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionCodename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDLike", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDLike = append(m.IDLike, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BugReportUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BugReportUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KernelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KernelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KernelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorVersion", wireType)
			}
			m.MajorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MajorVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorVersion", wireType)
			}
			m.MinorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinorVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchNumber", wireType)
			}
			m.PatchNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatchNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreRelease", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreRelease = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Build = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			m.OS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OS |= (OS(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KernelVersion == nil {
				m.KernelVersion = &KernelInfo{}
			}
			if err := m.KernelVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsArch", wireType)
			}
			m.OsArch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsArch |= (OSArchitecture(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinuxOSInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinuxOSInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OSDetails = &HostInfo_LinuxOSInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostEnv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostEnv = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestKernelVersion", wireType)
			}
			m.TestKernelVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestKernelVersion |= (TestStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestOS", wireType)
			}
			m.TestOS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestOS |= (TestStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BCCCheckInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BCCCheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BCCCheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCPUDistribution", wireType)
			}
			m.TestCPUDistribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestCPUDistribution |= (TestStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TestStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHostSystemInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHostSystemInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHostSystemInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHostSystemInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHostSystemInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHostSystemInfo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHostSystemInfo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHostSystemInfo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHostSystemInfo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHostSystemInfo   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("src/platform_dependent/smoke_test/proto/host_system_info.proto", fileDescriptor_host_system_info_e977840cab36d05c)
}

var fileDescriptor_host_system_info_e977840cab36d05c = []byte{
	// 1361 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x16, 0xf5, 0x47, 0xf1, 0xc8, 0x56, 0x14, 0x26, 0x37, 0x57, 0xbe, 0xb9, 0x91, 0x7c, 0x95,
	0xdb, 0xc2, 0x0d, 0x12, 0x1b, 0x70, 0x52, 0x23, 0x45, 0x80, 0xa2, 0xfa, 0x71, 0x60, 0x36, 0x8e,
	0x68, 0x8c, 0xec, 0xb8, 0xe8, 0x86, 0xa0, 0xc8, 0x91, 0xc5, 0x9a, 0xd4, 0x10, 0x33, 0xa4, 0xeb,
	0x78, 0xd5, 0x47, 0xe8, 0xae, 0x9b, 0x3e, 0x40, 0x77, 0x7d, 0x84, 0x6e, 0xbb, 0xcc, 0xae, 0x5d,
	0x09, 0x0d, 0xbb, 0xe9, 0x32, 0x28, 0xfa, 0x00, 0xc5, 0x1c, 0x52, 0xb1, 0x12, 0x3b, 0x68, 0x56,
	0x9e, 0xf3, 0x9d, 0x9f, 0x99, 0xf3, 0x9d, 0xef, 0xd0, 0x82, 0x4f, 0x05, 0x77, 0x36, 0x42, 0xdf,
	0x8e, 0xc6, 0x8c, 0x07, 0x96, 0x4b, 0x43, 0x3a, 0x75, 0xe9, 0x34, 0xda, 0x10, 0x01, 0x3b, 0xa6,
	0x56, 0x44, 0x45, 0xb4, 0x11, 0x72, 0x16, 0xb1, 0x8d, 0x09, 0x13, 0x91, 0x25, 0x9e, 0x8b, 0x88,
	0x06, 0x96, 0x37, 0x1d, 0xb3, 0x75, 0x84, 0xf5, 0xfa, 0xdb, 0xf8, 0x7f, 0xee, 0x1d, 0x79, 0xd1,
	0x24, 0x1e, 0xad, 0x3b, 0x2c, 0xd8, 0x38, 0x62, 0x47, 0x2c, 0xcd, 0x1f, 0xc5, 0x63, 0xb4, 0xd2,
	0x62, 0xf2, 0x94, 0x16, 0x68, 0xff, 0x94, 0x07, 0x6d, 0x8f, 0x33, 0x87, 0x0a, 0xc1, 0xb8, 0x7e,
	0x03, 0xf2, 0x9e, 0xdb, 0x50, 0x56, 0x95, 0xb5, 0x42, 0xb7, 0x9c, 0xcc, 0x5a, 0x79, 0xa3, 0x4f,
	0xf2, 0x9e, 0xab, 0x7f, 0x04, 0xda, 0x09, 0x9d, 0xba, 0x8c, 0x5b, 0x9e, 0xdb, 0xc8, 0xaf, 0x2a,
	0x6b, 0x5a, 0x77, 0x29, 0x99, 0xb5, 0x2a, 0xcf, 0x10, 0x34, 0xfa, 0xa4, 0x92, 0xba, 0x0d, 0x57,
	0xbf, 0x0e, 0xa5, 0x80, 0xb9, 0xd4, 0x6f, 0x14, 0x64, 0x15, 0x92, 0x1a, 0xfa, 0x2d, 0x00, 0x3c,
	0x58, 0x53, 0x3b, 0xa0, 0x8d, 0xa2, 0xac, 0x40, 0x34, 0x44, 0x06, 0x76, 0x40, 0x65, 0xd2, 0xd8,
	0xb7, 0x8f, 0x44, 0xa3, 0xb4, 0x5a, 0x58, 0xd3, 0x48, 0x6a, 0x48, 0xd4, 0x61, 0x9c, 0x8a, 0x46,
	0x39, 0x2d, 0x85, 0x86, 0xbe, 0x02, 0x85, 0x60, 0x72, 0xd6, 0x50, 0x57, 0x95, 0x35, 0xa5, 0xab,
	0x26, 0xb3, 0x56, 0xe1, 0xe9, 0xce, 0x19, 0x91, 0x98, 0xbc, 0xc5, 0xb1, 0x9d, 0x09, 0xb5, 0x84,
	0x77, 0x46, 0x1b, 0x15, 0xcc, 0xd2, 0x10, 0x19, 0x7a, 0x67, 0x54, 0xdf, 0x80, 0x6a, 0x38, 0x79,
	0x2e, 0x3c, 0xc7, 0xf6, 0x65, 0x1f, 0x1a, 0xb6, 0x59, 0x4b, 0x66, 0x2d, 0xd8, 0xcb, 0x60, 0xa3,
	0x4f, 0x60, 0x1e, 0x62, 0xb8, 0xfa, 0x6d, 0x50, 0xe5, 0x9d, 0x32, 0x18, 0x30, 0x18, 0x92, 0x59,
	0xab, 0xdc, 0x63, 0x9c, 0x1a, 0x7d, 0x52, 0x96, 0x2e, 0xc3, 0x6d, 0x1f, 0x81, 0xda, 0xdb, 0x3b,
	0x30, 0xa6, 0x63, 0xa6, 0x3f, 0x02, 0x08, 0xe7, 0x5c, 0x8a, 0x86, 0xb2, 0x5a, 0x58, 0xab, 0x6e,
	0xde, 0x5c, 0xbf, 0x30, 0xba, 0xd7, 0x7c, 0x93, 0x85, 0x70, 0xbd, 0x05, 0x25, 0xca, 0x39, 0xe3,
	0x19, 0xbf, 0x5a, 0x32, 0x6b, 0x95, 0xb6, 0x25, 0x40, 0x52, 0xbc, 0xfd, 0xa7, 0x02, 0xea, 0x53,
	0x1a, 0xe0, 0x4d, 0x37, 0x41, 0x0b, 0x68, 0x60, 0x45, 0x2c, 0xb2, 0x7d, 0x9c, 0x57, 0x91, 0x54,
	0x02, 0x1a, 0xec, 0x4b, 0x5b, 0x5f, 0x01, 0x79, 0xb6, 0xc6, 0x9c, 0x52, 0x2c, 0x56, 0x24, 0x6a,
	0x40, 0x83, 0xc7, 0x9c, 0x52, 0xfd, 0x36, 0x2c, 0x4b, 0x97, 0x7d, 0x62, 0x7b, 0xbe, 0x3d, 0xf2,
	0x29, 0x4e, 0xa9, 0x48, 0x96, 0x02, 0x1a, 0x74, 0xe6, 0x98, 0xde, 0x00, 0x75, 0x14, 0x8f, 0xc7,
	0x94, 0x0b, 0x9c, 0x54, 0x91, 0xcc, 0x4d, 0xfd, 0x06, 0x94, 0x91, 0x4e, 0xb7, 0x51, 0x42, 0x47,
	0x66, 0xe9, 0x2d, 0xa8, 0x8a, 0xaf, 0xed, 0xd0, 0xca, 0x9c, 0x65, 0x74, 0x82, 0x84, 0x7a, 0x69,
	0xc0, 0x0d, 0x28, 0xdb, 0x4e, 0xe4, 0x9d, 0x50, 0x9c, 0x5b, 0x91, 0x64, 0xd6, 0x79, 0xd3, 0x95,
	0x77, 0x34, 0x7d, 0x0a, 0x30, 0x44, 0xea, 0xb0, 0xed, 0x07, 0x50, 0x71, 0xc2, 0x18, 0x59, 0xc4,
	0xae, 0xab, 0x9b, 0x2b, 0x17, 0xe9, 0xcd, 0xa6, 0x41, 0x54, 0x27, 0x8c, 0xe7, 0x59, 0x41, 0xe6,
	0x44, 0x3e, 0x2e, 0xcd, 0xca, 0x98, 0x45, 0xaa, 0xe4, 0xa1, 0xfd, 0x5d, 0x01, 0xaa, 0xbb, 0xde,
	0x34, 0x3e, 0x35, 0x87, 0x58, 0x45, 0x87, 0x22, 0x8a, 0x57, 0x41, 0xf1, 0xe2, 0x59, 0xf6, 0x1d,
	0x72, 0x1a, 0x45, 0xcf, 0x53, 0x5d, 0xe3, 0xe4, 0xe4, 0x50, 0x25, 0x84, 0xc2, 0x6e, 0x80, 0x7a,
	0x42, 0xb9, 0xf0, 0xd8, 0x14, 0x99, 0xd6, 0xc8, 0xdc, 0xcc, 0x56, 0x0d, 0x37, 0xe1, 0x8d, 0x55,
	0xbb, 0x0b, 0x90, 0x85, 0x48, 0xd9, 0x95, 0xd0, 0xbf, 0x9c, 0xcc, 0x5a, 0xda, 0xb3, 0x14, 0x35,
	0xfa, 0x44, 0xcb, 0x02, 0x0c, 0xb9, 0x98, 0xf5, 0x79, 0xb4, 0xc3, 0x5c, 0x8a, 0xaf, 0x28, 0xe3,
	0x45, 0x57, 0x32, 0xbc, 0x97, 0xc1, 0xfa, 0x87, 0x50, 0x19, 0xc5, 0x9e, 0xef, 0xca, 0xb2, 0x2a,
	0x96, 0xad, 0x26, 0xb3, 0x96, 0xda, 0x95, 0x98, 0xd1, 0x97, 0x33, 0x96, 0x07, 0x14, 0xbd, 0xe7,
	0x5a, 0xbe, 0x77, 0x2c, 0x37, 0xa8, 0xb0, 0xa6, 0xa5, 0xa2, 0x37, 0xfa, 0xbb, 0xde, 0x31, 0x25,
	0x65, 0xcf, 0x95, 0x7f, 0xa5, 0xc4, 0x9c, 0x90, 0xa6, 0x5d, 0x6b, 0x69, 0x63, 0x4e, 0x48, 0xb1,
	0xe5, 0x15, 0xa8, 0x4c, 0x58, 0x40, 0xad, 0x98, 0xfb, 0xb8, 0x35, 0x1a, 0x51, 0xa5, 0x7d, 0xc0,
	0x7d, 0x94, 0x49, 0x1c, 0x86, 0x8c, 0x47, 0xe8, 0xad, 0xa6, 0x74, 0x65, 0x90, 0x0c, 0xf8, 0x3f,
	0xd4, 0x46, 0xf1, 0x91, 0xc5, 0xe9, 0xeb, 0x98, 0x25, 0x8c, 0x59, 0x1a, 0xc5, 0x47, 0x84, 0x66,
	0x51, 0xed, 0x5f, 0x14, 0x80, 0x27, 0x94, 0x4f, 0xa9, 0x8f, 0x83, 0xf9, 0x00, 0x6a, 0xc7, 0x68,
	0x59, 0x73, 0xaa, 0xd3, 0x11, 0x2d, 0xa7, 0x68, 0xc6, 0x1b, 0x4a, 0xdf, 0xfe, 0x8a, 0xf1, 0xd7,
	0x51, 0xf9, 0x4c, 0xfa, 0x12, 0x5c, 0x0c, 0xf2, 0xa6, 0x0b, 0x41, 0xf3, 0xfd, 0x90, 0xe0, 0x3c,
	0xe8, 0x7f, 0xb0, 0x14, 0xda, 0x91, 0x33, 0xb1, 0xa6, 0x71, 0x30, 0xa2, 0x3c, 0x5b, 0x92, 0x2a,
	0x62, 0x03, 0x84, 0x32, 0x61, 0x58, 0x9c, 0xfa, 0xd4, 0x16, 0x34, 0x1d, 0x23, 0x0a, 0x83, 0xa4,
	0x88, 0xfc, 0xb6, 0x21, 0xe1, 0xd9, 0xb4, 0x52, 0xa3, 0xfd, 0x57, 0x1e, 0x2a, 0x3b, 0x4c, 0x44,
	0xd8, 0xd7, 0x5d, 0xc8, 0x33, 0x81, 0xbd, 0xd4, 0x36, 0xaf, 0x5f, 0x14, 0xac, 0x39, 0x4c, 0x75,
	0x63, 0x0e, 0x49, 0x9e, 0x09, 0xbd, 0x77, 0x81, 0x85, 0x54, 0xea, 0xff, 0xbd, 0x98, 0x79, 0xce,
	0xdd, 0xdb, 0x1c, 0x7d, 0x02, 0x2a, 0x13, 0x96, 0xcd, 0x9d, 0x09, 0x36, 0x5e, 0xdb, 0x5c, 0xbd,
	0xec, 0xde, 0x0e, 0x77, 0x26, 0x5e, 0x44, 0x9d, 0x28, 0xe6, 0x94, 0x94, 0x99, 0x90, 0xb6, 0xbe,
	0x0f, 0xcb, 0xbe, 0xdc, 0x16, 0x8b, 0x89, 0x74, 0xd3, 0x8a, 0x78, 0xfd, 0xad, 0x8b, 0x05, 0x16,
	0x96, 0xaa, 0x7b, 0x25, 0x99, 0xb5, 0x16, 0xb7, 0x6c, 0x27, 0x47, 0xaa, 0x58, 0xc6, 0x14, 0xf3,
	0xef, 0x1c, 0xe6, 0xa3, 0xd0, 0x52, 0x16, 0x2b, 0x12, 0x38, 0x57, 0x9a, 0x88, 0x2c, 0x3a, 0x3d,
	0xc9, 0x68, 0x54, 0xa5, 0xbd, 0x3d, 0x3d, 0x39, 0xff, 0xae, 0xa8, 0x97, 0x7f, 0x57, 0xba, 0x55,
	0xd0, 0xcc, 0x61, 0x9f, 0x46, 0xb6, 0xe7, 0x8b, 0xf6, 0xf7, 0x0a, 0x68, 0xbd, 0x09, 0x75, 0x8e,
	0xf1, 0xce, 0x5d, 0xb8, 0x26, 0xff, 0xf1, 0x5a, 0x97, 0x88, 0xaa, 0x76, 0x19, 0x9d, 0xfb, 0x54,
	0x44, 0xc3, 0xc8, 0x8e, 0x62, 0x41, 0xae, 0xca, 0xc4, 0x27, 0x6f, 0x50, 0xda, 0x01, 0x15, 0xab,
	0x31, 0x81, 0x03, 0xf9, 0x87, 0x0a, 0xe9, 0xb2, 0x49, 0xdb, 0x1c, 0x92, 0xb2, 0x4c, 0x34, 0x45,
	0xfb, 0x47, 0x05, 0x96, 0xba, 0xbd, 0xde, 0xf9, 0x0b, 0x3d, 0xf8, 0x17, 0xd6, 0x94, 0xdf, 0x42,
	0xd7, 0x13, 0x11, 0xf7, 0x46, 0x71, 0xf4, 0x9e, 0x6f, 0xec, 0xfe, 0x3b, 0x99, 0xb5, 0xae, 0x49,
	0xbb, 0xb7, 0x77, 0xd0, 0x5f, 0x48, 0x26, 0xd8, 0x75, 0x2f, 0x8c, 0x17, 0x41, 0xfd, 0x01, 0x94,
	0x05, 0xe6, 0xbd, 0xcf, 0xeb, 0x49, 0x16, 0x7b, 0x67, 0x00, 0x79, 0x73, 0xa8, 0xd7, 0x00, 0x0e,
	0x06, 0x4f, 0x06, 0xe6, 0xe1, 0xc0, 0x32, 0x87, 0xf5, 0x9c, 0xae, 0x41, 0x69, 0xd7, 0x18, 0x1c,
	0x7c, 0x51, 0x57, 0xf4, 0x2a, 0xa8, 0x87, 0xc6, 0xa0, 0x6f, 0x1e, 0x0e, 0xeb, 0x79, 0x1d, 0xa0,
	0xdc, 0xef, 0x90, 0x43, 0x63, 0x50, 0x2f, 0xe8, 0x2a, 0x14, 0x0c, 0x73, 0x58, 0x2f, 0xca, 0x88,
	0xce, 0xa0, 0x4f, 0x4c, 0xa3, 0x5f, 0x2f, 0xdd, 0xf9, 0x1c, 0x6a, 0x6f, 0xca, 0x4e, 0x6f, 0xc0,
	0xf5, 0x79, 0xed, 0x0e, 0xe9, 0xed, 0x18, 0xfb, 0xdb, 0xbd, 0xfd, 0x03, 0xb2, 0x5d, 0xcf, 0xc9,
	0x6a, 0xa7, 0x0f, 0xb7, 0xac, 0xad, 0x07, 0x75, 0x45, 0xaf, 0x40, 0xd1, 0xbb, 0xff, 0x70, 0xab,
	0x9e, 0xc7, 0xd3, 0xc7, 0x0f, 0xb7, 0xea, 0x85, 0x3b, 0x9f, 0x01, 0x9c, 0xbf, 0x58, 0x5e, 0x93,
	0xd5, 0xa9, 0xe7, 0x64, 0xd0, 0xe3, 0x8e, 0xb1, 0x9b, 0x26, 0xee, 0x75, 0x86, 0xf2, 0x71, 0x57,
	0x61, 0x59, 0x62, 0xdb, 0x7d, 0x6b, 0xdf, 0xb4, 0xc8, 0xc1, 0xa0, 0x5e, 0xe8, 0x7a, 0x2f, 0x5e,
	0x36, 0x73, 0xbf, 0xbe, 0x6c, 0xe6, 0x5e, 0xbd, 0x6c, 0x2a, 0xdf, 0x24, 0x4d, 0xe5, 0x87, 0xa4,
	0xa9, 0xfc, 0x9c, 0x34, 0x95, 0x17, 0x49, 0x53, 0xf9, 0x2d, 0x69, 0x2a, 0x7f, 0x24, 0xcd, 0xdc,
	0xab, 0xa4, 0xa9, 0x7c, 0xfb, 0x7b, 0x33, 0xf7, 0xe5, 0xa3, 0xd0, 0x3b, 0xf5, 0xa8, 0x6f, 0x8f,
	0xc4, 0xba, 0xed, 0xbd, 0xf3, 0xb7, 0xde, 0x3d, 0x49, 0xfe, 0xa3, 0xb7, 0xb9, 0x1d, 0x95, 0xf1,
	0x57, 0xda, 0xfd, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x98, 0x58, 0x2d, 0xbd, 0x28, 0x0a, 0x00,
	0x00,
}
