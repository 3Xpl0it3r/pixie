import px

False = 0 == 1
True = 1 == 1
###############################################################
# Edit the following variables to change the visualization.
###############################################################
# Pods/services are formatted as <namespace>/<name>.
# If you want to match a namespace, only keep the namespace portion
requestor_filter = 'px-sock-shop/orders'
responder_filter = 'px-sock-shop/user'
k8s_object = 'service'

# Visualization Variables - Dont change unless you know what you are doing
num_seconds = 2
filter_dash = True
filter_health = True
filter_readyz = True
filter_empty_k8s = True
src_name = 'requestor'
dest_name = 'responder'
ip = 'remote_addr'
###############################################################


def prepare_columns(df, latency_ns_col):
    df.latency_ms = df[latency_ns_col] / 1.0E6
    df = df[df['latency_ms'] < 1000.0]
    df.timestamp = px.bin(df.time_, px.seconds(num_seconds))
    df[k8s_object] = df.ctx[k8s_object]
    return df


def prepare_http_columns(df, filter_health, filter_readyz, filter_dash):
    df = prepare_columns(df, 'http_resp_latency_ns')
    df.resp_size = px.length(df.http_resp_body)
    df.failure = df.http_resp_status >= 400
    filter_out_conds = ((df.http_req_path != '/health' or not filter_health) and (
        df.http_req_path != '/readyz' or not filter_readyz)) and (
        df[ip] != '-' or not filter_dash)

    return df[filter_out_conds]


def calc_LET(df, groups):
    df = df.groupby(groups).agg(
        latency_quantiles=('latency_ms', px.quantiles),
        error_rate_per_window=('failure', px.mean),
        throughput_total=('http_resp_status', px.count),
        bytes_total=('resp_size', px.sum)
    )

    df.latency_p50 = px.pluck_float64(df.latency_quantiles, 'p50')
    df.latency_p90 = px.pluck_float64(df.latency_quantiles, 'p90')
    df.latency_p99 = px.pluck_float64(df.latency_quantiles, 'p99')
    df['time_'] = df['timestamp']
    df.error_rate = df.error_rate_per_window * df.throughput_total / num_seconds
    df.rps = df.throughput_total / num_seconds
    df.bytes_per_s = df.bytes_total / num_seconds
    return df


def ip_to_svc_name(df, ip_col, svc_col_name):
    pod_id = 'pod_id'
    df[pod_id] = px.ip_to_pod_id(df[ip_col])
    df[svc_col_name] = px.pod_id_to_service_name(df[pod_id])
    return df.drop(pod_id)


def edge_agg(filtered_df, groups):
    df = filtered_df.groupby(groups).agg(
        rps=('rps', px.mean),
        bytes_per_s=('bytes_per_s', px.mean),
        error_rate=('error_rate', px.mean),
    )
    return df


df = px.DataFrame(table='http_events', start_time='-2m')
df = prepare_http_columns(df, filter_health, filter_readyz, filter_dash)
qa = calc_LET(df[px.contains(df[k8s_object], responder_filter)], [k8s_object, 'timestamp', ip])
# Convert the requesting ip into a pod name.
qa = ip_to_svc_name(qa, ip_col=ip, svc_col_name=src_name)

split_series_name = 'k8s'
qa[split_series_name] = qa[k8s_object]
qa[dest_name] = qa[k8s_object]
qa = qa[px.contains(qa[src_name], requestor_filter)]
px.display(qa['time_', src_name, split_series_name, 'latency_p50',
              'latency_p90', 'latency_p99', 'error_rate', 'rps', 'bytes_per_s'], 'test')

px.display(edge_agg(qa, [src_name, dest_name]), 'edges')
