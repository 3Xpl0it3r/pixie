# Copyright (c) Pixie Labs, Inc.
# Licensed under the Apache License, Version 2.0 (the "License")

'''PEM Flamegraph

Performance profile visualization for the PEM.

'''

import px


def stacktraces(start_time: str, node: str, namespace: str, pod: str, pct_basis_entity: str):
    df = px.DataFrame(table='stack_traces.beta', start_time=start_time)

    df.namespace = df.ctx['namespace']
    df.pod = df.ctx['pod']
    df.container = df.ctx['container']
    df.cmdline = df.ctx['cmdline']

    # Compute node using _exec_hostname() instead of `df.ctx['node']`
    # We do this so it works for non-k8s processes too.
    # This is important for determining total number of stack trace samples per node,
    # as we need to include the non-K8s processes in the computation.
    df.node = px.Node(px._exec_hostname())

    # This must be done before any filtering, to get accurate stack trace totals per node.
    node_agg = df.groupby([pct_basis_entity]).agg(
        count=('count', px.sum)
    )

    # Apply filters.
    df = df[px.contains(df.node, node)]
    df = df[px.contains(df.pod, pod)]
    df = df[px.contains(df.namespace, namespace)]

    # Filter out any non-k8s processes (it's now safe to do so).
    df = df[df.pod != '']

    # Aggregate stack-traces from different profiles into one larger profile.
    # For example, if a profile is generated every 30 seconds, and our query spans 5 minutes,
    # this merges the 10 profiles into a single profile including samples for entire 5 minutes.
    df = df.groupby(['node', 'namespace', 'pod', 'container', 'cmdline', 'stack_trace_id']).agg(
        stack_trace=('stack_trace', px.any),
        count=('count', px.sum)
    )

    # Compute percentages.
    df = df.merge(
        node_agg,
        how='inner',
        left_on=pct_basis_entity,
        right_on=pct_basis_entity,
        suffixes=['', '_x']
    )
    df.percent = 100.0 * df.count / df.count_x
    df.drop(pct_basis_entity + '_x')

    return df
