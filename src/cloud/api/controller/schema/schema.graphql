# This file describes the schema from the API service.
#
# It's not ideal, but we need to manually generate types for the TypeScript UI
# when this file is updated. This can be done by running:
#  graphql-schema-typescript generate-ts schema.graphql --output schema.d.ts
# which will generate the output type file that will be picked up by the UI.
# This schema.d.ts files should exist in the same directory as the schema.graphql file.

schema {
  query: Query
  mutation: Mutation
}

type UserInfo {
  id: ID!
  name: String!
  email: String!
  picture: String!
}

enum ArtifactType {
    AT_UNKNOWN
    AT_LINUX_AMD64
    AT_DARWIN_AMD64
    AT_CONTAINER_SET_YAMLS
    AT_CONTAINER_SET_LINUX_AMD64
}

type Query {
  user: UserInfo!
  cluster: ClusterInfo!
  clusterConnection: ClusterConnectionInfo!
  cliArtifact(artifactType: ArtifactType): CLIArtifact!
  artifacts(artifactName: String): ArtifactsInfo!
}

enum ClusterStatus {
  # The default state if nothing is known.
  VZ_ST_UNKNOWN
  # The state is healthy if heartbeats are received on regular intervals and the
  # cluster is responding to requests.
  VZ_ST_HEALTHY
  # The state will go to disconnected if the GRPC connection breaks. The hope is that
  # the cluster will come back online and resume in HEALTHY state.
  VZ_ST_DISCONNECTED
}

type VizierConfig {
  passthroughEnabled: Boolean
}

type ClusterInfo {
  id: ID!
  status: ClusterStatus!
  lastHeartbeatMs: Float!
  vizierConfig: VizierConfig!
}

type ClusterConnectionInfo {
  ipAddress: String!
  token: String!
}

type Mutation {
  CreateCluster: ClusterInfo
  UpdateVizierConfig(clusterID: ID!, passthroughEnabled: Boolean): Boolean!
}

type CLIArtifact {
    url: String!
    sha256: String!
}

type ArtifactsInfo {
  items: [Artifact]
}

type Artifact {
  version: String!
  changelog: String!
  timestampMs: Float!
}
