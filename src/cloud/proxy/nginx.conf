# File borrowed from openresty config.

# Environment variable need to be specified here (and below).
env PL_AUTH0_DOMAIN;
env PL_AUTH0_CLIENT_ID;
env PL_DOMAIN_NAME;
env PL_API_SERVICE_HTTP;
env PL_DOCS_SERVICE_HTTP;

worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;

    resolver kube-dns.kube-system.svc.cluster.local valid=5s;

    gzip  on;
    # Compress proxied traffic.
    gzip_proxied any;
    gzip_vary on;

    # Tune nginx keepalives to work with the GCP HTTP(S) Load Balancer:
    keepalive_timeout 650;
    keepalive_requests 10000;

    server {
        listen [::]:56000 ssl ipv6only=on;
        listen 56000 ssl;
        server_name app.staging.pixielabs.ai;
        ssl_certificate /certs/tls.crt;
        ssl_certificate_key /certs/tls.key;

        # On redirects don't rewrite the host/port. This can cause problems because the nginx service
        # is behind a load balancer/proxy.
        absolute_redirect off;

        # If the host contains a subdomain, redirect to the correct index file.
        set $index "/index.html";
        if ($host ~* ^([a-zA-Z0-9\-]+).(\.[a-zA-Z]+).(pixielabs.ai|withpixie.dev)$) {
          set $index "/subdomain-index.html";
        }

        if ($host ~* ^([a-zA-Z0-9\-]+).(withpixie.ai)$) {
          set $index "/subdomain-index.html";
        }

        if ($http_x_forwarded_proto = "http") {
            return 301 https://$host$request_uri;
        }

        # Get the environment information so that we can inject the correct config
        # into the javascript assets.
        # The environment variable also need an ENV directive above.
        set_by_lua $auth0_domain 'return os.getenv("PL_AUTH0_DOMAIN")';
        set_by_lua $auth0_client_id 'return os.getenv("PL_AUTH0_CLIENT_ID")';
        set_by_lua $domain_name 'return os.getenv("PL_DOMAIN_NAME")';
        set_by_lua $api_service 'return os.getenv("PL_API_SERVICE_HTTP")';
        set_by_lua $docs_service 'return os.getenv("PL_DOCS_SERVICE_HTTP")';

        location / {
            root   /assets;
            # Allow caching, but force revalidation for changed assets.
            etag on;
            expires 30m;
            add_header Cache-Control "public, must-revalidate, proxy-revalidate";

            sub_filter_types application/javascript;
            sub_filter '__CONFIG_AUTH0_DOMAIN__' $auth0_domain;
            sub_filter '__CONFIG_AUTH0_CLIENT_ID__' $auth0_client_id;
            sub_filter '__CONFIG_DOMAIN_NAME__' $domain_name;
            # Only need to filter once since these variables should not be repeated.
            sub_filter_once on;
            try_files $uri $index;
        }

        # Treat trailing slashes as optional.
        location ~ ^/docs(?:/(.*))?$ {
            auth_request /api/authorized;
            # TODO(zasgar): Figure out why proxy does not work and switch to that.
            root /customer_docs_assets/public;
            try_files /$1 /$1/index.html /index.html =404;
        }

        location /robots.txt {
            return 200 "User-agent: *\nDisallow: /\n";
        }

        location /api/ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_pass https://$api_service;
        }

        location /healthz {
          return 200 "healthy\n";
        }
    }
}
