// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/cloud/cloudapipb/cloudapi.proto

package cloudapipb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	proto1 "pixielabs.ai/pixielabs/src/common/uuid/proto"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ArtifactType int32

const (
	AT_UNKNOWN                   ArtifactType = 0
	AT_LINUX_AMD64               ArtifactType = 1
	AT_DARWIN_AMD64              ArtifactType = 2
	AT_CONTAINER_SET_YAMLS       ArtifactType = 50
	AT_CONTAINER_SET_LINUX_AMD64 ArtifactType = 100
)

var ArtifactType_name = map[int32]string{
	0:   "AT_UNKNOWN",
	1:   "AT_LINUX_AMD64",
	2:   "AT_DARWIN_AMD64",
	50:  "AT_CONTAINER_SET_YAMLS",
	100: "AT_CONTAINER_SET_LINUX_AMD64",
}

var ArtifactType_value = map[string]int32{
	"AT_UNKNOWN":                   0,
	"AT_LINUX_AMD64":               1,
	"AT_DARWIN_AMD64":              2,
	"AT_CONTAINER_SET_YAMLS":       50,
	"AT_CONTAINER_SET_LINUX_AMD64": 100,
}

func (ArtifactType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{0}
}

type ClusterStatus int32

const (
	CS_UNKNOWN      ClusterStatus = 0
	CS_HEALTHY      ClusterStatus = 1
	CS_UNHEALTHY    ClusterStatus = 2
	CS_DISCONNECTED ClusterStatus = 3
)

var ClusterStatus_name = map[int32]string{
	0: "CS_UNKNOWN",
	1: "CS_HEALTHY",
	2: "CS_UNHEALTHY",
	3: "CS_DISCONNECTED",
}

var ClusterStatus_value = map[string]int32{
	"CS_UNKNOWN":      0,
	"CS_HEALTHY":      1,
	"CS_UNHEALTHY":    2,
	"CS_DISCONNECTED": 3,
}

func (ClusterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{1}
}

type SemanticType int32

const (
	ST_UNSPECIFIED  SemanticType = 0
	ST_NONE         SemanticType = 1
	ST_AGENT_UID    SemanticType = 100
	ST_UPID         SemanticType = 200
	ST_SERVICE_NAME SemanticType = 300
)

var SemanticType_name = map[int32]string{
	0:   "ST_UNSPECIFIED",
	1:   "ST_NONE",
	100: "ST_AGENT_UID",
	200: "ST_UPID",
	300: "ST_SERVICE_NAME",
}

var SemanticType_value = map[string]int32{
	"ST_UNSPECIFIED":  0,
	"ST_NONE":         1,
	"ST_AGENT_UID":    100,
	"ST_UPID":         200,
	"ST_SERVICE_NAME": 300,
}

func (SemanticType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{2}
}

type DataType int32

const (
	DATA_TYPE_UNKNOWN DataType = 0
	BOOLEAN           DataType = 1
	INT64             DataType = 2
	UINT128           DataType = 3
	FLOAT64           DataType = 4
	STRING            DataType = 5
	TIME64NS          DataType = 6
	DURATION64NS      DataType = 7
)

var DataType_name = map[int32]string{
	0: "DATA_TYPE_UNKNOWN",
	1: "BOOLEAN",
	2: "INT64",
	3: "UINT128",
	4: "FLOAT64",
	5: "STRING",
	6: "TIME64NS",
	7: "DURATION64NS",
}

var DataType_value = map[string]int32{
	"DATA_TYPE_UNKNOWN": 0,
	"BOOLEAN":           1,
	"INT64":             2,
	"UINT128":           3,
	"FLOAT64":           4,
	"STRING":            5,
	"TIME64NS":          6,
	"DURATION64NS":      7,
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{3}
}

type AutocompleteActionType int32

const (
	AAT_UNKNOWN AutocompleteActionType = 0
	AAT_EDIT    AutocompleteActionType = 1
	AAT_SELECT  AutocompleteActionType = 2
)

var AutocompleteActionType_name = map[int32]string{
	0: "AAT_UNKNOWN",
	1: "AAT_EDIT",
	2: "AAT_SELECT",
}

var AutocompleteActionType_value = map[string]int32{
	"AAT_UNKNOWN": 0,
	"AAT_EDIT":    1,
	"AAT_SELECT":  2,
}

func (AutocompleteActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{4}
}

type AutocompleteEntityKind int32

const (
	AEK_UNKNOWN   AutocompleteEntityKind = 0
	AEK_POD       AutocompleteEntityKind = 1
	AEK_SVC       AutocompleteEntityKind = 2
	AEK_SCRIPT    AutocompleteEntityKind = 3
	AEK_NAMESPACE AutocompleteEntityKind = 4
)

var AutocompleteEntityKind_name = map[int32]string{
	0: "AEK_UNKNOWN",
	1: "AEK_POD",
	2: "AEK_SVC",
	3: "AEK_SCRIPT",
	4: "AEK_NAMESPACE",
}

var AutocompleteEntityKind_value = map[string]int32{
	"AEK_UNKNOWN":   0,
	"AEK_POD":       1,
	"AEK_SVC":       2,
	"AEK_SCRIPT":    3,
	"AEK_NAMESPACE": 4,
}

func (AutocompleteEntityKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{5}
}

type LoginRequest struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *LoginRequest) Reset()      { *m = LoginRequest{} }
func (*LoginRequest) ProtoMessage() {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{0}
}
func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(m, src)
}
func (m *LoginRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

type LoginReply struct {
	Token     string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	ExpiresAt int64  `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (m *LoginReply) Reset()      { *m = LoginReply{} }
func (*LoginReply) ProtoMessage() {}
func (*LoginReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{1}
}
func (m *LoginReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReply.Merge(m, src)
}
func (m *LoginReply) XXX_Size() int {
	return m.Size()
}
func (m *LoginReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReply.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReply proto.InternalMessageInfo

func (m *LoginReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginReply) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

type GetImageCredentialsRequest struct {
}

func (m *GetImageCredentialsRequest) Reset()      { *m = GetImageCredentialsRequest{} }
func (*GetImageCredentialsRequest) ProtoMessage() {}
func (*GetImageCredentialsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{2}
}
func (m *GetImageCredentialsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageCredentialsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageCredentialsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageCredentialsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageCredentialsRequest.Merge(m, src)
}
func (m *GetImageCredentialsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImageCredentialsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageCredentialsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageCredentialsRequest proto.InternalMessageInfo

type GetImageCredentialsResponse struct {
	Creds string `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *GetImageCredentialsResponse) Reset()      { *m = GetImageCredentialsResponse{} }
func (*GetImageCredentialsResponse) ProtoMessage() {}
func (*GetImageCredentialsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{3}
}
func (m *GetImageCredentialsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageCredentialsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageCredentialsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageCredentialsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageCredentialsResponse.Merge(m, src)
}
func (m *GetImageCredentialsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetImageCredentialsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageCredentialsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageCredentialsResponse proto.InternalMessageInfo

func (m *GetImageCredentialsResponse) GetCreds() string {
	if m != nil {
		return m.Creds
	}
	return ""
}

type ArtifactSet struct {
	Name     string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Artifact []*Artifact `protobuf:"bytes,2,rep,name=artifact,proto3" json:"artifact,omitempty"`
}

func (m *ArtifactSet) Reset()      { *m = ArtifactSet{} }
func (*ArtifactSet) ProtoMessage() {}
func (*ArtifactSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{4}
}
func (m *ArtifactSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactSet.Merge(m, src)
}
func (m *ArtifactSet) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactSet.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactSet proto.InternalMessageInfo

func (m *ArtifactSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArtifactSet) GetArtifact() []*Artifact {
	if m != nil {
		return m.Artifact
	}
	return nil
}

type Artifact struct {
	Timestamp          *types.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	CommitHash         string           `protobuf:"bytes,2,opt,name=commit_hash,json=commitHash,proto3" json:"commit_hash,omitempty"`
	VersionStr         string           `protobuf:"bytes,3,opt,name=version_str,json=versionStr,proto3" json:"version_str,omitempty"`
	AvailableArtifacts []ArtifactType   `protobuf:"varint,4,rep,packed,name=available_artifacts,json=availableArtifacts,proto3,enum=pl.cloudapi.ArtifactType" json:"available_artifacts,omitempty"`
	Changelog          string           `protobuf:"bytes,5,opt,name=changelog,proto3" json:"changelog,omitempty"`
}

func (m *Artifact) Reset()      { *m = Artifact{} }
func (*Artifact) ProtoMessage() {}
func (*Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{5}
}
func (m *Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Artifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Artifact.Merge(m, src)
}
func (m *Artifact) XXX_Size() int {
	return m.Size()
}
func (m *Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_Artifact proto.InternalMessageInfo

func (m *Artifact) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Artifact) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Artifact) GetVersionStr() string {
	if m != nil {
		return m.VersionStr
	}
	return ""
}

func (m *Artifact) GetAvailableArtifacts() []ArtifactType {
	if m != nil {
		return m.AvailableArtifacts
	}
	return nil
}

func (m *Artifact) GetChangelog() string {
	if m != nil {
		return m.Changelog
	}
	return ""
}

type GetArtifactListRequest struct {
	ArtifactName string       `protobuf:"bytes,1,opt,name=artifact_name,json=artifactName,proto3" json:"artifact_name,omitempty"`
	ArtifactType ArtifactType `protobuf:"varint,2,opt,name=artifact_type,json=artifactType,proto3,enum=pl.cloudapi.ArtifactType" json:"artifact_type,omitempty"`
	Limit        int64        `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetArtifactListRequest) Reset()      { *m = GetArtifactListRequest{} }
func (*GetArtifactListRequest) ProtoMessage() {}
func (*GetArtifactListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{6}
}
func (m *GetArtifactListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetArtifactListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetArtifactListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetArtifactListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetArtifactListRequest.Merge(m, src)
}
func (m *GetArtifactListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetArtifactListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetArtifactListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetArtifactListRequest proto.InternalMessageInfo

func (m *GetArtifactListRequest) GetArtifactName() string {
	if m != nil {
		return m.ArtifactName
	}
	return ""
}

func (m *GetArtifactListRequest) GetArtifactType() ArtifactType {
	if m != nil {
		return m.ArtifactType
	}
	return AT_UNKNOWN
}

func (m *GetArtifactListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetDownloadLinkRequest struct {
	ArtifactName string       `protobuf:"bytes,1,opt,name=artifact_name,json=artifactName,proto3" json:"artifact_name,omitempty"`
	VersionStr   string       `protobuf:"bytes,2,opt,name=version_str,json=versionStr,proto3" json:"version_str,omitempty"`
	ArtifactType ArtifactType `protobuf:"varint,3,opt,name=artifact_type,json=artifactType,proto3,enum=pl.cloudapi.ArtifactType" json:"artifact_type,omitempty"`
}

func (m *GetDownloadLinkRequest) Reset()      { *m = GetDownloadLinkRequest{} }
func (*GetDownloadLinkRequest) ProtoMessage() {}
func (*GetDownloadLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{7}
}
func (m *GetDownloadLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDownloadLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDownloadLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDownloadLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDownloadLinkRequest.Merge(m, src)
}
func (m *GetDownloadLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDownloadLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDownloadLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDownloadLinkRequest proto.InternalMessageInfo

func (m *GetDownloadLinkRequest) GetArtifactName() string {
	if m != nil {
		return m.ArtifactName
	}
	return ""
}

func (m *GetDownloadLinkRequest) GetVersionStr() string {
	if m != nil {
		return m.VersionStr
	}
	return ""
}

func (m *GetDownloadLinkRequest) GetArtifactType() ArtifactType {
	if m != nil {
		return m.ArtifactType
	}
	return AT_UNKNOWN
}

type GetDownloadLinkResponse struct {
	Url        string           `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	SHA256     string           `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	ValidUntil *types.Timestamp `protobuf:"bytes,3,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
}

func (m *GetDownloadLinkResponse) Reset()      { *m = GetDownloadLinkResponse{} }
func (*GetDownloadLinkResponse) ProtoMessage() {}
func (*GetDownloadLinkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{8}
}
func (m *GetDownloadLinkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDownloadLinkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDownloadLinkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDownloadLinkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDownloadLinkResponse.Merge(m, src)
}
func (m *GetDownloadLinkResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDownloadLinkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDownloadLinkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDownloadLinkResponse proto.InternalMessageInfo

func (m *GetDownloadLinkResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *GetDownloadLinkResponse) GetSHA256() string {
	if m != nil {
		return m.SHA256
	}
	return ""
}

func (m *GetDownloadLinkResponse) GetValidUntil() *types.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

type CreateClusterRequest struct {
}

func (m *CreateClusterRequest) Reset()      { *m = CreateClusterRequest{} }
func (*CreateClusterRequest) ProtoMessage() {}
func (*CreateClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{9}
}
func (m *CreateClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterRequest.Merge(m, src)
}
func (m *CreateClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterRequest proto.InternalMessageInfo

type CreateClusterResponse struct {
	ClusterID *proto1.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *CreateClusterResponse) Reset()      { *m = CreateClusterResponse{} }
func (*CreateClusterResponse) ProtoMessage() {}
func (*CreateClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{10}
}
func (m *CreateClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterResponse.Merge(m, src)
}
func (m *CreateClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterResponse proto.InternalMessageInfo

func (m *CreateClusterResponse) GetClusterID() *proto1.UUID {
	if m != nil {
		return m.ClusterID
	}
	return nil
}

type VizierConfig struct {
	PassthroughEnabled bool `protobuf:"varint,1,opt,name=passthrough_enabled,json=passthroughEnabled,proto3" json:"passthrough_enabled,omitempty"`
}

func (m *VizierConfig) Reset()      { *m = VizierConfig{} }
func (*VizierConfig) ProtoMessage() {}
func (*VizierConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{11}
}
func (m *VizierConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VizierConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VizierConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VizierConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VizierConfig.Merge(m, src)
}
func (m *VizierConfig) XXX_Size() int {
	return m.Size()
}
func (m *VizierConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VizierConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VizierConfig proto.InternalMessageInfo

func (m *VizierConfig) GetPassthroughEnabled() bool {
	if m != nil {
		return m.PassthroughEnabled
	}
	return false
}

type VizierConfigUpdate struct {
	PassthroughEnabled *types.BoolValue `protobuf:"bytes,1,opt,name=passthrough_enabled,json=passthroughEnabled,proto3" json:"passthrough_enabled,omitempty"`
}

func (m *VizierConfigUpdate) Reset()      { *m = VizierConfigUpdate{} }
func (*VizierConfigUpdate) ProtoMessage() {}
func (*VizierConfigUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{12}
}
func (m *VizierConfigUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VizierConfigUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VizierConfigUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VizierConfigUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VizierConfigUpdate.Merge(m, src)
}
func (m *VizierConfigUpdate) XXX_Size() int {
	return m.Size()
}
func (m *VizierConfigUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_VizierConfigUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_VizierConfigUpdate proto.InternalMessageInfo

func (m *VizierConfigUpdate) GetPassthroughEnabled() *types.BoolValue {
	if m != nil {
		return m.PassthroughEnabled
	}
	return nil
}

type GetClusterInfoRequest struct {
	ID *proto1.UUID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetClusterInfoRequest) Reset()      { *m = GetClusterInfoRequest{} }
func (*GetClusterInfoRequest) ProtoMessage() {}
func (*GetClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{13}
}
func (m *GetClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoRequest.Merge(m, src)
}
func (m *GetClusterInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoRequest proto.InternalMessageInfo

func (m *GetClusterInfoRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

type ClusterInfo struct {
	ID              *proto1.UUID  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Status          ClusterStatus `protobuf:"varint,2,opt,name=status,proto3,enum=pl.cloudapi.ClusterStatus" json:"status,omitempty"`
	LastHeartbeatNs int64         `protobuf:"varint,3,opt,name=lastHeartbeatNs,proto3" json:"lastHeartbeatNs,omitempty"`
	Config          *VizierConfig `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *ClusterInfo) Reset()      { *m = ClusterInfo{} }
func (*ClusterInfo) ProtoMessage() {}
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{14}
}
func (m *ClusterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo.Merge(m, src)
}
func (m *ClusterInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo proto.InternalMessageInfo

func (m *ClusterInfo) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ClusterInfo) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return CS_UNKNOWN
}

func (m *ClusterInfo) GetLastHeartbeatNs() int64 {
	if m != nil {
		return m.LastHeartbeatNs
	}
	return 0
}

func (m *ClusterInfo) GetConfig() *VizierConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

type GetClusterInfoResponse struct {
	Clusters []*ClusterInfo `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
}

func (m *GetClusterInfoResponse) Reset()      { *m = GetClusterInfoResponse{} }
func (*GetClusterInfoResponse) ProtoMessage() {}
func (*GetClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{15}
}
func (m *GetClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoResponse.Merge(m, src)
}
func (m *GetClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoResponse proto.InternalMessageInfo

func (m *GetClusterInfoResponse) GetClusters() []*ClusterInfo {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type GetClusterConnectionInfoRequest struct {
	ID *proto1.UUID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetClusterConnectionInfoRequest) Reset()      { *m = GetClusterConnectionInfoRequest{} }
func (*GetClusterConnectionInfoRequest) ProtoMessage() {}
func (*GetClusterConnectionInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{16}
}
func (m *GetClusterConnectionInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConnectionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConnectionInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConnectionInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConnectionInfoRequest.Merge(m, src)
}
func (m *GetClusterConnectionInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConnectionInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConnectionInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConnectionInfoRequest proto.InternalMessageInfo

func (m *GetClusterConnectionInfoRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

type GetClusterConnectionInfoResponse struct {
	IPAddress string `protobuf:"bytes,1,opt,name=ipAddress,proto3" json:"ipAddress,omitempty"`
	Token     string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *GetClusterConnectionInfoResponse) Reset()      { *m = GetClusterConnectionInfoResponse{} }
func (*GetClusterConnectionInfoResponse) ProtoMessage() {}
func (*GetClusterConnectionInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{17}
}
func (m *GetClusterConnectionInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConnectionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConnectionInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConnectionInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConnectionInfoResponse.Merge(m, src)
}
func (m *GetClusterConnectionInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConnectionInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConnectionInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConnectionInfoResponse proto.InternalMessageInfo

func (m *GetClusterConnectionInfoResponse) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *GetClusterConnectionInfoResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UpdateClusterVizierConfigRequest struct {
	ID           *proto1.UUID        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ConfigUpdate *VizierConfigUpdate `protobuf:"bytes,2,opt,name=config_update,json=configUpdate,proto3" json:"config_update,omitempty"`
}

func (m *UpdateClusterVizierConfigRequest) Reset()      { *m = UpdateClusterVizierConfigRequest{} }
func (*UpdateClusterVizierConfigRequest) ProtoMessage() {}
func (*UpdateClusterVizierConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{18}
}
func (m *UpdateClusterVizierConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClusterVizierConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClusterVizierConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClusterVizierConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClusterVizierConfigRequest.Merge(m, src)
}
func (m *UpdateClusterVizierConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClusterVizierConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClusterVizierConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClusterVizierConfigRequest proto.InternalMessageInfo

func (m *UpdateClusterVizierConfigRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *UpdateClusterVizierConfigRequest) GetConfigUpdate() *VizierConfigUpdate {
	if m != nil {
		return m.ConfigUpdate
	}
	return nil
}

type UpdateClusterVizierConfigResponse struct {
}

func (m *UpdateClusterVizierConfigResponse) Reset()      { *m = UpdateClusterVizierConfigResponse{} }
func (*UpdateClusterVizierConfigResponse) ProtoMessage() {}
func (*UpdateClusterVizierConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{19}
}
func (m *UpdateClusterVizierConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClusterVizierConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClusterVizierConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClusterVizierConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClusterVizierConfigResponse.Merge(m, src)
}
func (m *UpdateClusterVizierConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClusterVizierConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClusterVizierConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClusterVizierConfigResponse proto.InternalMessageInfo

type ExtractVisFuncsInfoRequest struct {
	Script    string   `protobuf:"bytes,1,opt,name=script,proto3" json:"script,omitempty"`
	FuncNames []string `protobuf:"bytes,2,rep,name=func_names,json=funcNames,proto3" json:"func_names,omitempty"`
}

func (m *ExtractVisFuncsInfoRequest) Reset()      { *m = ExtractVisFuncsInfoRequest{} }
func (*ExtractVisFuncsInfoRequest) ProtoMessage() {}
func (*ExtractVisFuncsInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{20}
}
func (m *ExtractVisFuncsInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractVisFuncsInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractVisFuncsInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractVisFuncsInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractVisFuncsInfoRequest.Merge(m, src)
}
func (m *ExtractVisFuncsInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExtractVisFuncsInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractVisFuncsInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractVisFuncsInfoRequest proto.InternalMessageInfo

func (m *ExtractVisFuncsInfoRequest) GetScript() string {
	if m != nil {
		return m.Script
	}
	return ""
}

func (m *ExtractVisFuncsInfoRequest) GetFuncNames() []string {
	if m != nil {
		return m.FuncNames
	}
	return nil
}

type FuncArgsSpec struct {
	Args []*FuncArgsSpec_Arg `protobuf:"bytes,1,rep,name=args,proto3" json:"args,omitempty"`
}

func (m *FuncArgsSpec) Reset()      { *m = FuncArgsSpec{} }
func (*FuncArgsSpec) ProtoMessage() {}
func (*FuncArgsSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{21}
}
func (m *FuncArgsSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuncArgsSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuncArgsSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuncArgsSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuncArgsSpec.Merge(m, src)
}
func (m *FuncArgsSpec) XXX_Size() int {
	return m.Size()
}
func (m *FuncArgsSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FuncArgsSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FuncArgsSpec proto.InternalMessageInfo

func (m *FuncArgsSpec) GetArgs() []*FuncArgsSpec_Arg {
	if m != nil {
		return m.Args
	}
	return nil
}

type FuncArgsSpec_Arg struct {
	DataType     DataType     `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3,enum=pl.cloudapi.DataType" json:"data_type,omitempty"`
	SemanticType SemanticType `protobuf:"varint,2,opt,name=semantic_type,json=semanticType,proto3,enum=pl.cloudapi.SemanticType" json:"semantic_type,omitempty"`
	Name         string       `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	DefaultValue string       `protobuf:"bytes,5,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (m *FuncArgsSpec_Arg) Reset()      { *m = FuncArgsSpec_Arg{} }
func (*FuncArgsSpec_Arg) ProtoMessage() {}
func (*FuncArgsSpec_Arg) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{21, 0}
}
func (m *FuncArgsSpec_Arg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuncArgsSpec_Arg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuncArgsSpec_Arg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuncArgsSpec_Arg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuncArgsSpec_Arg.Merge(m, src)
}
func (m *FuncArgsSpec_Arg) XXX_Size() int {
	return m.Size()
}
func (m *FuncArgsSpec_Arg) XXX_DiscardUnknown() {
	xxx_messageInfo_FuncArgsSpec_Arg.DiscardUnknown(m)
}

var xxx_messageInfo_FuncArgsSpec_Arg proto.InternalMessageInfo

func (m *FuncArgsSpec_Arg) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DATA_TYPE_UNKNOWN
}

func (m *FuncArgsSpec_Arg) GetSemanticType() SemanticType {
	if m != nil {
		return m.SemanticType
	}
	return ST_UNSPECIFIED
}

func (m *FuncArgsSpec_Arg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FuncArgsSpec_Arg) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

type VisSpec struct {
	VegaSpec string `protobuf:"bytes,1,opt,name=vega_spec,json=vegaSpec,proto3" json:"vega_spec,omitempty"`
}

func (m *VisSpec) Reset()      { *m = VisSpec{} }
func (*VisSpec) ProtoMessage() {}
func (*VisSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{22}
}
func (m *VisSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VisSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VisSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VisSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VisSpec.Merge(m, src)
}
func (m *VisSpec) XXX_Size() int {
	return m.Size()
}
func (m *VisSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VisSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VisSpec proto.InternalMessageInfo

func (m *VisSpec) GetVegaSpec() string {
	if m != nil {
		return m.VegaSpec
	}
	return ""
}

type ExtractVisFuncsInfoResponse struct {
	DocStringMap map[string]string        `protobuf:"bytes,1,rep,name=doc_string_map,json=docStringMap,proto3" json:"doc_string_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VisSpecMap   map[string]*VisSpec      `protobuf:"bytes,2,rep,name=vis_spec_map,json=visSpecMap,proto3" json:"vis_spec_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FnArgsMap    map[string]*FuncArgsSpec `protobuf:"bytes,3,rep,name=fn_args_map,json=fnArgsMap,proto3" json:"fn_args_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ExtractVisFuncsInfoResponse) Reset()      { *m = ExtractVisFuncsInfoResponse{} }
func (*ExtractVisFuncsInfoResponse) ProtoMessage() {}
func (*ExtractVisFuncsInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{23}
}
func (m *ExtractVisFuncsInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractVisFuncsInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractVisFuncsInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractVisFuncsInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractVisFuncsInfoResponse.Merge(m, src)
}
func (m *ExtractVisFuncsInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExtractVisFuncsInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractVisFuncsInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractVisFuncsInfoResponse proto.InternalMessageInfo

func (m *ExtractVisFuncsInfoResponse) GetDocStringMap() map[string]string {
	if m != nil {
		return m.DocStringMap
	}
	return nil
}

func (m *ExtractVisFuncsInfoResponse) GetVisSpecMap() map[string]*VisSpec {
	if m != nil {
		return m.VisSpecMap
	}
	return nil
}

func (m *ExtractVisFuncsInfoResponse) GetFnArgsMap() map[string]*FuncArgsSpec {
	if m != nil {
		return m.FnArgsMap
	}
	return nil
}

type AutocompleteRequest struct {
	Input     string                 `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	CursorPos int64                  `protobuf:"varint,2,opt,name=cursor_pos,json=cursorPos,proto3" json:"cursor_pos,omitempty"`
	Action    AutocompleteActionType `protobuf:"varint,3,opt,name=action,proto3,enum=pl.cloudapi.AutocompleteActionType" json:"action,omitempty"`
}

func (m *AutocompleteRequest) Reset()      { *m = AutocompleteRequest{} }
func (*AutocompleteRequest) ProtoMessage() {}
func (*AutocompleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{24}
}
func (m *AutocompleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteRequest.Merge(m, src)
}
func (m *AutocompleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteRequest proto.InternalMessageInfo

func (m *AutocompleteRequest) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *AutocompleteRequest) GetCursorPos() int64 {
	if m != nil {
		return m.CursorPos
	}
	return 0
}

func (m *AutocompleteRequest) GetAction() AutocompleteActionType {
	if m != nil {
		return m.Action
	}
	return AAT_UNKNOWN
}

type TabSuggestion struct {
	TabIndex              int64                     `protobuf:"varint,1,opt,name=tab_index,json=tabIndex,proto3" json:"tab_index,omitempty"`
	ExecutableAfterSelect bool                      `protobuf:"varint,2,opt,name=executable_after_select,json=executableAfterSelect,proto3" json:"executable_after_select,omitempty"`
	Suggestions           []*AutocompleteSuggestion `protobuf:"bytes,3,rep,name=suggestions,proto3" json:"suggestions,omitempty"`
}

func (m *TabSuggestion) Reset()      { *m = TabSuggestion{} }
func (*TabSuggestion) ProtoMessage() {}
func (*TabSuggestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{25}
}
func (m *TabSuggestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TabSuggestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TabSuggestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TabSuggestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TabSuggestion.Merge(m, src)
}
func (m *TabSuggestion) XXX_Size() int {
	return m.Size()
}
func (m *TabSuggestion) XXX_DiscardUnknown() {
	xxx_messageInfo_TabSuggestion.DiscardUnknown(m)
}

var xxx_messageInfo_TabSuggestion proto.InternalMessageInfo

func (m *TabSuggestion) GetTabIndex() int64 {
	if m != nil {
		return m.TabIndex
	}
	return 0
}

func (m *TabSuggestion) GetExecutableAfterSelect() bool {
	if m != nil {
		return m.ExecutableAfterSelect
	}
	return false
}

func (m *TabSuggestion) GetSuggestions() []*AutocompleteSuggestion {
	if m != nil {
		return m.Suggestions
	}
	return nil
}

type AutocompleteSuggestion struct {
	Kind        AutocompleteEntityKind `protobuf:"varint,1,opt,name=kind,proto3,enum=pl.cloudapi.AutocompleteEntityKind" json:"kind,omitempty"`
	Name        string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *AutocompleteSuggestion) Reset()      { *m = AutocompleteSuggestion{} }
func (*AutocompleteSuggestion) ProtoMessage() {}
func (*AutocompleteSuggestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{26}
}
func (m *AutocompleteSuggestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteSuggestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteSuggestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteSuggestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteSuggestion.Merge(m, src)
}
func (m *AutocompleteSuggestion) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteSuggestion) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteSuggestion.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteSuggestion proto.InternalMessageInfo

func (m *AutocompleteSuggestion) GetKind() AutocompleteEntityKind {
	if m != nil {
		return m.Kind
	}
	return AEK_UNKNOWN
}

func (m *AutocompleteSuggestion) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AutocompleteSuggestion) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type AutocompleteResponse struct {
	FormattedInput string           `protobuf:"bytes,1,opt,name=formatted_input,json=formattedInput,proto3" json:"formatted_input,omitempty"`
	IsExecutable   bool             `protobuf:"varint,2,opt,name=is_executable,json=isExecutable,proto3" json:"is_executable,omitempty"`
	TabSuggestions []*TabSuggestion `protobuf:"bytes,3,rep,name=tabSuggestions,proto3" json:"tabSuggestions,omitempty"`
}

func (m *AutocompleteResponse) Reset()      { *m = AutocompleteResponse{} }
func (*AutocompleteResponse) ProtoMessage() {}
func (*AutocompleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{27}
}
func (m *AutocompleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteResponse.Merge(m, src)
}
func (m *AutocompleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteResponse proto.InternalMessageInfo

func (m *AutocompleteResponse) GetFormattedInput() string {
	if m != nil {
		return m.FormattedInput
	}
	return ""
}

func (m *AutocompleteResponse) GetIsExecutable() bool {
	if m != nil {
		return m.IsExecutable
	}
	return false
}

func (m *AutocompleteResponse) GetTabSuggestions() []*TabSuggestion {
	if m != nil {
		return m.TabSuggestions
	}
	return nil
}

func init() {
	proto.RegisterEnum("pl.cloudapi.ArtifactType", ArtifactType_name, ArtifactType_value)
	proto.RegisterEnum("pl.cloudapi.ClusterStatus", ClusterStatus_name, ClusterStatus_value)
	proto.RegisterEnum("pl.cloudapi.SemanticType", SemanticType_name, SemanticType_value)
	proto.RegisterEnum("pl.cloudapi.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("pl.cloudapi.AutocompleteActionType", AutocompleteActionType_name, AutocompleteActionType_value)
	proto.RegisterEnum("pl.cloudapi.AutocompleteEntityKind", AutocompleteEntityKind_name, AutocompleteEntityKind_value)
	proto.RegisterType((*LoginRequest)(nil), "pl.cloudapi.LoginRequest")
	proto.RegisterType((*LoginReply)(nil), "pl.cloudapi.LoginReply")
	proto.RegisterType((*GetImageCredentialsRequest)(nil), "pl.cloudapi.GetImageCredentialsRequest")
	proto.RegisterType((*GetImageCredentialsResponse)(nil), "pl.cloudapi.GetImageCredentialsResponse")
	proto.RegisterType((*ArtifactSet)(nil), "pl.cloudapi.ArtifactSet")
	proto.RegisterType((*Artifact)(nil), "pl.cloudapi.Artifact")
	proto.RegisterType((*GetArtifactListRequest)(nil), "pl.cloudapi.GetArtifactListRequest")
	proto.RegisterType((*GetDownloadLinkRequest)(nil), "pl.cloudapi.GetDownloadLinkRequest")
	proto.RegisterType((*GetDownloadLinkResponse)(nil), "pl.cloudapi.GetDownloadLinkResponse")
	proto.RegisterType((*CreateClusterRequest)(nil), "pl.cloudapi.CreateClusterRequest")
	proto.RegisterType((*CreateClusterResponse)(nil), "pl.cloudapi.CreateClusterResponse")
	proto.RegisterType((*VizierConfig)(nil), "pl.cloudapi.VizierConfig")
	proto.RegisterType((*VizierConfigUpdate)(nil), "pl.cloudapi.VizierConfigUpdate")
	proto.RegisterType((*GetClusterInfoRequest)(nil), "pl.cloudapi.GetClusterInfoRequest")
	proto.RegisterType((*ClusterInfo)(nil), "pl.cloudapi.ClusterInfo")
	proto.RegisterType((*GetClusterInfoResponse)(nil), "pl.cloudapi.GetClusterInfoResponse")
	proto.RegisterType((*GetClusterConnectionInfoRequest)(nil), "pl.cloudapi.GetClusterConnectionInfoRequest")
	proto.RegisterType((*GetClusterConnectionInfoResponse)(nil), "pl.cloudapi.GetClusterConnectionInfoResponse")
	proto.RegisterType((*UpdateClusterVizierConfigRequest)(nil), "pl.cloudapi.UpdateClusterVizierConfigRequest")
	proto.RegisterType((*UpdateClusterVizierConfigResponse)(nil), "pl.cloudapi.UpdateClusterVizierConfigResponse")
	proto.RegisterType((*ExtractVisFuncsInfoRequest)(nil), "pl.cloudapi.ExtractVisFuncsInfoRequest")
	proto.RegisterType((*FuncArgsSpec)(nil), "pl.cloudapi.FuncArgsSpec")
	proto.RegisterType((*FuncArgsSpec_Arg)(nil), "pl.cloudapi.FuncArgsSpec.Arg")
	proto.RegisterType((*VisSpec)(nil), "pl.cloudapi.VisSpec")
	proto.RegisterType((*ExtractVisFuncsInfoResponse)(nil), "pl.cloudapi.ExtractVisFuncsInfoResponse")
	proto.RegisterMapType((map[string]string)(nil), "pl.cloudapi.ExtractVisFuncsInfoResponse.DocStringMapEntry")
	proto.RegisterMapType((map[string]*FuncArgsSpec)(nil), "pl.cloudapi.ExtractVisFuncsInfoResponse.FnArgsMapEntry")
	proto.RegisterMapType((map[string]*VisSpec)(nil), "pl.cloudapi.ExtractVisFuncsInfoResponse.VisSpecMapEntry")
	proto.RegisterType((*AutocompleteRequest)(nil), "pl.cloudapi.AutocompleteRequest")
	proto.RegisterType((*TabSuggestion)(nil), "pl.cloudapi.TabSuggestion")
	proto.RegisterType((*AutocompleteSuggestion)(nil), "pl.cloudapi.AutocompleteSuggestion")
	proto.RegisterType((*AutocompleteResponse)(nil), "pl.cloudapi.AutocompleteResponse")
}

func init() {
	proto.RegisterFile("src/cloud/cloudapipb/cloudapi.proto", fileDescriptor_c309ce7890afda1a)
}

var fileDescriptor_c309ce7890afda1a = []byte{
	// 2216 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xc1, 0x6f, 0xe3, 0xc6,
	0xd5, 0x17, 0x25, 0xdb, 0x6b, 0x3d, 0xc9, 0xb6, 0x76, 0xd6, 0xbb, 0x71, 0x94, 0x44, 0xf6, 0xd2,
	0x1f, 0xbe, 0x18, 0x6e, 0x23, 0x63, 0x95, 0xc4, 0x59, 0x24, 0x68, 0x53, 0x5a, 0xe2, 0x7a, 0x99,
	0xb5, 0x65, 0x83, 0xa4, 0xbd, 0x49, 0x0a, 0x94, 0x1d, 0x93, 0x63, 0x99, 0x35, 0x45, 0xb2, 0x9c,
	0x91, 0xb3, 0x0e, 0x0a, 0xb4, 0x97, 0xb6, 0x97, 0x1e, 0x5a, 0xf4, 0xde, 0x4b, 0x2f, 0x01, 0xda,
	0x53, 0xff, 0x85, 0xa2, 0x68, 0x8e, 0x39, 0xe6, 0x14, 0x34, 0xce, 0xa5, 0xc7, 0x9c, 0x7a, 0x2e,
	0x66, 0x48, 0x4a, 0xa4, 0x2c, 0x39, 0xbb, 0xbd, 0x08, 0x7c, 0x6f, 0xde, 0xfb, 0xcd, 0x9b, 0x37,
	0xef, 0xbd, 0x79, 0x4f, 0xb0, 0x4e, 0x23, 0x7b, 0xcb, 0xf6, 0x82, 0x81, 0x13, 0xff, 0xe2, 0xd0,
	0x0d, 0x4f, 0x86, 0x9f, 0xcd, 0x30, 0x0a, 0x58, 0x80, 0x2a, 0xa1, 0xd7, 0x4c, 0x59, 0xf5, 0x37,
	0x7a, 0x2e, 0x3b, 0x1b, 0x9c, 0x34, 0xed, 0xa0, 0xbf, 0xd5, 0x0b, 0x7a, 0xc1, 0x96, 0x90, 0x39,
	0x19, 0x9c, 0x0a, 0x4a, 0x10, 0xe2, 0x2b, 0xd6, 0xad, 0xaf, 0x89, 0x0d, 0x82, 0x7e, 0x3f, 0xf0,
	0xb7, 0x06, 0x03, 0xd7, 0x89, 0xc5, 0xc5, 0x67, 0x22, 0xb1, 0xda, 0x0b, 0x82, 0x9e, 0x47, 0x46,
	0x38, 0xcc, 0xed, 0x13, 0xca, 0x70, 0x3f, 0x4c, 0x04, 0x1a, 0xe3, 0x02, 0x9f, 0x44, 0x38, 0x0c,
	0x49, 0x44, 0xe3, 0x75, 0xf9, 0x01, 0x54, 0xf7, 0x82, 0x9e, 0xeb, 0xeb, 0xe4, 0xe7, 0x03, 0x42,
	0x19, 0xba, 0x0f, 0x55, 0x6c, 0xdb, 0x84, 0x52, 0x8b, 0x05, 0xe7, 0xc4, 0x5f, 0x91, 0xd6, 0xa4,
	0x8d, 0xb2, 0x5e, 0x89, 0x79, 0x26, 0x67, 0xc9, 0x0a, 0x40, 0xa2, 0x12, 0x7a, 0x97, 0x68, 0x19,
	0x66, 0xb3, 0x92, 0x31, 0x81, 0x5e, 0x03, 0x20, 0xcf, 0x42, 0x37, 0x22, 0xd4, 0xc2, 0x6c, 0xa5,
	0xb8, 0x26, 0x6d, 0x94, 0xf4, 0x72, 0xc2, 0x51, 0x98, 0xfc, 0x2a, 0xd4, 0x77, 0x09, 0xd3, 0xfa,
	0xb8, 0x47, 0xda, 0x11, 0x71, 0x88, 0xcf, 0x5c, 0xec, 0xd1, 0xc4, 0x06, 0xf9, 0x4d, 0x78, 0x65,
	0xe2, 0x2a, 0x0d, 0x03, 0x9f, 0x12, 0xbe, 0xa3, 0x1d, 0x11, 0x87, 0xa6, 0x3b, 0x0a, 0x42, 0x36,
	0xa1, 0xa2, 0x44, 0xcc, 0x3d, 0xc5, 0x36, 0x33, 0x08, 0x43, 0x08, 0x66, 0x7c, 0xdc, 0x27, 0x89,
	0x8c, 0xf8, 0x46, 0x0f, 0x60, 0x1e, 0x27, 0x22, 0x2b, 0xc5, 0xb5, 0xd2, 0x46, 0xa5, 0x75, 0xb7,
	0x99, 0xb9, 0x9d, 0x66, 0xaa, 0xaf, 0x0f, 0xc5, 0xe4, 0x6f, 0x25, 0x98, 0x4f, 0xd9, 0xe8, 0x21,
	0x94, 0x87, 0xee, 0x15, 0xc0, 0x95, 0x56, 0xbd, 0x19, 0xfb, 0xb7, 0x99, 0xfa, 0xb7, 0x69, 0xa6,
	0x12, 0xfa, 0x48, 0x18, 0xad, 0x42, 0x85, 0x5f, 0xa3, 0xcb, 0xac, 0x33, 0x4c, 0xcf, 0x84, 0x3f,
	0xca, 0x3a, 0xc4, 0xac, 0xc7, 0x98, 0x9e, 0x71, 0x81, 0x0b, 0x12, 0x51, 0x37, 0xf0, 0x2d, 0xca,
	0xa2, 0x95, 0x52, 0x2c, 0x90, 0xb0, 0x0c, 0x16, 0xa1, 0x0f, 0xe0, 0x0e, 0xbe, 0xc0, 0xae, 0x87,
	0x4f, 0x3c, 0x62, 0xa5, 0xe6, 0xd1, 0x95, 0x99, 0xb5, 0xd2, 0xc6, 0x62, 0xeb, 0xe5, 0x89, 0xc7,
	0x30, 0x2f, 0x43, 0xa2, 0xa3, 0xa1, 0x56, 0xca, 0xa6, 0xe8, 0x55, 0x28, 0xdb, 0x67, 0xd8, 0xef,
	0x11, 0x2f, 0xe8, 0xad, 0xcc, 0x8a, 0xad, 0x46, 0x0c, 0xf9, 0x8f, 0x12, 0xdc, 0xdb, 0x25, 0x2c,
	0x15, 0xdf, 0x73, 0x29, 0x4b, 0x83, 0x63, 0x1d, 0x16, 0xd2, 0xad, 0xad, 0x8c, 0x77, 0xab, 0x29,
	0xb3, 0xcb, 0xbd, 0xfc, 0xc3, 0x8c, 0x10, 0xbb, 0x0c, 0x89, 0x38, 0xed, 0x8d, 0x36, 0x0e, 0xf5,
	0x39, 0xc5, 0xaf, 0xd7, 0x73, 0xfb, 0x2e, 0x13, 0x4e, 0x28, 0xe9, 0x31, 0x21, 0xff, 0x29, 0xb6,
	0xaa, 0x13, 0x7c, 0xe2, 0x7b, 0x01, 0x76, 0xf6, 0x5c, 0xff, 0xfc, 0x85, 0xac, 0x1a, 0x73, 0x70,
	0xf1, 0x9a, 0x83, 0xaf, 0x99, 0x5d, 0x7a, 0x21, 0xb3, 0xe5, 0xdf, 0x49, 0xf0, 0xd2, 0x35, 0x03,
	0x93, 0x88, 0xad, 0x41, 0x69, 0x10, 0x79, 0x89, 0x5d, 0xfc, 0x13, 0xc9, 0x30, 0x47, 0xcf, 0x70,
	0xeb, 0xed, 0xed, 0xd8, 0x92, 0x1d, 0xb8, 0xfa, 0x6a, 0x75, 0xce, 0x78, 0xac, 0xb4, 0xde, 0xde,
	0xd6, 0x93, 0x15, 0xf4, 0x1e, 0x54, 0x2e, 0xb0, 0xe7, 0x3a, 0xd6, 0xc0, 0x67, 0xae, 0x27, 0xec,
	0xb9, 0x39, 0xe0, 0x40, 0x88, 0x1f, 0x71, 0x69, 0xf9, 0x1e, 0x2c, 0xb7, 0x23, 0x82, 0x19, 0x69,
	0x7b, 0x03, 0xca, 0x48, 0x94, 0xe6, 0xd6, 0x31, 0xdc, 0x1d, 0xe3, 0x27, 0x36, 0xfe, 0x00, 0xc0,
	0x8e, 0x59, 0x96, 0xeb, 0x24, 0xd1, 0xbd, 0xc4, 0x0f, 0xcf, 0xab, 0x4d, 0x78, 0xd2, 0x3c, 0x3a,
	0xd2, 0x3a, 0x3b, 0x0b, 0x57, 0x5f, 0xad, 0x96, 0x13, 0x4d, 0xad, 0xa3, 0x97, 0x13, 0x0d, 0xcd,
	0x91, 0xdf, 0x87, 0xea, 0xb1, 0xfb, 0xa9, 0x4b, 0xa2, 0x76, 0xe0, 0x9f, 0xba, 0x3d, 0xb4, 0x05,
	0x77, 0x42, 0x4c, 0x29, 0x3b, 0x8b, 0x82, 0x41, 0xef, 0xcc, 0x22, 0x3e, 0x0f, 0xc1, 0x18, 0x77,
	0x5e, 0x47, 0x99, 0x25, 0x35, 0x5e, 0x91, 0x31, 0xa0, 0x2c, 0xc0, 0x51, 0xe8, 0x60, 0x46, 0xd0,
	0x93, 0xe9, 0x30, 0x93, 0x7c, 0xb1, 0x13, 0x04, 0xde, 0x31, 0xf6, 0x06, 0x64, 0xe2, 0x16, 0x3f,
	0x82, 0xbb, 0xbb, 0x84, 0xa5, 0xe6, 0xfb, 0xa7, 0x41, 0x1a, 0x41, 0xaf, 0x43, 0x71, 0xfa, 0x99,
	0xe7, 0xae, 0xbe, 0x5a, 0x2d, 0x6a, 0x1d, 0xbd, 0xe8, 0x3a, 0xf2, 0x3f, 0x25, 0xa8, 0x64, 0xf4,
	0x9f, 0x5b, 0x11, 0xb5, 0x60, 0x8e, 0x32, 0xcc, 0x06, 0x34, 0xc9, 0x86, 0x7a, 0x2e, 0xac, 0x12,
	0x48, 0x43, 0x48, 0xe8, 0x89, 0x24, 0xda, 0x80, 0x25, 0x0f, 0x53, 0xf6, 0x98, 0xe0, 0x88, 0x9d,
	0x10, 0xcc, 0xba, 0x34, 0x49, 0x89, 0x71, 0x36, 0x7a, 0x00, 0x73, 0xb6, 0xf0, 0xda, 0xca, 0x8c,
	0x30, 0x25, 0x1f, 0xb4, 0x59, 0xb7, 0xea, 0x89, 0xa0, 0xdc, 0x15, 0xe9, 0x94, 0xf3, 0x45, 0x12,
	0x08, 0x6f, 0xc1, 0x7c, 0x72, 0xad, 0xbc, 0xc2, 0xf2, 0x2a, 0xb9, 0x32, 0xc9, 0x58, 0xa1, 0x33,
	0x94, 0x94, 0x3f, 0x80, 0xd5, 0x11, 0x5e, 0x3b, 0xf0, 0x7d, 0x62, 0x33, 0x37, 0xf0, 0xff, 0x27,
	0x2f, 0x13, 0x58, 0x9b, 0x8e, 0x95, 0x58, 0xf9, 0x3d, 0x28, 0xbb, 0xa1, 0xe2, 0x38, 0x11, 0xa1,
	0xc9, 0x43, 0x10, 0x07, 0xa7, 0x76, 0x98, 0x30, 0xf5, 0xd1, 0xfa, 0xe8, 0x8d, 0x2a, 0x66, 0xde,
	0x28, 0xf9, 0x0f, 0x12, 0xac, 0xc5, 0x61, 0x96, 0x6c, 0x95, 0x73, 0xd4, 0x0b, 0x1a, 0x8d, 0x3a,
	0xb0, 0x10, 0xbb, 0xd6, 0x1a, 0x08, 0x4c, 0xb1, 0x57, 0xa5, 0xb5, 0x3a, 0xf5, 0x2a, 0xe2, 0xad,
	0xf5, 0xaa, 0x9d, 0xa1, 0xe4, 0x75, 0xb8, 0x7f, 0x83, 0x49, 0xf1, 0xd9, 0x65, 0x03, 0xea, 0xea,
	0x33, 0x16, 0x61, 0x9b, 0x1d, 0xbb, 0xf4, 0xd1, 0xc0, 0xb7, 0x69, 0xd6, 0xcd, 0xf7, 0x60, 0x8e,
	0xda, 0x91, 0x1b, 0xb2, 0xa4, 0xde, 0x24, 0x14, 0x7f, 0x92, 0x4f, 0x07, 0xbe, 0x2d, 0x4a, 0x24,
	0x15, 0xef, 0x5f, 0x59, 0x2f, 0x73, 0x0e, 0xaf, 0x8f, 0x54, 0xfe, 0x8f, 0x04, 0x55, 0x8e, 0xa5,
	0x44, 0x3d, 0x6a, 0x84, 0xc4, 0x46, 0x0f, 0x60, 0x06, 0x47, 0xbd, 0x34, 0x06, 0x5e, 0xcb, 0x9d,
	0x23, 0x2b, 0xd8, 0x54, 0xa2, 0x9e, 0x2e, 0x44, 0xeb, 0x7f, 0x93, 0xa0, 0xa4, 0x44, 0x3d, 0xd4,
	0x82, 0xb2, 0x83, 0x19, 0x8e, 0xeb, 0xa8, 0x24, 0x02, 0x3e, 0xff, 0xd2, 0x76, 0x30, 0xc3, 0xa2,
	0x86, 0xce, 0x3b, 0xc9, 0x17, 0xaf, 0xbf, 0x94, 0xf4, 0xb1, 0xcf, 0x5c, 0x7b, 0xfa, 0xb3, 0x61,
	0x24, 0x12, 0x71, 0xfd, 0xa5, 0x19, 0x6a, 0xf8, 0xe0, 0x97, 0x32, 0x0f, 0xfe, 0x3a, 0x2c, 0x38,
	0xe4, 0x14, 0x0f, 0x3c, 0x66, 0x5d, 0xf0, 0xaa, 0x90, 0x3c, 0x76, 0xd5, 0x84, 0x29, 0x2a, 0x85,
	0xfc, 0xff, 0x70, 0xeb, 0xd8, 0x8d, 0x8f, 0xfc, 0x0a, 0x94, 0x2f, 0x48, 0x0f, 0x5b, 0x34, 0x24,
	0x76, 0xe2, 0xbd, 0x79, 0xce, 0xe0, 0x8b, 0xf2, 0x9f, 0x67, 0xe0, 0x95, 0x89, 0x6e, 0x4f, 0x22,
	0xf2, 0xa7, 0xb0, 0xe8, 0x04, 0x36, 0x7f, 0x5d, 0x5c, 0xbf, 0x67, 0xf5, 0x71, 0x98, 0x78, 0xee,
	0xdd, 0xdc, 0x09, 0x6e, 0x40, 0x68, 0x76, 0x02, 0xdb, 0x10, 0xda, 0xfb, 0x38, 0x54, 0x7d, 0x16,
	0x5d, 0xea, 0x55, 0x27, 0xc3, 0x42, 0x1f, 0x43, 0xf5, 0xc2, 0xa5, 0xc2, 0x3a, 0x81, 0x1f, 0xf7,
	0x30, 0x0f, 0x9f, 0x1b, 0x3f, 0x39, 0xe6, 0x10, 0x1d, 0x2e, 0x86, 0x0c, 0xf4, 0x14, 0x2a, 0xa7,
	0xbe, 0xc5, 0x6f, 0x51, 0x40, 0x97, 0x04, 0xf4, 0x3b, 0xcf, 0x0d, 0xfd, 0xc8, 0xe7, 0xe1, 0x30,
	0x44, 0x2e, 0x9f, 0xa6, 0x74, 0xfd, 0x7d, 0xb8, 0x7d, 0xed, 0x5c, 0xfc, 0x41, 0x3c, 0x27, 0x97,
	0xe9, 0x83, 0x78, 0x4e, 0x44, 0x1b, 0x19, 0x5f, 0x51, 0x92, 0xa2, 0x82, 0x78, 0xb7, 0xf8, 0x50,
	0xaa, 0x1b, 0xb0, 0x34, 0x66, 0xf8, 0x04, 0xf5, 0xcd, 0xac, 0x7a, 0xa5, 0xb5, 0x3c, 0x96, 0x75,
	0x42, 0x3d, 0x0b, 0xfa, 0x14, 0x16, 0xf3, 0x26, 0x4f, 0xc0, 0xdc, 0xca, 0x63, 0xbe, 0x3c, 0x35,
	0x03, 0x32, 0xc0, 0xf2, 0x6f, 0x25, 0xb8, 0xa3, 0x0c, 0x58, 0x60, 0x07, 0xfd, 0xd0, 0x23, 0x8c,
	0xa4, 0x59, 0xb9, 0x0c, 0xb3, 0xae, 0x1f, 0x0e, 0xd2, 0xa4, 0x8c, 0x09, 0x9e, 0x93, 0xf6, 0x20,
	0xa2, 0x41, 0x64, 0x85, 0x01, 0x4d, 0xdb, 0xe4, 0x98, 0x73, 0x18, 0x50, 0xf4, 0x1e, 0xcc, 0x61,
	0x51, 0xfa, 0x92, 0x66, 0x64, 0x3d, 0xdf, 0x8c, 0x64, 0xb6, 0x51, 0x84, 0x98, 0x48, 0x8b, 0x44,
	0x45, 0xfe, 0x8b, 0x04, 0x0b, 0x26, 0x3e, 0x31, 0x06, 0xbd, 0x1e, 0xa1, 0x9c, 0xc3, 0xc3, 0x9b,
	0xe1, 0x13, 0xcb, 0xf5, 0x1d, 0xf2, 0x4c, 0xd8, 0x51, 0xd2, 0xe7, 0x19, 0x3e, 0xd1, 0x38, 0x8d,
	0xb6, 0xe1, 0x25, 0xf2, 0x8c, 0xd8, 0x03, 0x16, 0x77, 0x98, 0xa7, 0xbc, 0x11, 0xa0, 0xc4, 0x23,
	0x76, 0xdc, 0xbe, 0xcf, 0xeb, 0x77, 0x47, 0xcb, 0x0a, 0x5f, 0x35, 0xc4, 0x22, 0x52, 0xa1, 0x42,
	0x87, 0x5b, 0xd0, 0x24, 0x70, 0xa6, 0x1b, 0x3a, 0x32, 0x47, 0xcf, 0xea, 0x71, 0xbf, 0xdd, 0x9b,
	0x2c, 0x87, 0xde, 0x81, 0x99, 0x73, 0xd7, 0x77, 0x92, 0x42, 0x32, 0x1d, 0x5a, 0xf5, 0x99, 0xcb,
	0x2e, 0x9f, 0xb8, 0xbe, 0xa3, 0x0b, 0x85, 0x61, 0x49, 0x28, 0x66, 0x4a, 0xc2, 0x1a, 0x54, 0x1c,
	0x12, 0x57, 0xc4, 0xd4, 0xaf, 0x65, 0x3d, 0xcb, 0x92, 0x3f, 0x93, 0x60, 0x39, 0x7f, 0x83, 0x49,
	0x82, 0xbf, 0x0e, 0x4b, 0xa7, 0x41, 0xd4, 0xc7, 0x8c, 0x11, 0xc7, 0xca, 0x5e, 0xe6, 0xe2, 0x90,
	0xad, 0x89, 0x5b, 0x5d, 0x87, 0x05, 0x97, 0x5a, 0x23, 0x77, 0x25, 0x0e, 0xac, 0xba, 0x54, 0x1d,
	0xf2, 0xd0, 0x0e, 0x2c, 0xb2, 0xec, 0xed, 0xa4, 0xae, 0xcb, 0x77, 0x06, 0xb9, 0x0b, 0xd4, 0xc7,
	0x34, 0x36, 0x7f, 0x2d, 0x41, 0x35, 0xdb, 0x92, 0xa2, 0x45, 0x00, 0xc5, 0xb4, 0x8e, 0xba, 0x4f,
	0xba, 0x07, 0x4f, 0xbb, 0xb5, 0x02, 0x42, 0xb0, 0xa8, 0x98, 0xd6, 0x9e, 0xd6, 0x3d, 0xfa, 0xd0,
	0x52, 0xf6, 0x3b, 0xdb, 0x6f, 0xd5, 0x24, 0x74, 0x07, 0x96, 0x14, 0xd3, 0xea, 0x28, 0xfa, 0x53,
	0xad, 0x9b, 0x30, 0x8b, 0xa8, 0x0e, 0xf7, 0x14, 0xd3, 0x6a, 0x1f, 0x74, 0x4d, 0x45, 0xeb, 0xaa,
	0xba, 0x65, 0xa8, 0xa6, 0xf5, 0x91, 0xb2, 0xbf, 0x67, 0xd4, 0x5a, 0x68, 0x0d, 0x5e, 0xbd, 0xb6,
	0x96, 0x85, 0x74, 0x36, 0x8f, 0x61, 0x21, 0xd7, 0xc2, 0x70, 0x3b, 0xda, 0x46, 0xc6, 0x8e, 0x98,
	0x7e, 0xac, 0x2a, 0x7b, 0xe6, 0xe3, 0x8f, 0x6a, 0x12, 0xaa, 0x41, 0x55, 0xac, 0xa7, 0x9c, 0x22,
	0xb7, 0xaa, 0x6d, 0x58, 0x1d, 0xcd, 0x68, 0x1f, 0x74, 0xbb, 0x6a, 0xdb, 0x54, 0x3b, 0xb5, 0xd2,
	0x26, 0x81, 0xaa, 0x91, 0xaf, 0xf1, 0x8b, 0x06, 0x3f, 0x9e, 0x71, 0xa8, 0xb6, 0xb5, 0x47, 0x9a,
	0xda, 0xa9, 0x15, 0x50, 0x05, 0x6e, 0x19, 0xa6, 0xd5, 0x3d, 0xe8, 0xaa, 0x31, 0xae, 0x61, 0x5a,
	0xca, 0xae, 0xda, 0x35, 0xad, 0x23, 0xad, 0x53, 0x73, 0x50, 0x55, 0x2c, 0x1f, 0x1d, 0x6a, 0x9d,
	0xda, 0xe7, 0x12, 0x5a, 0x86, 0x25, 0xc3, 0xb4, 0x0c, 0x55, 0x3f, 0xd6, 0xda, 0xaa, 0xd5, 0x55,
	0xf6, 0xd5, 0xda, 0x5f, 0x8b, 0x9b, 0xbf, 0x84, 0xf9, 0xf4, 0x41, 0x42, 0x77, 0xe1, 0x76, 0x47,
	0x31, 0x15, 0xcb, 0xfc, 0xe8, 0x50, 0xcd, 0x1c, 0xa0, 0x02, 0xb7, 0x76, 0x0e, 0x0e, 0xf6, 0x54,
	0xa5, 0x5b, 0x93, 0x50, 0x19, 0x66, 0xb5, 0xae, 0x29, 0xfc, 0x56, 0x81, 0x5b, 0x47, 0x5a, 0xd7,
	0x7c, 0xd0, 0x7a, 0x58, 0x2b, 0x71, 0xe2, 0xd1, 0xde, 0x81, 0xc2, 0x57, 0x66, 0x10, 0xc0, 0x9c,
	0x61, 0xea, 0x5a, 0x77, 0xb7, 0x36, 0x8b, 0xaa, 0x30, 0x6f, 0x6a, 0xfb, 0xea, 0xf6, 0x5b, 0x5d,
	0xa3, 0x36, 0xc7, 0x8d, 0xec, 0x1c, 0xe9, 0x8a, 0xa9, 0x1d, 0x74, 0x05, 0xe7, 0xd6, 0xe6, 0x6e,
	0x3e, 0xf6, 0x47, 0xc9, 0x8c, 0x96, 0xa0, 0xa2, 0xe4, 0x6e, 0xb4, 0x0a, 0xf3, 0x9c, 0xa1, 0x76,
	0x34, 0xb3, 0x26, 0x89, 0xfb, 0x56, 0xf8, 0x81, 0xf6, 0xd4, 0xb6, 0x59, 0x2b, 0x6e, 0x9e, 0xe6,
	0x81, 0x46, 0x19, 0x21, 0x80, 0xd4, 0x27, 0xf9, 0x13, 0x71, 0xc6, 0xe1, 0x41, 0xa7, 0x26, 0xa5,
	0x84, 0x71, 0xdc, 0xae, 0x15, 0x05, 0x28, 0x27, 0xda, 0xba, 0x76, 0x68, 0xd6, 0x4a, 0xe8, 0x36,
	0x2c, 0x70, 0x9a, 0x7b, 0xcb, 0x38, 0x54, 0xda, 0x6a, 0x6d, 0xa6, 0xb5, 0x07, 0x15, 0x65, 0xc0,
	0xce, 0x0c, 0x12, 0x5d, 0xb8, 0x36, 0x9f, 0x1d, 0x66, 0xc5, 0x3f, 0x02, 0x28, 0x5f, 0x23, 0xb3,
	0x7f, 0x2c, 0xd4, 0x5f, 0x9a, 0xb4, 0x14, 0x7a, 0x97, 0x72, 0xa1, 0xf5, 0x1b, 0x09, 0x56, 0xe2,
	0x46, 0x47, 0xcc, 0xfc, 0x1c, 0x39, 0x88, 0xdc, 0x4f, 0xb1, 0xc8, 0xfe, 0x9f, 0xc1, 0x9d, 0x09,
	0x7f, 0x06, 0xa0, 0xd7, 0x73, 0x70, 0xd3, 0xff, 0x4c, 0xa8, 0x6f, 0x7c, 0xb7, 0x60, 0xd2, 0x56,
	0x15, 0x5a, 0xff, 0x90, 0x60, 0x69, 0x98, 0x4f, 0x11, 0xb6, 0xcf, 0x49, 0x84, 0x74, 0x58, 0x1a,
	0x9b, 0x86, 0xd1, 0xfa, 0x38, 0xe4, 0x84, 0x59, 0xb9, 0xbe, 0x32, 0x71, 0x70, 0x34, 0x08, 0x93,
	0x0b, 0xe8, 0x27, 0x02, 0x33, 0x3b, 0x2a, 0x5e, 0xc7, 0x9c, 0x30, 0xe9, 0xd6, 0xff, 0xef, 0x66,
	0xa1, 0xe1, 0x39, 0xfe, 0x5e, 0x82, 0xdb, 0x49, 0xe7, 0x98, 0x19, 0x56, 0x3e, 0x84, 0x85, 0xdc,
	0xe8, 0x87, 0xee, 0xe7, 0xfb, 0xfa, 0x09, 0xe3, 0x62, 0x5d, 0xbe, 0x49, 0x24, 0xdd, 0x0f, 0xfd,
	0x18, 0x16, 0xf3, 0xc3, 0x04, 0x92, 0xc7, 0x2d, 0xbd, 0x3e, 0x75, 0xd5, 0xd7, 0x6f, 0x94, 0x19,
	0x82, 0x5f, 0xc2, 0xca, 0xb4, 0x69, 0x00, 0x7d, 0x7f, 0x0a, 0xc4, 0xc4, 0x01, 0xa4, 0xfe, 0xc6,
	0x73, 0x4a, 0x0f, 0xb7, 0xfe, 0x05, 0xbc, 0x3c, 0xb5, 0x1b, 0x47, 0x79, 0xb4, 0xef, 0x1a, 0x24,
	0xea, 0xcd, 0xe7, 0x15, 0x1f, 0xde, 0xe2, 0x27, 0x50, 0x36, 0xc4, 0xab, 0xb4, 0xdf, 0x8b, 0x78,
	0x1a, 0x4c, 0xe8, 0xbf, 0xc6, 0xd2, 0x60, 0xfa, 0x54, 0x30, 0x96, 0x06, 0x37, 0xb4, 0x72, 0x72,
	0xa1, 0xe5, 0xe5, 0x5b, 0x98, 0x34, 0xcb, 0x8f, 0xa0, 0x9a, 0x65, 0xa3, 0xb5, 0xa9, 0x2f, 0x71,
	0xba, 0xe9, 0xfd, 0x1b, 0x24, 0xd2, 0xdd, 0x76, 0xbc, 0x2f, 0xbe, 0x6e, 0x14, 0xbe, 0xfc, 0xba,
	0x51, 0xf8, 0xf6, 0xeb, 0x86, 0xf4, 0xab, 0xab, 0x86, 0xf4, 0xd9, 0x55, 0x43, 0xfa, 0xfc, 0xaa,
	0x21, 0x7d, 0x71, 0xd5, 0x90, 0xfe, 0x75, 0xd5, 0x90, 0xfe, 0x7d, 0xd5, 0x28, 0x7c, 0x7b, 0xd5,
	0x90, 0x7e, 0xff, 0x4d, 0xa3, 0xf0, 0xc5, 0x37, 0x8d, 0xc2, 0x97, 0xdf, 0x34, 0x0a, 0x1f, 0x6f,
	0x87, 0xee, 0x33, 0x97, 0x78, 0xf8, 0x84, 0x36, 0xb1, 0xbb, 0x35, 0x24, 0xb6, 0x26, 0xfd, 0x25,
	0xfb, 0xde, 0xe8, 0xf3, 0x64, 0x4e, 0xfc, 0x57, 0xf0, 0xe6, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0xab, 0x4a, 0x43, 0x0f, 0xbc, 0x15, 0x00, 0x00,
}

func (x ArtifactType) String() string {
	s, ok := ArtifactType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ClusterStatus) String() string {
	s, ok := ClusterStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SemanticType) String() string {
	s, ok := SemanticType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DataType) String() string {
	s, ok := DataType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AutocompleteActionType) String() string {
	s, ok := AutocompleteActionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AutocompleteEntityKind) String() string {
	s, ok := AutocompleteEntityKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LoginRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginRequest)
	if !ok {
		that2, ok := that.(LoginRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	return true
}
func (this *LoginReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginReply)
	if !ok {
		that2, ok := that.(LoginReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	return true
}
func (this *GetImageCredentialsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetImageCredentialsRequest)
	if !ok {
		that2, ok := that.(GetImageCredentialsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetImageCredentialsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetImageCredentialsResponse)
	if !ok {
		that2, ok := that.(GetImageCredentialsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Creds != that1.Creds {
		return false
	}
	return true
}
func (this *ArtifactSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArtifactSet)
	if !ok {
		that2, ok := that.(ArtifactSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Artifact) != len(that1.Artifact) {
		return false
	}
	for i := range this.Artifact {
		if !this.Artifact[i].Equal(that1.Artifact[i]) {
			return false
		}
	}
	return true
}
func (this *Artifact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Artifact)
	if !ok {
		that2, ok := that.(Artifact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.CommitHash != that1.CommitHash {
		return false
	}
	if this.VersionStr != that1.VersionStr {
		return false
	}
	if len(this.AvailableArtifacts) != len(that1.AvailableArtifacts) {
		return false
	}
	for i := range this.AvailableArtifacts {
		if this.AvailableArtifacts[i] != that1.AvailableArtifacts[i] {
			return false
		}
	}
	if this.Changelog != that1.Changelog {
		return false
	}
	return true
}
func (this *GetArtifactListRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetArtifactListRequest)
	if !ok {
		that2, ok := that.(GetArtifactListRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ArtifactName != that1.ArtifactName {
		return false
	}
	if this.ArtifactType != that1.ArtifactType {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *GetDownloadLinkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetDownloadLinkRequest)
	if !ok {
		that2, ok := that.(GetDownloadLinkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ArtifactName != that1.ArtifactName {
		return false
	}
	if this.VersionStr != that1.VersionStr {
		return false
	}
	if this.ArtifactType != that1.ArtifactType {
		return false
	}
	return true
}
func (this *GetDownloadLinkResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetDownloadLinkResponse)
	if !ok {
		that2, ok := that.(GetDownloadLinkResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.SHA256 != that1.SHA256 {
		return false
	}
	if !this.ValidUntil.Equal(that1.ValidUntil) {
		return false
	}
	return true
}
func (this *CreateClusterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateClusterRequest)
	if !ok {
		that2, ok := that.(CreateClusterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CreateClusterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateClusterResponse)
	if !ok {
		that2, ok := that.(CreateClusterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterID.Equal(that1.ClusterID) {
		return false
	}
	return true
}
func (this *VizierConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VizierConfig)
	if !ok {
		that2, ok := that.(VizierConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PassthroughEnabled != that1.PassthroughEnabled {
		return false
	}
	return true
}
func (this *VizierConfigUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VizierConfigUpdate)
	if !ok {
		that2, ok := that.(VizierConfigUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassthroughEnabled.Equal(that1.PassthroughEnabled) {
		return false
	}
	return true
}
func (this *GetClusterInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterInfoRequest)
	if !ok {
		that2, ok := that.(GetClusterInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *ClusterInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClusterInfo)
	if !ok {
		that2, ok := that.(ClusterInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.LastHeartbeatNs != that1.LastHeartbeatNs {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *GetClusterInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterInfoResponse)
	if !ok {
		that2, ok := that.(GetClusterInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Clusters) != len(that1.Clusters) {
		return false
	}
	for i := range this.Clusters {
		if !this.Clusters[i].Equal(that1.Clusters[i]) {
			return false
		}
	}
	return true
}
func (this *GetClusterConnectionInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterConnectionInfoRequest)
	if !ok {
		that2, ok := that.(GetClusterConnectionInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *GetClusterConnectionInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterConnectionInfoResponse)
	if !ok {
		that2, ok := that.(GetClusterConnectionInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IPAddress != that1.IPAddress {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *UpdateClusterVizierConfigRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateClusterVizierConfigRequest)
	if !ok {
		that2, ok := that.(UpdateClusterVizierConfigRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.ConfigUpdate.Equal(that1.ConfigUpdate) {
		return false
	}
	return true
}
func (this *UpdateClusterVizierConfigResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateClusterVizierConfigResponse)
	if !ok {
		that2, ok := that.(UpdateClusterVizierConfigResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ExtractVisFuncsInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtractVisFuncsInfoRequest)
	if !ok {
		that2, ok := that.(ExtractVisFuncsInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Script != that1.Script {
		return false
	}
	if len(this.FuncNames) != len(that1.FuncNames) {
		return false
	}
	for i := range this.FuncNames {
		if this.FuncNames[i] != that1.FuncNames[i] {
			return false
		}
	}
	return true
}
func (this *FuncArgsSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FuncArgsSpec)
	if !ok {
		that2, ok := that.(FuncArgsSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(that1.Args[i]) {
			return false
		}
	}
	return true
}
func (this *FuncArgsSpec_Arg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FuncArgsSpec_Arg)
	if !ok {
		that2, ok := that.(FuncArgsSpec_Arg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.SemanticType != that1.SemanticType {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DefaultValue != that1.DefaultValue {
		return false
	}
	return true
}
func (this *VisSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VisSpec)
	if !ok {
		that2, ok := that.(VisSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VegaSpec != that1.VegaSpec {
		return false
	}
	return true
}
func (this *ExtractVisFuncsInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtractVisFuncsInfoResponse)
	if !ok {
		that2, ok := that.(ExtractVisFuncsInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DocStringMap) != len(that1.DocStringMap) {
		return false
	}
	for i := range this.DocStringMap {
		if this.DocStringMap[i] != that1.DocStringMap[i] {
			return false
		}
	}
	if len(this.VisSpecMap) != len(that1.VisSpecMap) {
		return false
	}
	for i := range this.VisSpecMap {
		if !this.VisSpecMap[i].Equal(that1.VisSpecMap[i]) {
			return false
		}
	}
	if len(this.FnArgsMap) != len(that1.FnArgsMap) {
		return false
	}
	for i := range this.FnArgsMap {
		if !this.FnArgsMap[i].Equal(that1.FnArgsMap[i]) {
			return false
		}
	}
	return true
}
func (this *AutocompleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteRequest)
	if !ok {
		that2, ok := that.(AutocompleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Input != that1.Input {
		return false
	}
	if this.CursorPos != that1.CursorPos {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *TabSuggestion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TabSuggestion)
	if !ok {
		that2, ok := that.(TabSuggestion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TabIndex != that1.TabIndex {
		return false
	}
	if this.ExecutableAfterSelect != that1.ExecutableAfterSelect {
		return false
	}
	if len(this.Suggestions) != len(that1.Suggestions) {
		return false
	}
	for i := range this.Suggestions {
		if !this.Suggestions[i].Equal(that1.Suggestions[i]) {
			return false
		}
	}
	return true
}
func (this *AutocompleteSuggestion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteSuggestion)
	if !ok {
		that2, ok := that.(AutocompleteSuggestion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *AutocompleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteResponse)
	if !ok {
		that2, ok := that.(AutocompleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FormattedInput != that1.FormattedInput {
		return false
	}
	if this.IsExecutable != that1.IsExecutable {
		return false
	}
	if len(this.TabSuggestions) != len(that1.TabSuggestions) {
		return false
	}
	for i := range this.TabSuggestions {
		if !this.TabSuggestions[i].Equal(that1.TabSuggestions[i]) {
			return false
		}
	}
	return true
}
func (this *LoginRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.LoginRequest{")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.LoginReply{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "ExpiresAt: "+fmt.Sprintf("%#v", this.ExpiresAt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetImageCredentialsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.GetImageCredentialsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetImageCredentialsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetImageCredentialsResponse{")
	s = append(s, "Creds: "+fmt.Sprintf("%#v", this.Creds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArtifactSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.ArtifactSet{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Artifact != nil {
		s = append(s, "Artifact: "+fmt.Sprintf("%#v", this.Artifact)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Artifact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloudapipb.Artifact{")
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	}
	s = append(s, "CommitHash: "+fmt.Sprintf("%#v", this.CommitHash)+",\n")
	s = append(s, "VersionStr: "+fmt.Sprintf("%#v", this.VersionStr)+",\n")
	s = append(s, "AvailableArtifacts: "+fmt.Sprintf("%#v", this.AvailableArtifacts)+",\n")
	s = append(s, "Changelog: "+fmt.Sprintf("%#v", this.Changelog)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetArtifactListRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetArtifactListRequest{")
	s = append(s, "ArtifactName: "+fmt.Sprintf("%#v", this.ArtifactName)+",\n")
	s = append(s, "ArtifactType: "+fmt.Sprintf("%#v", this.ArtifactType)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetDownloadLinkRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetDownloadLinkRequest{")
	s = append(s, "ArtifactName: "+fmt.Sprintf("%#v", this.ArtifactName)+",\n")
	s = append(s, "VersionStr: "+fmt.Sprintf("%#v", this.VersionStr)+",\n")
	s = append(s, "ArtifactType: "+fmt.Sprintf("%#v", this.ArtifactType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetDownloadLinkResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetDownloadLinkResponse{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "SHA256: "+fmt.Sprintf("%#v", this.SHA256)+",\n")
	if this.ValidUntil != nil {
		s = append(s, "ValidUntil: "+fmt.Sprintf("%#v", this.ValidUntil)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateClusterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.CreateClusterRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateClusterResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.CreateClusterResponse{")
	if this.ClusterID != nil {
		s = append(s, "ClusterID: "+fmt.Sprintf("%#v", this.ClusterID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VizierConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.VizierConfig{")
	s = append(s, "PassthroughEnabled: "+fmt.Sprintf("%#v", this.PassthroughEnabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VizierConfigUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.VizierConfigUpdate{")
	if this.PassthroughEnabled != nil {
		s = append(s, "PassthroughEnabled: "+fmt.Sprintf("%#v", this.PassthroughEnabled)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterInfoRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClusterInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloudapipb.ClusterInfo{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "LastHeartbeatNs: "+fmt.Sprintf("%#v", this.LastHeartbeatNs)+",\n")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterInfoResponse{")
	if this.Clusters != nil {
		s = append(s, "Clusters: "+fmt.Sprintf("%#v", this.Clusters)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterConnectionInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterConnectionInfoRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterConnectionInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.GetClusterConnectionInfoResponse{")
	s = append(s, "IPAddress: "+fmt.Sprintf("%#v", this.IPAddress)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateClusterVizierConfigRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.UpdateClusterVizierConfigRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.ConfigUpdate != nil {
		s = append(s, "ConfigUpdate: "+fmt.Sprintf("%#v", this.ConfigUpdate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateClusterVizierConfigResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.UpdateClusterVizierConfigResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExtractVisFuncsInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.ExtractVisFuncsInfoRequest{")
	s = append(s, "Script: "+fmt.Sprintf("%#v", this.Script)+",\n")
	s = append(s, "FuncNames: "+fmt.Sprintf("%#v", this.FuncNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FuncArgsSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.FuncArgsSpec{")
	if this.Args != nil {
		s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FuncArgsSpec_Arg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloudapipb.FuncArgsSpec_Arg{")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	s = append(s, "SemanticType: "+fmt.Sprintf("%#v", this.SemanticType)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "DefaultValue: "+fmt.Sprintf("%#v", this.DefaultValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VisSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.VisSpec{")
	s = append(s, "VegaSpec: "+fmt.Sprintf("%#v", this.VegaSpec)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExtractVisFuncsInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.ExtractVisFuncsInfoResponse{")
	keysForDocStringMap := make([]string, 0, len(this.DocStringMap))
	for k, _ := range this.DocStringMap {
		keysForDocStringMap = append(keysForDocStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDocStringMap)
	mapStringForDocStringMap := "map[string]string{"
	for _, k := range keysForDocStringMap {
		mapStringForDocStringMap += fmt.Sprintf("%#v: %#v,", k, this.DocStringMap[k])
	}
	mapStringForDocStringMap += "}"
	if this.DocStringMap != nil {
		s = append(s, "DocStringMap: "+mapStringForDocStringMap+",\n")
	}
	keysForVisSpecMap := make([]string, 0, len(this.VisSpecMap))
	for k, _ := range this.VisSpecMap {
		keysForVisSpecMap = append(keysForVisSpecMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVisSpecMap)
	mapStringForVisSpecMap := "map[string]*VisSpec{"
	for _, k := range keysForVisSpecMap {
		mapStringForVisSpecMap += fmt.Sprintf("%#v: %#v,", k, this.VisSpecMap[k])
	}
	mapStringForVisSpecMap += "}"
	if this.VisSpecMap != nil {
		s = append(s, "VisSpecMap: "+mapStringForVisSpecMap+",\n")
	}
	keysForFnArgsMap := make([]string, 0, len(this.FnArgsMap))
	for k, _ := range this.FnArgsMap {
		keysForFnArgsMap = append(keysForFnArgsMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFnArgsMap)
	mapStringForFnArgsMap := "map[string]*FuncArgsSpec{"
	for _, k := range keysForFnArgsMap {
		mapStringForFnArgsMap += fmt.Sprintf("%#v: %#v,", k, this.FnArgsMap[k])
	}
	mapStringForFnArgsMap += "}"
	if this.FnArgsMap != nil {
		s = append(s, "FnArgsMap: "+mapStringForFnArgsMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.AutocompleteRequest{")
	s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	s = append(s, "CursorPos: "+fmt.Sprintf("%#v", this.CursorPos)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TabSuggestion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.TabSuggestion{")
	s = append(s, "TabIndex: "+fmt.Sprintf("%#v", this.TabIndex)+",\n")
	s = append(s, "ExecutableAfterSelect: "+fmt.Sprintf("%#v", this.ExecutableAfterSelect)+",\n")
	if this.Suggestions != nil {
		s = append(s, "Suggestions: "+fmt.Sprintf("%#v", this.Suggestions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteSuggestion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.AutocompleteSuggestion{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.AutocompleteResponse{")
	s = append(s, "FormattedInput: "+fmt.Sprintf("%#v", this.FormattedInput)+",\n")
	s = append(s, "IsExecutable: "+fmt.Sprintf("%#v", this.IsExecutable)+",\n")
	if this.TabSuggestions != nil {
		s = append(s, "TabSuggestions: "+fmt.Sprintf("%#v", this.TabSuggestions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloudapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error) {
	out := new(LoginReply)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.AuthService/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginReply, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) Login(ctx context.Context, req *LoginRequest) (*LoginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.AuthService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// VizierImageAuthorizationClient is the client API for VizierImageAuthorization service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VizierImageAuthorizationClient interface {
	GetImageCredentials(ctx context.Context, in *GetImageCredentialsRequest, opts ...grpc.CallOption) (*GetImageCredentialsResponse, error)
}

type vizierImageAuthorizationClient struct {
	cc *grpc.ClientConn
}

func NewVizierImageAuthorizationClient(cc *grpc.ClientConn) VizierImageAuthorizationClient {
	return &vizierImageAuthorizationClient{cc}
}

func (c *vizierImageAuthorizationClient) GetImageCredentials(ctx context.Context, in *GetImageCredentialsRequest, opts ...grpc.CallOption) (*GetImageCredentialsResponse, error) {
	out := new(GetImageCredentialsResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierImageAuthorization/GetImageCredentials", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VizierImageAuthorizationServer is the server API for VizierImageAuthorization service.
type VizierImageAuthorizationServer interface {
	GetImageCredentials(context.Context, *GetImageCredentialsRequest) (*GetImageCredentialsResponse, error)
}

// UnimplementedVizierImageAuthorizationServer can be embedded to have forward compatible implementations.
type UnimplementedVizierImageAuthorizationServer struct {
}

func (*UnimplementedVizierImageAuthorizationServer) GetImageCredentials(ctx context.Context, req *GetImageCredentialsRequest) (*GetImageCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageCredentials not implemented")
}

func RegisterVizierImageAuthorizationServer(s *grpc.Server, srv VizierImageAuthorizationServer) {
	s.RegisterService(&_VizierImageAuthorization_serviceDesc, srv)
}

func _VizierImageAuthorization_GetImageCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierImageAuthorizationServer).GetImageCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierImageAuthorization/GetImageCredentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierImageAuthorizationServer).GetImageCredentials(ctx, req.(*GetImageCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VizierImageAuthorization_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.VizierImageAuthorization",
	HandlerType: (*VizierImageAuthorizationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetImageCredentials",
			Handler:    _VizierImageAuthorization_GetImageCredentials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// ArtifactTrackerClient is the client API for ArtifactTracker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArtifactTrackerClient interface {
	GetArtifactList(ctx context.Context, in *GetArtifactListRequest, opts ...grpc.CallOption) (*ArtifactSet, error)
	GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error)
}

type artifactTrackerClient struct {
	cc *grpc.ClientConn
}

func NewArtifactTrackerClient(cc *grpc.ClientConn) ArtifactTrackerClient {
	return &artifactTrackerClient{cc}
}

func (c *artifactTrackerClient) GetArtifactList(ctx context.Context, in *GetArtifactListRequest, opts ...grpc.CallOption) (*ArtifactSet, error) {
	out := new(ArtifactSet)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ArtifactTracker/GetArtifactList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artifactTrackerClient) GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error) {
	out := new(GetDownloadLinkResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ArtifactTracker/GetDownloadLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArtifactTrackerServer is the server API for ArtifactTracker service.
type ArtifactTrackerServer interface {
	GetArtifactList(context.Context, *GetArtifactListRequest) (*ArtifactSet, error)
	GetDownloadLink(context.Context, *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error)
}

// UnimplementedArtifactTrackerServer can be embedded to have forward compatible implementations.
type UnimplementedArtifactTrackerServer struct {
}

func (*UnimplementedArtifactTrackerServer) GetArtifactList(ctx context.Context, req *GetArtifactListRequest) (*ArtifactSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifactList not implemented")
}
func (*UnimplementedArtifactTrackerServer) GetDownloadLink(ctx context.Context, req *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDownloadLink not implemented")
}

func RegisterArtifactTrackerServer(s *grpc.Server, srv ArtifactTrackerServer) {
	s.RegisterService(&_ArtifactTracker_serviceDesc, srv)
}

func _ArtifactTracker_GetArtifactList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactTrackerServer).GetArtifactList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ArtifactTracker/GetArtifactList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactTrackerServer).GetArtifactList(ctx, req.(*GetArtifactListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtifactTracker_GetDownloadLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactTrackerServer).GetDownloadLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ArtifactTracker/GetDownloadLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactTrackerServer).GetDownloadLink(ctx, req.(*GetDownloadLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArtifactTracker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.ArtifactTracker",
	HandlerType: (*ArtifactTrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetArtifactList",
			Handler:    _ArtifactTracker_GetArtifactList_Handler,
		},
		{
			MethodName: "GetDownloadLink",
			Handler:    _ArtifactTracker_GetDownloadLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// VizierClusterInfoClient is the client API for VizierClusterInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VizierClusterInfoClient interface {
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error)
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	GetClusterConnectionInfo(ctx context.Context, in *GetClusterConnectionInfoRequest, opts ...grpc.CallOption) (*GetClusterConnectionInfoResponse, error)
	UpdateClusterVizierConfig(ctx context.Context, in *UpdateClusterVizierConfigRequest, opts ...grpc.CallOption) (*UpdateClusterVizierConfigResponse, error)
}

type vizierClusterInfoClient struct {
	cc *grpc.ClientConn
}

func NewVizierClusterInfoClient(cc *grpc.ClientConn) VizierClusterInfoClient {
	return &vizierClusterInfoClient{cc}
}

func (c *vizierClusterInfoClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error) {
	out := new(CreateClusterResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/CreateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) GetClusterConnectionInfo(ctx context.Context, in *GetClusterConnectionInfoRequest, opts ...grpc.CallOption) (*GetClusterConnectionInfoResponse, error) {
	out := new(GetClusterConnectionInfoResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/GetClusterConnectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) UpdateClusterVizierConfig(ctx context.Context, in *UpdateClusterVizierConfigRequest, opts ...grpc.CallOption) (*UpdateClusterVizierConfigResponse, error) {
	out := new(UpdateClusterVizierConfigResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/UpdateClusterVizierConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VizierClusterInfoServer is the server API for VizierClusterInfo service.
type VizierClusterInfoServer interface {
	CreateCluster(context.Context, *CreateClusterRequest) (*CreateClusterResponse, error)
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	GetClusterConnectionInfo(context.Context, *GetClusterConnectionInfoRequest) (*GetClusterConnectionInfoResponse, error)
	UpdateClusterVizierConfig(context.Context, *UpdateClusterVizierConfigRequest) (*UpdateClusterVizierConfigResponse, error)
}

// UnimplementedVizierClusterInfoServer can be embedded to have forward compatible implementations.
type UnimplementedVizierClusterInfoServer struct {
}

func (*UnimplementedVizierClusterInfoServer) CreateCluster(ctx context.Context, req *CreateClusterRequest) (*CreateClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (*UnimplementedVizierClusterInfoServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (*UnimplementedVizierClusterInfoServer) GetClusterConnectionInfo(ctx context.Context, req *GetClusterConnectionInfoRequest) (*GetClusterConnectionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterConnectionInfo not implemented")
}
func (*UnimplementedVizierClusterInfoServer) UpdateClusterVizierConfig(ctx context.Context, req *UpdateClusterVizierConfigRequest) (*UpdateClusterVizierConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterVizierConfig not implemented")
}

func RegisterVizierClusterInfoServer(s *grpc.Server, srv VizierClusterInfoServer) {
	s.RegisterService(&_VizierClusterInfo_serviceDesc, srv)
}

func _VizierClusterInfo_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_GetClusterConnectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterConnectionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).GetClusterConnectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/GetClusterConnectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).GetClusterConnectionInfo(ctx, req.(*GetClusterConnectionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_UpdateClusterVizierConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterVizierConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).UpdateClusterVizierConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/UpdateClusterVizierConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).UpdateClusterVizierConfig(ctx, req.(*UpdateClusterVizierConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VizierClusterInfo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.VizierClusterInfo",
	HandlerType: (*VizierClusterInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _VizierClusterInfo_CreateCluster_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _VizierClusterInfo_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetClusterConnectionInfo",
			Handler:    _VizierClusterInfo_GetClusterConnectionInfo_Handler,
		},
		{
			MethodName: "UpdateClusterVizierConfig",
			Handler:    _VizierClusterInfo_UpdateClusterVizierConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// ScriptMgrClient is the client API for ScriptMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ScriptMgrClient interface {
	ExtractVisFuncsInfo(ctx context.Context, in *ExtractVisFuncsInfoRequest, opts ...grpc.CallOption) (*ExtractVisFuncsInfoResponse, error)
}

type scriptMgrClient struct {
	cc *grpc.ClientConn
}

func NewScriptMgrClient(cc *grpc.ClientConn) ScriptMgrClient {
	return &scriptMgrClient{cc}
}

func (c *scriptMgrClient) ExtractVisFuncsInfo(ctx context.Context, in *ExtractVisFuncsInfoRequest, opts ...grpc.CallOption) (*ExtractVisFuncsInfoResponse, error) {
	out := new(ExtractVisFuncsInfoResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ScriptMgr/ExtractVisFuncsInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScriptMgrServer is the server API for ScriptMgr service.
type ScriptMgrServer interface {
	ExtractVisFuncsInfo(context.Context, *ExtractVisFuncsInfoRequest) (*ExtractVisFuncsInfoResponse, error)
}

// UnimplementedScriptMgrServer can be embedded to have forward compatible implementations.
type UnimplementedScriptMgrServer struct {
}

func (*UnimplementedScriptMgrServer) ExtractVisFuncsInfo(ctx context.Context, req *ExtractVisFuncsInfoRequest) (*ExtractVisFuncsInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractVisFuncsInfo not implemented")
}

func RegisterScriptMgrServer(s *grpc.Server, srv ScriptMgrServer) {
	s.RegisterService(&_ScriptMgr_serviceDesc, srv)
}

func _ScriptMgr_ExtractVisFuncsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractVisFuncsInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScriptMgrServer).ExtractVisFuncsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ScriptMgr/ExtractVisFuncsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScriptMgrServer).ExtractVisFuncsInfo(ctx, req.(*ExtractVisFuncsInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScriptMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.ScriptMgr",
	HandlerType: (*ScriptMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExtractVisFuncsInfo",
			Handler:    _ScriptMgr_ExtractVisFuncsInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// AutocompleteServiceClient is the client API for AutocompleteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutocompleteServiceClient interface {
	Autocomplete(ctx context.Context, in *AutocompleteRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error)
}

type autocompleteServiceClient struct {
	cc *grpc.ClientConn
}

func NewAutocompleteServiceClient(cc *grpc.ClientConn) AutocompleteServiceClient {
	return &autocompleteServiceClient{cc}
}

func (c *autocompleteServiceClient) Autocomplete(ctx context.Context, in *AutocompleteRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error) {
	out := new(AutocompleteResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.AutocompleteService/Autocomplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutocompleteServiceServer is the server API for AutocompleteService service.
type AutocompleteServiceServer interface {
	Autocomplete(context.Context, *AutocompleteRequest) (*AutocompleteResponse, error)
}

// UnimplementedAutocompleteServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAutocompleteServiceServer struct {
}

func (*UnimplementedAutocompleteServiceServer) Autocomplete(ctx context.Context, req *AutocompleteRequest) (*AutocompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Autocomplete not implemented")
}

func RegisterAutocompleteServiceServer(s *grpc.Server, srv AutocompleteServiceServer) {
	s.RegisterService(&_AutocompleteService_serviceDesc, srv)
}

func _AutocompleteService_Autocomplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutocompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutocompleteServiceServer).Autocomplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.AutocompleteService/Autocomplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutocompleteServiceServer).Autocomplete(ctx, req.(*AutocompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutocompleteService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.AutocompleteService",
	HandlerType: (*AutocompleteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Autocomplete",
			Handler:    _AutocompleteService_Autocomplete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

func (m *LoginRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImageCredentialsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageCredentialsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageCredentialsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetImageCredentialsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageCredentialsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageCredentialsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creds) > 0 {
		i -= len(m.Creds)
		copy(dAtA[i:], m.Creds)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Creds)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Artifact) > 0 {
		for iNdEx := len(m.Artifact) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifact[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changelog) > 0 {
		i -= len(m.Changelog)
		copy(dAtA[i:], m.Changelog)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Changelog)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AvailableArtifacts) > 0 {
		dAtA2 := make([]byte, len(m.AvailableArtifacts)*10)
		var j1 int
		for _, num := range m.AvailableArtifacts {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCloudapi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VersionStr) > 0 {
		i -= len(m.VersionStr)
		copy(dAtA[i:], m.VersionStr)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VersionStr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CommitHash) > 0 {
		i -= len(m.CommitHash)
		copy(dAtA[i:], m.CommitHash)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.CommitHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetArtifactListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetArtifactListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetArtifactListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.ArtifactType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ArtifactType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ArtifactName) > 0 {
		i -= len(m.ArtifactName)
		copy(dAtA[i:], m.ArtifactName)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ArtifactName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDownloadLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDownloadLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDownloadLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ArtifactType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ArtifactType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VersionStr) > 0 {
		i -= len(m.VersionStr)
		copy(dAtA[i:], m.VersionStr)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VersionStr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ArtifactName) > 0 {
		i -= len(m.ArtifactName)
		copy(dAtA[i:], m.ArtifactName)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ArtifactName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDownloadLinkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDownloadLinkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDownloadLinkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != nil {
		{
			size, err := m.ValidUntil.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SHA256) > 0 {
		i -= len(m.SHA256)
		copy(dAtA[i:], m.SHA256)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.SHA256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateClusterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CreateClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterID != nil {
		{
			size, err := m.ClusterID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VizierConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VizierConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VizierConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PassthroughEnabled {
		i--
		if m.PassthroughEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VizierConfigUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VizierConfigUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VizierConfigUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PassthroughEnabled != nil {
		{
			size, err := m.PassthroughEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LastHeartbeatNs != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.LastHeartbeatNs))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConnectionInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConnectionInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConnectionInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConnectionInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConnectionInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConnectionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IPAddress) > 0 {
		i -= len(m.IPAddress)
		copy(dAtA[i:], m.IPAddress)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.IPAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateClusterVizierConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClusterVizierConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClusterVizierConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigUpdate != nil {
		{
			size, err := m.ConfigUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateClusterVizierConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClusterVizierConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClusterVizierConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ExtractVisFuncsInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractVisFuncsInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractVisFuncsInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FuncNames) > 0 {
		for iNdEx := len(m.FuncNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FuncNames[iNdEx])
			copy(dAtA[i:], m.FuncNames[iNdEx])
			i = encodeVarintCloudapi(dAtA, i, uint64(len(m.FuncNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Script) > 0 {
		i -= len(m.Script)
		copy(dAtA[i:], m.Script)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Script)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FuncArgsSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncArgsSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuncArgsSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FuncArgsSpec_Arg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncArgsSpec_Arg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuncArgsSpec_Arg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SemanticType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.SemanticType))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VisSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VisSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VisSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VegaSpec) > 0 {
		i -= len(m.VegaSpec)
		copy(dAtA[i:], m.VegaSpec)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VegaSpec)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtractVisFuncsInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractVisFuncsInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractVisFuncsInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FnArgsMap) > 0 {
		for k := range m.FnArgsMap {
			v := m.FnArgsMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VisSpecMap) > 0 {
		for k := range m.VisSpecMap {
			v := m.VisSpecMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DocStringMap) > 0 {
		for k := range m.DocStringMap {
			v := m.DocStringMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudapi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if m.CursorPos != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.CursorPos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Input) > 0 {
		i -= len(m.Input)
		copy(dAtA[i:], m.Input)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Input)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TabSuggestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabSuggestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TabSuggestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Suggestions) > 0 {
		for iNdEx := len(m.Suggestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Suggestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExecutableAfterSelect {
		i--
		if m.ExecutableAfterSelect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TabIndex != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.TabIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteSuggestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteSuggestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteSuggestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TabSuggestions) > 0 {
		for iNdEx := len(m.TabSuggestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TabSuggestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsExecutable {
		i--
		if m.IsExecutable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FormattedInput) > 0 {
		i -= len(m.FormattedInput)
		copy(dAtA[i:], m.FormattedInput)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.FormattedInput)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloudapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloudapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LoginRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *LoginReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovCloudapi(uint64(m.ExpiresAt))
	}
	return n
}

func (m *GetImageCredentialsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetImageCredentialsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creds)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *ArtifactSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.Artifact) > 0 {
		for _, e := range m.Artifact {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.CommitHash)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.VersionStr)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.AvailableArtifacts) > 0 {
		l = 0
		for _, e := range m.AvailableArtifacts {
			l += sovCloudapi(uint64(e))
		}
		n += 1 + sovCloudapi(uint64(l)) + l
	}
	l = len(m.Changelog)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetArtifactListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ArtifactName)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ArtifactType != 0 {
		n += 1 + sovCloudapi(uint64(m.ArtifactType))
	}
	if m.Limit != 0 {
		n += 1 + sovCloudapi(uint64(m.Limit))
	}
	return n
}

func (m *GetDownloadLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ArtifactName)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.VersionStr)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ArtifactType != 0 {
		n += 1 + sovCloudapi(uint64(m.ArtifactType))
	}
	return n
}

func (m *GetDownloadLinkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.SHA256)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ValidUntil != nil {
		l = m.ValidUntil.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *CreateClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != nil {
		l = m.ClusterID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *VizierConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassthroughEnabled {
		n += 2
	}
	return n
}

func (m *VizierConfigUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassthroughEnabled != nil {
		l = m.PassthroughEnabled.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *ClusterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCloudapi(uint64(m.Status))
	}
	if m.LastHeartbeatNs != 0 {
		n += 1 + sovCloudapi(uint64(m.LastHeartbeatNs))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *GetClusterConnectionInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterConnectionInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateClusterVizierConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ConfigUpdate != nil {
		l = m.ConfigUpdate.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateClusterVizierConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExtractVisFuncsInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.FuncNames) > 0 {
		for _, s := range m.FuncNames {
			l = len(s)
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *FuncArgsSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *FuncArgsSpec_Arg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovCloudapi(uint64(m.DataType))
	}
	if m.SemanticType != 0 {
		n += 1 + sovCloudapi(uint64(m.SemanticType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *VisSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VegaSpec)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *ExtractVisFuncsInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DocStringMap) > 0 {
		for k, v := range m.DocStringMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudapi(uint64(len(k))) + 1 + len(v) + sovCloudapi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudapi(uint64(mapEntrySize))
		}
	}
	if len(m.VisSpecMap) > 0 {
		for k, v := range m.VisSpecMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCloudapi(uint64(mapEntrySize))
		}
	}
	if len(m.FnArgsMap) > 0 {
		for k, v := range m.FnArgsMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCloudapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AutocompleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.CursorPos != 0 {
		n += 1 + sovCloudapi(uint64(m.CursorPos))
	}
	if m.Action != 0 {
		n += 1 + sovCloudapi(uint64(m.Action))
	}
	return n
}

func (m *TabSuggestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabIndex != 0 {
		n += 1 + sovCloudapi(uint64(m.TabIndex))
	}
	if m.ExecutableAfterSelect {
		n += 2
	}
	if len(m.Suggestions) > 0 {
		for _, e := range m.Suggestions {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *AutocompleteSuggestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovCloudapi(uint64(m.Kind))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *AutocompleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FormattedInput)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.IsExecutable {
		n += 2
	}
	if len(m.TabSuggestions) > 0 {
		for _, e := range m.TabSuggestions {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func sovCloudapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloudapi(x uint64) (n int) {
	return sovCloudapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LoginRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginRequest{`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginReply{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`ExpiresAt:` + fmt.Sprintf("%v", this.ExpiresAt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetImageCredentialsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetImageCredentialsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetImageCredentialsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetImageCredentialsResponse{`,
		`Creds:` + fmt.Sprintf("%v", this.Creds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArtifactSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArtifact := "[]*Artifact{"
	for _, f := range this.Artifact {
		repeatedStringForArtifact += strings.Replace(f.String(), "Artifact", "Artifact", 1) + ","
	}
	repeatedStringForArtifact += "}"
	s := strings.Join([]string{`&ArtifactSet{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Artifact:` + repeatedStringForArtifact + `,`,
		`}`,
	}, "")
	return s
}
func (this *Artifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Artifact{`,
		`Timestamp:` + strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`CommitHash:` + fmt.Sprintf("%v", this.CommitHash) + `,`,
		`VersionStr:` + fmt.Sprintf("%v", this.VersionStr) + `,`,
		`AvailableArtifacts:` + fmt.Sprintf("%v", this.AvailableArtifacts) + `,`,
		`Changelog:` + fmt.Sprintf("%v", this.Changelog) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetArtifactListRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetArtifactListRequest{`,
		`ArtifactName:` + fmt.Sprintf("%v", this.ArtifactName) + `,`,
		`ArtifactType:` + fmt.Sprintf("%v", this.ArtifactType) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetDownloadLinkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetDownloadLinkRequest{`,
		`ArtifactName:` + fmt.Sprintf("%v", this.ArtifactName) + `,`,
		`VersionStr:` + fmt.Sprintf("%v", this.VersionStr) + `,`,
		`ArtifactType:` + fmt.Sprintf("%v", this.ArtifactType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetDownloadLinkResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetDownloadLinkResponse{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`SHA256:` + fmt.Sprintf("%v", this.SHA256) + `,`,
		`ValidUntil:` + strings.Replace(fmt.Sprintf("%v", this.ValidUntil), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateClusterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateClusterRequest{`,
		`}`,
	}, "")
	return s
}
func (this *CreateClusterResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateClusterResponse{`,
		`ClusterID:` + strings.Replace(fmt.Sprintf("%v", this.ClusterID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VizierConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VizierConfig{`,
		`PassthroughEnabled:` + fmt.Sprintf("%v", this.PassthroughEnabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VizierConfigUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VizierConfigUpdate{`,
		`PassthroughEnabled:` + strings.Replace(fmt.Sprintf("%v", this.PassthroughEnabled), "BoolValue", "types.BoolValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterInfoRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClusterInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClusterInfo{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastHeartbeatNs:` + fmt.Sprintf("%v", this.LastHeartbeatNs) + `,`,
		`Config:` + strings.Replace(this.Config.String(), "VizierConfig", "VizierConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForClusters := "[]*ClusterInfo{"
	for _, f := range this.Clusters {
		repeatedStringForClusters += strings.Replace(f.String(), "ClusterInfo", "ClusterInfo", 1) + ","
	}
	repeatedStringForClusters += "}"
	s := strings.Join([]string{`&GetClusterInfoResponse{`,
		`Clusters:` + repeatedStringForClusters + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterConnectionInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterConnectionInfoRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterConnectionInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterConnectionInfoResponse{`,
		`IPAddress:` + fmt.Sprintf("%v", this.IPAddress) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateClusterVizierConfigRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateClusterVizierConfigRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`ConfigUpdate:` + strings.Replace(this.ConfigUpdate.String(), "VizierConfigUpdate", "VizierConfigUpdate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateClusterVizierConfigResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateClusterVizierConfigResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ExtractVisFuncsInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExtractVisFuncsInfoRequest{`,
		`Script:` + fmt.Sprintf("%v", this.Script) + `,`,
		`FuncNames:` + fmt.Sprintf("%v", this.FuncNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FuncArgsSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArgs := "[]*FuncArgsSpec_Arg{"
	for _, f := range this.Args {
		repeatedStringForArgs += strings.Replace(fmt.Sprintf("%v", f), "FuncArgsSpec_Arg", "FuncArgsSpec_Arg", 1) + ","
	}
	repeatedStringForArgs += "}"
	s := strings.Join([]string{`&FuncArgsSpec{`,
		`Args:` + repeatedStringForArgs + `,`,
		`}`,
	}, "")
	return s
}
func (this *FuncArgsSpec_Arg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FuncArgsSpec_Arg{`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`SemanticType:` + fmt.Sprintf("%v", this.SemanticType) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DefaultValue:` + fmt.Sprintf("%v", this.DefaultValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VisSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VisSpec{`,
		`VegaSpec:` + fmt.Sprintf("%v", this.VegaSpec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExtractVisFuncsInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForDocStringMap := make([]string, 0, len(this.DocStringMap))
	for k, _ := range this.DocStringMap {
		keysForDocStringMap = append(keysForDocStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDocStringMap)
	mapStringForDocStringMap := "map[string]string{"
	for _, k := range keysForDocStringMap {
		mapStringForDocStringMap += fmt.Sprintf("%v: %v,", k, this.DocStringMap[k])
	}
	mapStringForDocStringMap += "}"
	keysForVisSpecMap := make([]string, 0, len(this.VisSpecMap))
	for k, _ := range this.VisSpecMap {
		keysForVisSpecMap = append(keysForVisSpecMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVisSpecMap)
	mapStringForVisSpecMap := "map[string]*VisSpec{"
	for _, k := range keysForVisSpecMap {
		mapStringForVisSpecMap += fmt.Sprintf("%v: %v,", k, this.VisSpecMap[k])
	}
	mapStringForVisSpecMap += "}"
	keysForFnArgsMap := make([]string, 0, len(this.FnArgsMap))
	for k, _ := range this.FnArgsMap {
		keysForFnArgsMap = append(keysForFnArgsMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFnArgsMap)
	mapStringForFnArgsMap := "map[string]*FuncArgsSpec{"
	for _, k := range keysForFnArgsMap {
		mapStringForFnArgsMap += fmt.Sprintf("%v: %v,", k, this.FnArgsMap[k])
	}
	mapStringForFnArgsMap += "}"
	s := strings.Join([]string{`&ExtractVisFuncsInfoResponse{`,
		`DocStringMap:` + mapStringForDocStringMap + `,`,
		`VisSpecMap:` + mapStringForVisSpecMap + `,`,
		`FnArgsMap:` + mapStringForFnArgsMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutocompleteRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`CursorPos:` + fmt.Sprintf("%v", this.CursorPos) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TabSuggestion) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSuggestions := "[]*AutocompleteSuggestion{"
	for _, f := range this.Suggestions {
		repeatedStringForSuggestions += strings.Replace(f.String(), "AutocompleteSuggestion", "AutocompleteSuggestion", 1) + ","
	}
	repeatedStringForSuggestions += "}"
	s := strings.Join([]string{`&TabSuggestion{`,
		`TabIndex:` + fmt.Sprintf("%v", this.TabIndex) + `,`,
		`ExecutableAfterSelect:` + fmt.Sprintf("%v", this.ExecutableAfterSelect) + `,`,
		`Suggestions:` + repeatedStringForSuggestions + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteSuggestion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutocompleteSuggestion{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTabSuggestions := "[]*TabSuggestion{"
	for _, f := range this.TabSuggestions {
		repeatedStringForTabSuggestions += strings.Replace(f.String(), "TabSuggestion", "TabSuggestion", 1) + ","
	}
	repeatedStringForTabSuggestions += "}"
	s := strings.Join([]string{`&AutocompleteResponse{`,
		`FormattedInput:` + fmt.Sprintf("%v", this.FormattedInput) + `,`,
		`IsExecutable:` + fmt.Sprintf("%v", this.IsExecutable) + `,`,
		`TabSuggestions:` + repeatedStringForTabSuggestions + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCloudapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LoginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageCredentialsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageCredentialsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageCredentialsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageCredentialsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageCredentialsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageCredentialsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifact = append(m.Artifact, &Artifact{})
			if err := m.Artifact[len(m.Artifact)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v ArtifactType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ArtifactType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AvailableArtifacts = append(m.AvailableArtifacts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCloudapi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCloudapi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AvailableArtifacts) == 0 {
					m.AvailableArtifacts = make([]ArtifactType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ArtifactType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ArtifactType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AvailableArtifacts = append(m.AvailableArtifacts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableArtifacts", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changelog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changelog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetArtifactListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetArtifactListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetArtifactListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArtifactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactType", wireType)
			}
			m.ArtifactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactType |= ArtifactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDownloadLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDownloadLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDownloadLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArtifactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactType", wireType)
			}
			m.ArtifactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactType |= ArtifactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDownloadLinkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDownloadLinkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDownloadLinkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHA256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SHA256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidUntil == nil {
				m.ValidUntil = &types.Timestamp{}
			}
			if err := m.ValidUntil.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterID == nil {
				m.ClusterID = &proto1.UUID{}
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VizierConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VizierConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VizierConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassthroughEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassthroughEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VizierConfigUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VizierConfigUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VizierConfigUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassthroughEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassthroughEnabled == nil {
				m.PassthroughEnabled = &types.BoolValue{}
			}
			if err := m.PassthroughEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ClusterStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeatNs", wireType)
			}
			m.LastHeartbeatNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeatNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &VizierConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &ClusterInfo{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConnectionInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConnectionInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConnectionInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConnectionInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConnectionInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConnectionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateClusterVizierConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigUpdate == nil {
				m.ConfigUpdate = &VizierConfigUpdate{}
			}
			if err := m.ConfigUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateClusterVizierConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractVisFuncsInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractVisFuncsInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractVisFuncsInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncNames = append(m.FuncNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncArgsSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuncArgsSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuncArgsSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &FuncArgsSpec_Arg{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncArgsSpec_Arg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticType", wireType)
			}
			m.SemanticType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SemanticType |= SemanticType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VisSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VisSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VisSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VegaSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VegaSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractVisFuncsInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractVisFuncsInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractVisFuncsInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocStringMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocStringMap == nil {
				m.DocStringMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudapi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DocStringMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisSpecMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VisSpecMap == nil {
				m.VisSpecMap = make(map[string]*VisSpec)
			}
			var mapkey string
			var mapvalue *VisSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VisSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VisSpecMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FnArgsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FnArgsMap == nil {
				m.FnArgsMap = make(map[string]*FuncArgsSpec)
			}
			var mapkey string
			var mapvalue *FuncArgsSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FuncArgsSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FnArgsMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorPos", wireType)
			}
			m.CursorPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CursorPos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= AutocompleteActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabSuggestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabSuggestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabSuggestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabIndex", wireType)
			}
			m.TabIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutableAfterSelect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecutableAfterSelect = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suggestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suggestions = append(m.Suggestions, &AutocompleteSuggestion{})
			if err := m.Suggestions[len(m.Suggestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteSuggestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteSuggestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteSuggestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= AutocompleteEntityKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormattedInput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormattedInput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExecutable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExecutable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabSuggestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TabSuggestions = append(m.TabSuggestions, &TabSuggestion{})
			if err := m.TabSuggestions[len(m.TabSuggestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloudapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloudapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloudapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloudapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloudapi = fmt.Errorf("proto: unexpected end of group")
)
