// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/cloud/cloudapipb/cloudapi.proto

package cloudapipb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	proto1 "pixielabs.ai/pixielabs/src/common/uuid/proto"
	vispb "pixielabs.ai/pixielabs/src/shared/vispb"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ArtifactType int32

const (
	AT_UNKNOWN                   ArtifactType = 0
	AT_LINUX_AMD64               ArtifactType = 1
	AT_DARWIN_AMD64              ArtifactType = 2
	AT_CONTAINER_SET_YAMLS       ArtifactType = 50
	AT_CONTAINER_SET_LINUX_AMD64 ArtifactType = 100
)

var ArtifactType_name = map[int32]string{
	0:   "AT_UNKNOWN",
	1:   "AT_LINUX_AMD64",
	2:   "AT_DARWIN_AMD64",
	50:  "AT_CONTAINER_SET_YAMLS",
	100: "AT_CONTAINER_SET_LINUX_AMD64",
}

var ArtifactType_value = map[string]int32{
	"AT_UNKNOWN":                   0,
	"AT_LINUX_AMD64":               1,
	"AT_DARWIN_AMD64":              2,
	"AT_CONTAINER_SET_YAMLS":       50,
	"AT_CONTAINER_SET_LINUX_AMD64": 100,
}

func (ArtifactType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{0}
}

type ClusterStatus int32

const (
	CS_UNKNOWN       ClusterStatus = 0
	CS_HEALTHY       ClusterStatus = 1
	CS_UNHEALTHY     ClusterStatus = 2
	CS_DISCONNECTED  ClusterStatus = 3
	CS_UPDATING      ClusterStatus = 4
	CS_CONNECTED     ClusterStatus = 5
	CS_UPDATE_FAILED ClusterStatus = 6
)

var ClusterStatus_name = map[int32]string{
	0: "CS_UNKNOWN",
	1: "CS_HEALTHY",
	2: "CS_UNHEALTHY",
	3: "CS_DISCONNECTED",
	4: "CS_UPDATING",
	5: "CS_CONNECTED",
	6: "CS_UPDATE_FAILED",
}

var ClusterStatus_value = map[string]int32{
	"CS_UNKNOWN":       0,
	"CS_HEALTHY":       1,
	"CS_UNHEALTHY":     2,
	"CS_DISCONNECTED":  3,
	"CS_UPDATING":      4,
	"CS_CONNECTED":     5,
	"CS_UPDATE_FAILED": 6,
}

func (ClusterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{1}
}

type AutocompleteActionType int32

const (
	AAT_UNKNOWN AutocompleteActionType = 0
	AAT_EDIT    AutocompleteActionType = 1
	AAT_SELECT  AutocompleteActionType = 2
)

var AutocompleteActionType_name = map[int32]string{
	0: "AAT_UNKNOWN",
	1: "AAT_EDIT",
	2: "AAT_SELECT",
}

var AutocompleteActionType_value = map[string]int32{
	"AAT_UNKNOWN": 0,
	"AAT_EDIT":    1,
	"AAT_SELECT":  2,
}

func (AutocompleteActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{2}
}

type AutocompleteEntityKind int32

const (
	AEK_UNKNOWN   AutocompleteEntityKind = 0
	AEK_POD       AutocompleteEntityKind = 1
	AEK_SVC       AutocompleteEntityKind = 2
	AEK_SCRIPT    AutocompleteEntityKind = 3
	AEK_NAMESPACE AutocompleteEntityKind = 4
)

var AutocompleteEntityKind_name = map[int32]string{
	0: "AEK_UNKNOWN",
	1: "AEK_POD",
	2: "AEK_SVC",
	3: "AEK_SCRIPT",
	4: "AEK_NAMESPACE",
}

var AutocompleteEntityKind_value = map[string]int32{
	"AEK_UNKNOWN":   0,
	"AEK_POD":       1,
	"AEK_SVC":       2,
	"AEK_SCRIPT":    3,
	"AEK_NAMESPACE": 4,
}

func (AutocompleteEntityKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{3}
}

type LoginRequest struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *LoginRequest) Reset()      { *m = LoginRequest{} }
func (*LoginRequest) ProtoMessage() {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{0}
}
func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(m, src)
}
func (m *LoginRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

type LoginReply struct {
	Token     string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	ExpiresAt int64  `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (m *LoginReply) Reset()      { *m = LoginReply{} }
func (*LoginReply) ProtoMessage() {}
func (*LoginReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{1}
}
func (m *LoginReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReply.Merge(m, src)
}
func (m *LoginReply) XXX_Size() int {
	return m.Size()
}
func (m *LoginReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReply.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReply proto.InternalMessageInfo

func (m *LoginReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginReply) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

type GetImageCredentialsRequest struct {
}

func (m *GetImageCredentialsRequest) Reset()      { *m = GetImageCredentialsRequest{} }
func (*GetImageCredentialsRequest) ProtoMessage() {}
func (*GetImageCredentialsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{2}
}
func (m *GetImageCredentialsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageCredentialsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageCredentialsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageCredentialsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageCredentialsRequest.Merge(m, src)
}
func (m *GetImageCredentialsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImageCredentialsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageCredentialsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageCredentialsRequest proto.InternalMessageInfo

type GetImageCredentialsResponse struct {
	Creds string `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *GetImageCredentialsResponse) Reset()      { *m = GetImageCredentialsResponse{} }
func (*GetImageCredentialsResponse) ProtoMessage() {}
func (*GetImageCredentialsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{3}
}
func (m *GetImageCredentialsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageCredentialsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageCredentialsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageCredentialsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageCredentialsResponse.Merge(m, src)
}
func (m *GetImageCredentialsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetImageCredentialsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageCredentialsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageCredentialsResponse proto.InternalMessageInfo

func (m *GetImageCredentialsResponse) GetCreds() string {
	if m != nil {
		return m.Creds
	}
	return ""
}

type ArtifactSet struct {
	Name     string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Artifact []*Artifact `protobuf:"bytes,2,rep,name=artifact,proto3" json:"artifact,omitempty"`
}

func (m *ArtifactSet) Reset()      { *m = ArtifactSet{} }
func (*ArtifactSet) ProtoMessage() {}
func (*ArtifactSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{4}
}
func (m *ArtifactSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactSet.Merge(m, src)
}
func (m *ArtifactSet) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactSet.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactSet proto.InternalMessageInfo

func (m *ArtifactSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArtifactSet) GetArtifact() []*Artifact {
	if m != nil {
		return m.Artifact
	}
	return nil
}

type Artifact struct {
	Timestamp          *types.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	CommitHash         string           `protobuf:"bytes,2,opt,name=commit_hash,json=commitHash,proto3" json:"commit_hash,omitempty"`
	VersionStr         string           `protobuf:"bytes,3,opt,name=version_str,json=versionStr,proto3" json:"version_str,omitempty"`
	AvailableArtifacts []ArtifactType   `protobuf:"varint,4,rep,packed,name=available_artifacts,json=availableArtifacts,proto3,enum=pl.cloudapi.ArtifactType" json:"available_artifacts,omitempty"`
	Changelog          string           `protobuf:"bytes,5,opt,name=changelog,proto3" json:"changelog,omitempty"`
}

func (m *Artifact) Reset()      { *m = Artifact{} }
func (*Artifact) ProtoMessage() {}
func (*Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{5}
}
func (m *Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Artifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Artifact.Merge(m, src)
}
func (m *Artifact) XXX_Size() int {
	return m.Size()
}
func (m *Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_Artifact proto.InternalMessageInfo

func (m *Artifact) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Artifact) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Artifact) GetVersionStr() string {
	if m != nil {
		return m.VersionStr
	}
	return ""
}

func (m *Artifact) GetAvailableArtifacts() []ArtifactType {
	if m != nil {
		return m.AvailableArtifacts
	}
	return nil
}

func (m *Artifact) GetChangelog() string {
	if m != nil {
		return m.Changelog
	}
	return ""
}

type GetArtifactListRequest struct {
	ArtifactName string       `protobuf:"bytes,1,opt,name=artifact_name,json=artifactName,proto3" json:"artifact_name,omitempty"`
	ArtifactType ArtifactType `protobuf:"varint,2,opt,name=artifact_type,json=artifactType,proto3,enum=pl.cloudapi.ArtifactType" json:"artifact_type,omitempty"`
	Limit        int64        `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetArtifactListRequest) Reset()      { *m = GetArtifactListRequest{} }
func (*GetArtifactListRequest) ProtoMessage() {}
func (*GetArtifactListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{6}
}
func (m *GetArtifactListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetArtifactListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetArtifactListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetArtifactListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetArtifactListRequest.Merge(m, src)
}
func (m *GetArtifactListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetArtifactListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetArtifactListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetArtifactListRequest proto.InternalMessageInfo

func (m *GetArtifactListRequest) GetArtifactName() string {
	if m != nil {
		return m.ArtifactName
	}
	return ""
}

func (m *GetArtifactListRequest) GetArtifactType() ArtifactType {
	if m != nil {
		return m.ArtifactType
	}
	return AT_UNKNOWN
}

func (m *GetArtifactListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetDownloadLinkRequest struct {
	ArtifactName string       `protobuf:"bytes,1,opt,name=artifact_name,json=artifactName,proto3" json:"artifact_name,omitempty"`
	VersionStr   string       `protobuf:"bytes,2,opt,name=version_str,json=versionStr,proto3" json:"version_str,omitempty"`
	ArtifactType ArtifactType `protobuf:"varint,3,opt,name=artifact_type,json=artifactType,proto3,enum=pl.cloudapi.ArtifactType" json:"artifact_type,omitempty"`
}

func (m *GetDownloadLinkRequest) Reset()      { *m = GetDownloadLinkRequest{} }
func (*GetDownloadLinkRequest) ProtoMessage() {}
func (*GetDownloadLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{7}
}
func (m *GetDownloadLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDownloadLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDownloadLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDownloadLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDownloadLinkRequest.Merge(m, src)
}
func (m *GetDownloadLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDownloadLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDownloadLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDownloadLinkRequest proto.InternalMessageInfo

func (m *GetDownloadLinkRequest) GetArtifactName() string {
	if m != nil {
		return m.ArtifactName
	}
	return ""
}

func (m *GetDownloadLinkRequest) GetVersionStr() string {
	if m != nil {
		return m.VersionStr
	}
	return ""
}

func (m *GetDownloadLinkRequest) GetArtifactType() ArtifactType {
	if m != nil {
		return m.ArtifactType
	}
	return AT_UNKNOWN
}

type GetDownloadLinkResponse struct {
	Url        string           `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	SHA256     string           `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	ValidUntil *types.Timestamp `protobuf:"bytes,3,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
}

func (m *GetDownloadLinkResponse) Reset()      { *m = GetDownloadLinkResponse{} }
func (*GetDownloadLinkResponse) ProtoMessage() {}
func (*GetDownloadLinkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{8}
}
func (m *GetDownloadLinkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDownloadLinkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDownloadLinkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDownloadLinkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDownloadLinkResponse.Merge(m, src)
}
func (m *GetDownloadLinkResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDownloadLinkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDownloadLinkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDownloadLinkResponse proto.InternalMessageInfo

func (m *GetDownloadLinkResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *GetDownloadLinkResponse) GetSHA256() string {
	if m != nil {
		return m.SHA256
	}
	return ""
}

func (m *GetDownloadLinkResponse) GetValidUntil() *types.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

type CreateClusterRequest struct {
}

func (m *CreateClusterRequest) Reset()      { *m = CreateClusterRequest{} }
func (*CreateClusterRequest) ProtoMessage() {}
func (*CreateClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{9}
}
func (m *CreateClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterRequest.Merge(m, src)
}
func (m *CreateClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterRequest proto.InternalMessageInfo

type CreateClusterResponse struct {
	ClusterID *proto1.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *CreateClusterResponse) Reset()      { *m = CreateClusterResponse{} }
func (*CreateClusterResponse) ProtoMessage() {}
func (*CreateClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{10}
}
func (m *CreateClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterResponse.Merge(m, src)
}
func (m *CreateClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterResponse proto.InternalMessageInfo

func (m *CreateClusterResponse) GetClusterID() *proto1.UUID {
	if m != nil {
		return m.ClusterID
	}
	return nil
}

type UpdateOrInstallClusterRequest struct {
	ClusterID *proto1.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Version   string       `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *UpdateOrInstallClusterRequest) Reset()      { *m = UpdateOrInstallClusterRequest{} }
func (*UpdateOrInstallClusterRequest) ProtoMessage() {}
func (*UpdateOrInstallClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{11}
}
func (m *UpdateOrInstallClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOrInstallClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOrInstallClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOrInstallClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOrInstallClusterRequest.Merge(m, src)
}
func (m *UpdateOrInstallClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOrInstallClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOrInstallClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOrInstallClusterRequest proto.InternalMessageInfo

func (m *UpdateOrInstallClusterRequest) GetClusterID() *proto1.UUID {
	if m != nil {
		return m.ClusterID
	}
	return nil
}

func (m *UpdateOrInstallClusterRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type UpdateOrInstallClusterResponse struct {
	UpdateStarted bool `protobuf:"varint,1,opt,name=update_started,json=updateStarted,proto3" json:"update_started,omitempty"`
}

func (m *UpdateOrInstallClusterResponse) Reset()      { *m = UpdateOrInstallClusterResponse{} }
func (*UpdateOrInstallClusterResponse) ProtoMessage() {}
func (*UpdateOrInstallClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{12}
}
func (m *UpdateOrInstallClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOrInstallClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOrInstallClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOrInstallClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOrInstallClusterResponse.Merge(m, src)
}
func (m *UpdateOrInstallClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOrInstallClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOrInstallClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOrInstallClusterResponse proto.InternalMessageInfo

func (m *UpdateOrInstallClusterResponse) GetUpdateStarted() bool {
	if m != nil {
		return m.UpdateStarted
	}
	return false
}

type VizierConfig struct {
	PassthroughEnabled bool `protobuf:"varint,1,opt,name=passthrough_enabled,json=passthroughEnabled,proto3" json:"passthrough_enabled,omitempty"`
}

func (m *VizierConfig) Reset()      { *m = VizierConfig{} }
func (*VizierConfig) ProtoMessage() {}
func (*VizierConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{13}
}
func (m *VizierConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VizierConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VizierConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VizierConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VizierConfig.Merge(m, src)
}
func (m *VizierConfig) XXX_Size() int {
	return m.Size()
}
func (m *VizierConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VizierConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VizierConfig proto.InternalMessageInfo

func (m *VizierConfig) GetPassthroughEnabled() bool {
	if m != nil {
		return m.PassthroughEnabled
	}
	return false
}

type VizierConfigUpdate struct {
	PassthroughEnabled *types.BoolValue `protobuf:"bytes,1,opt,name=passthrough_enabled,json=passthroughEnabled,proto3" json:"passthrough_enabled,omitempty"`
}

func (m *VizierConfigUpdate) Reset()      { *m = VizierConfigUpdate{} }
func (*VizierConfigUpdate) ProtoMessage() {}
func (*VizierConfigUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{14}
}
func (m *VizierConfigUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VizierConfigUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VizierConfigUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VizierConfigUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VizierConfigUpdate.Merge(m, src)
}
func (m *VizierConfigUpdate) XXX_Size() int {
	return m.Size()
}
func (m *VizierConfigUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_VizierConfigUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_VizierConfigUpdate proto.InternalMessageInfo

func (m *VizierConfigUpdate) GetPassthroughEnabled() *types.BoolValue {
	if m != nil {
		return m.PassthroughEnabled
	}
	return nil
}

type GetClusterInfoRequest struct {
	ID *proto1.UUID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetClusterInfoRequest) Reset()      { *m = GetClusterInfoRequest{} }
func (*GetClusterInfoRequest) ProtoMessage() {}
func (*GetClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{15}
}
func (m *GetClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoRequest.Merge(m, src)
}
func (m *GetClusterInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoRequest proto.InternalMessageInfo

func (m *GetClusterInfoRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

type ClusterInfo struct {
	ID              *proto1.UUID  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Status          ClusterStatus `protobuf:"varint,2,opt,name=status,proto3,enum=pl.cloudapi.ClusterStatus" json:"status,omitempty"`
	LastHeartbeatNs int64         `protobuf:"varint,3,opt,name=lastHeartbeatNs,proto3" json:"lastHeartbeatNs,omitempty"`
	Config          *VizierConfig `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	ClusterUID      string        `protobuf:"bytes,5,opt,name=cluster_uid,json=clusterUid,proto3" json:"cluster_uid,omitempty"`
	ClusterName     string        `protobuf:"bytes,6,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	ClusterVersion  string        `protobuf:"bytes,7,opt,name=cluster_version,json=clusterVersion,proto3" json:"cluster_version,omitempty"`
	VizierVersion   string        `protobuf:"bytes,8,opt,name=vizier_version,json=vizierVersion,proto3" json:"vizier_version,omitempty"`
}

func (m *ClusterInfo) Reset()      { *m = ClusterInfo{} }
func (*ClusterInfo) ProtoMessage() {}
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{16}
}
func (m *ClusterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo.Merge(m, src)
}
func (m *ClusterInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo proto.InternalMessageInfo

func (m *ClusterInfo) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ClusterInfo) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return CS_UNKNOWN
}

func (m *ClusterInfo) GetLastHeartbeatNs() int64 {
	if m != nil {
		return m.LastHeartbeatNs
	}
	return 0
}

func (m *ClusterInfo) GetConfig() *VizierConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ClusterInfo) GetClusterUID() string {
	if m != nil {
		return m.ClusterUID
	}
	return ""
}

func (m *ClusterInfo) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *ClusterInfo) GetClusterVersion() string {
	if m != nil {
		return m.ClusterVersion
	}
	return ""
}

func (m *ClusterInfo) GetVizierVersion() string {
	if m != nil {
		return m.VizierVersion
	}
	return ""
}

type GetClusterInfoResponse struct {
	Clusters []*ClusterInfo `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
}

func (m *GetClusterInfoResponse) Reset()      { *m = GetClusterInfoResponse{} }
func (*GetClusterInfoResponse) ProtoMessage() {}
func (*GetClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{17}
}
func (m *GetClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoResponse.Merge(m, src)
}
func (m *GetClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoResponse proto.InternalMessageInfo

func (m *GetClusterInfoResponse) GetClusters() []*ClusterInfo {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type GetClusterConnectionInfoRequest struct {
	ID *proto1.UUID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetClusterConnectionInfoRequest) Reset()      { *m = GetClusterConnectionInfoRequest{} }
func (*GetClusterConnectionInfoRequest) ProtoMessage() {}
func (*GetClusterConnectionInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{18}
}
func (m *GetClusterConnectionInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConnectionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConnectionInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConnectionInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConnectionInfoRequest.Merge(m, src)
}
func (m *GetClusterConnectionInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConnectionInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConnectionInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConnectionInfoRequest proto.InternalMessageInfo

func (m *GetClusterConnectionInfoRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

type GetClusterConnectionInfoResponse struct {
	IPAddress string `protobuf:"bytes,1,opt,name=ipAddress,proto3" json:"ipAddress,omitempty"`
	Token     string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *GetClusterConnectionInfoResponse) Reset()      { *m = GetClusterConnectionInfoResponse{} }
func (*GetClusterConnectionInfoResponse) ProtoMessage() {}
func (*GetClusterConnectionInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{19}
}
func (m *GetClusterConnectionInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterConnectionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterConnectionInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterConnectionInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterConnectionInfoResponse.Merge(m, src)
}
func (m *GetClusterConnectionInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterConnectionInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterConnectionInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterConnectionInfoResponse proto.InternalMessageInfo

func (m *GetClusterConnectionInfoResponse) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *GetClusterConnectionInfoResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UpdateClusterVizierConfigRequest struct {
	ID           *proto1.UUID        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ConfigUpdate *VizierConfigUpdate `protobuf:"bytes,2,opt,name=config_update,json=configUpdate,proto3" json:"config_update,omitempty"`
}

func (m *UpdateClusterVizierConfigRequest) Reset()      { *m = UpdateClusterVizierConfigRequest{} }
func (*UpdateClusterVizierConfigRequest) ProtoMessage() {}
func (*UpdateClusterVizierConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{20}
}
func (m *UpdateClusterVizierConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClusterVizierConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClusterVizierConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClusterVizierConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClusterVizierConfigRequest.Merge(m, src)
}
func (m *UpdateClusterVizierConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClusterVizierConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClusterVizierConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClusterVizierConfigRequest proto.InternalMessageInfo

func (m *UpdateClusterVizierConfigRequest) GetID() *proto1.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *UpdateClusterVizierConfigRequest) GetConfigUpdate() *VizierConfigUpdate {
	if m != nil {
		return m.ConfigUpdate
	}
	return nil
}

type UpdateClusterVizierConfigResponse struct {
}

func (m *UpdateClusterVizierConfigResponse) Reset()      { *m = UpdateClusterVizierConfigResponse{} }
func (*UpdateClusterVizierConfigResponse) ProtoMessage() {}
func (*UpdateClusterVizierConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{21}
}
func (m *UpdateClusterVizierConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClusterVizierConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClusterVizierConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClusterVizierConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClusterVizierConfigResponse.Merge(m, src)
}
func (m *UpdateClusterVizierConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClusterVizierConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClusterVizierConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClusterVizierConfigResponse proto.InternalMessageInfo

type GetLiveViewsReq struct {
}

func (m *GetLiveViewsReq) Reset()      { *m = GetLiveViewsReq{} }
func (*GetLiveViewsReq) ProtoMessage() {}
func (*GetLiveViewsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{22}
}
func (m *GetLiveViewsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLiveViewsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLiveViewsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLiveViewsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLiveViewsReq.Merge(m, src)
}
func (m *GetLiveViewsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetLiveViewsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLiveViewsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetLiveViewsReq proto.InternalMessageInfo

type LiveViewMetadata struct {
	ID   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *LiveViewMetadata) Reset()      { *m = LiveViewMetadata{} }
func (*LiveViewMetadata) ProtoMessage() {}
func (*LiveViewMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{23}
}
func (m *LiveViewMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiveViewMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiveViewMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiveViewMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiveViewMetadata.Merge(m, src)
}
func (m *LiveViewMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LiveViewMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LiveViewMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LiveViewMetadata proto.InternalMessageInfo

func (m *LiveViewMetadata) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *LiveViewMetadata) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *LiveViewMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetLiveViewsResp struct {
	LiveViews []*LiveViewMetadata `protobuf:"bytes,1,rep,name=live_views,json=liveViews,proto3" json:"live_views,omitempty"`
}

func (m *GetLiveViewsResp) Reset()      { *m = GetLiveViewsResp{} }
func (*GetLiveViewsResp) ProtoMessage() {}
func (*GetLiveViewsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{24}
}
func (m *GetLiveViewsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLiveViewsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLiveViewsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLiveViewsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLiveViewsResp.Merge(m, src)
}
func (m *GetLiveViewsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetLiveViewsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLiveViewsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetLiveViewsResp proto.InternalMessageInfo

func (m *GetLiveViewsResp) GetLiveViews() []*LiveViewMetadata {
	if m != nil {
		return m.LiveViews
	}
	return nil
}

type GetLiveViewContentsReq struct {
	LiveViewID string `protobuf:"bytes,1,opt,name=live_view_id,json=liveViewId,proto3" json:"live_view_id,omitempty"`
}

func (m *GetLiveViewContentsReq) Reset()      { *m = GetLiveViewContentsReq{} }
func (*GetLiveViewContentsReq) ProtoMessage() {}
func (*GetLiveViewContentsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{25}
}
func (m *GetLiveViewContentsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLiveViewContentsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLiveViewContentsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLiveViewContentsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLiveViewContentsReq.Merge(m, src)
}
func (m *GetLiveViewContentsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetLiveViewContentsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLiveViewContentsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetLiveViewContentsReq proto.InternalMessageInfo

func (m *GetLiveViewContentsReq) GetLiveViewID() string {
	if m != nil {
		return m.LiveViewID
	}
	return ""
}

type GetLiveViewContentsResp struct {
	Metadata    *LiveViewMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	PxlContents string            `protobuf:"bytes,2,opt,name=pxl_contents,json=pxlContents,proto3" json:"pxl_contents,omitempty"`
	Vis         *vispb.Vis        `protobuf:"bytes,3,opt,name=vis,proto3" json:"vis,omitempty"`
}

func (m *GetLiveViewContentsResp) Reset()      { *m = GetLiveViewContentsResp{} }
func (*GetLiveViewContentsResp) ProtoMessage() {}
func (*GetLiveViewContentsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{26}
}
func (m *GetLiveViewContentsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLiveViewContentsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLiveViewContentsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLiveViewContentsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLiveViewContentsResp.Merge(m, src)
}
func (m *GetLiveViewContentsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetLiveViewContentsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLiveViewContentsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetLiveViewContentsResp proto.InternalMessageInfo

func (m *GetLiveViewContentsResp) GetMetadata() *LiveViewMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *GetLiveViewContentsResp) GetPxlContents() string {
	if m != nil {
		return m.PxlContents
	}
	return ""
}

func (m *GetLiveViewContentsResp) GetVis() *vispb.Vis {
	if m != nil {
		return m.Vis
	}
	return nil
}

type GetScriptsReq struct {
}

func (m *GetScriptsReq) Reset()      { *m = GetScriptsReq{} }
func (*GetScriptsReq) ProtoMessage() {}
func (*GetScriptsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{27}
}
func (m *GetScriptsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScriptsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScriptsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScriptsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScriptsReq.Merge(m, src)
}
func (m *GetScriptsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetScriptsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScriptsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetScriptsReq proto.InternalMessageInfo

type ScriptMetadata struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc        string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	HasLiveView bool   `protobuf:"varint,4,opt,name=has_live_view,json=hasLiveView,proto3" json:"has_live_view,omitempty"`
}

func (m *ScriptMetadata) Reset()      { *m = ScriptMetadata{} }
func (*ScriptMetadata) ProtoMessage() {}
func (*ScriptMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{28}
}
func (m *ScriptMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScriptMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScriptMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScriptMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScriptMetadata.Merge(m, src)
}
func (m *ScriptMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ScriptMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ScriptMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ScriptMetadata proto.InternalMessageInfo

func (m *ScriptMetadata) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ScriptMetadata) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ScriptMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScriptMetadata) GetHasLiveView() bool {
	if m != nil {
		return m.HasLiveView
	}
	return false
}

type GetScriptsResp struct {
	Scripts []*ScriptMetadata `protobuf:"bytes,1,rep,name=scripts,proto3" json:"scripts,omitempty"`
}

func (m *GetScriptsResp) Reset()      { *m = GetScriptsResp{} }
func (*GetScriptsResp) ProtoMessage() {}
func (*GetScriptsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{29}
}
func (m *GetScriptsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScriptsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScriptsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScriptsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScriptsResp.Merge(m, src)
}
func (m *GetScriptsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetScriptsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScriptsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetScriptsResp proto.InternalMessageInfo

func (m *GetScriptsResp) GetScripts() []*ScriptMetadata {
	if m != nil {
		return m.Scripts
	}
	return nil
}

type GetScriptContentsReq struct {
	ScriptID string `protobuf:"bytes,1,opt,name=script_id,json=scriptId,proto3" json:"script_id,omitempty"`
}

func (m *GetScriptContentsReq) Reset()      { *m = GetScriptContentsReq{} }
func (*GetScriptContentsReq) ProtoMessage() {}
func (*GetScriptContentsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{30}
}
func (m *GetScriptContentsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScriptContentsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScriptContentsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScriptContentsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScriptContentsReq.Merge(m, src)
}
func (m *GetScriptContentsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetScriptContentsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScriptContentsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetScriptContentsReq proto.InternalMessageInfo

func (m *GetScriptContentsReq) GetScriptID() string {
	if m != nil {
		return m.ScriptID
	}
	return ""
}

type GetScriptContentsResp struct {
	Metadata *ScriptMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Contents string          `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *GetScriptContentsResp) Reset()      { *m = GetScriptContentsResp{} }
func (*GetScriptContentsResp) ProtoMessage() {}
func (*GetScriptContentsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{31}
}
func (m *GetScriptContentsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScriptContentsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScriptContentsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScriptContentsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScriptContentsResp.Merge(m, src)
}
func (m *GetScriptContentsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetScriptContentsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScriptContentsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetScriptContentsResp proto.InternalMessageInfo

func (m *GetScriptContentsResp) GetMetadata() *ScriptMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *GetScriptContentsResp) GetContents() string {
	if m != nil {
		return m.Contents
	}
	return ""
}

type AutocompleteRequest struct {
	Input     string                 `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	CursorPos int64                  `protobuf:"varint,2,opt,name=cursor_pos,json=cursorPos,proto3" json:"cursor_pos,omitempty"`
	Action    AutocompleteActionType `protobuf:"varint,3,opt,name=action,proto3,enum=pl.cloudapi.AutocompleteActionType" json:"action,omitempty"`
}

func (m *AutocompleteRequest) Reset()      { *m = AutocompleteRequest{} }
func (*AutocompleteRequest) ProtoMessage() {}
func (*AutocompleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{32}
}
func (m *AutocompleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteRequest.Merge(m, src)
}
func (m *AutocompleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteRequest proto.InternalMessageInfo

func (m *AutocompleteRequest) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *AutocompleteRequest) GetCursorPos() int64 {
	if m != nil {
		return m.CursorPos
	}
	return 0
}

func (m *AutocompleteRequest) GetAction() AutocompleteActionType {
	if m != nil {
		return m.Action
	}
	return AAT_UNKNOWN
}

type TabSuggestion struct {
	TabIndex              int64                     `protobuf:"varint,1,opt,name=tab_index,json=tabIndex,proto3" json:"tab_index,omitempty"`
	ExecutableAfterSelect bool                      `protobuf:"varint,2,opt,name=executable_after_select,json=executableAfterSelect,proto3" json:"executable_after_select,omitempty"`
	Suggestions           []*AutocompleteSuggestion `protobuf:"bytes,3,rep,name=suggestions,proto3" json:"suggestions,omitempty"`
}

func (m *TabSuggestion) Reset()      { *m = TabSuggestion{} }
func (*TabSuggestion) ProtoMessage() {}
func (*TabSuggestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{33}
}
func (m *TabSuggestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TabSuggestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TabSuggestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TabSuggestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TabSuggestion.Merge(m, src)
}
func (m *TabSuggestion) XXX_Size() int {
	return m.Size()
}
func (m *TabSuggestion) XXX_DiscardUnknown() {
	xxx_messageInfo_TabSuggestion.DiscardUnknown(m)
}

var xxx_messageInfo_TabSuggestion proto.InternalMessageInfo

func (m *TabSuggestion) GetTabIndex() int64 {
	if m != nil {
		return m.TabIndex
	}
	return 0
}

func (m *TabSuggestion) GetExecutableAfterSelect() bool {
	if m != nil {
		return m.ExecutableAfterSelect
	}
	return false
}

func (m *TabSuggestion) GetSuggestions() []*AutocompleteSuggestion {
	if m != nil {
		return m.Suggestions
	}
	return nil
}

type AutocompleteSuggestion struct {
	Kind           AutocompleteEntityKind `protobuf:"varint,1,opt,name=kind,proto3,enum=pl.cloudapi.AutocompleteEntityKind" json:"kind,omitempty"`
	Name           string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description    string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	MatchedIndexes []int64                `protobuf:"varint,4,rep,packed,name=matched_indexes,json=matchedIndexes,proto3" json:"matched_indexes,omitempty"`
}

func (m *AutocompleteSuggestion) Reset()      { *m = AutocompleteSuggestion{} }
func (*AutocompleteSuggestion) ProtoMessage() {}
func (*AutocompleteSuggestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{34}
}
func (m *AutocompleteSuggestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteSuggestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteSuggestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteSuggestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteSuggestion.Merge(m, src)
}
func (m *AutocompleteSuggestion) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteSuggestion) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteSuggestion.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteSuggestion proto.InternalMessageInfo

func (m *AutocompleteSuggestion) GetKind() AutocompleteEntityKind {
	if m != nil {
		return m.Kind
	}
	return AEK_UNKNOWN
}

func (m *AutocompleteSuggestion) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AutocompleteSuggestion) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AutocompleteSuggestion) GetMatchedIndexes() []int64 {
	if m != nil {
		return m.MatchedIndexes
	}
	return nil
}

type AutocompleteResponse struct {
	FormattedInput string           `protobuf:"bytes,1,opt,name=formatted_input,json=formattedInput,proto3" json:"formatted_input,omitempty"`
	IsExecutable   bool             `protobuf:"varint,2,opt,name=is_executable,json=isExecutable,proto3" json:"is_executable,omitempty"`
	TabSuggestions []*TabSuggestion `protobuf:"bytes,3,rep,name=tabSuggestions,proto3" json:"tabSuggestions,omitempty"`
}

func (m *AutocompleteResponse) Reset()      { *m = AutocompleteResponse{} }
func (*AutocompleteResponse) ProtoMessage() {}
func (*AutocompleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c309ce7890afda1a, []int{35}
}
func (m *AutocompleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteResponse.Merge(m, src)
}
func (m *AutocompleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteResponse proto.InternalMessageInfo

func (m *AutocompleteResponse) GetFormattedInput() string {
	if m != nil {
		return m.FormattedInput
	}
	return ""
}

func (m *AutocompleteResponse) GetIsExecutable() bool {
	if m != nil {
		return m.IsExecutable
	}
	return false
}

func (m *AutocompleteResponse) GetTabSuggestions() []*TabSuggestion {
	if m != nil {
		return m.TabSuggestions
	}
	return nil
}

func init() {
	proto.RegisterEnum("pl.cloudapi.ArtifactType", ArtifactType_name, ArtifactType_value)
	proto.RegisterEnum("pl.cloudapi.ClusterStatus", ClusterStatus_name, ClusterStatus_value)
	proto.RegisterEnum("pl.cloudapi.AutocompleteActionType", AutocompleteActionType_name, AutocompleteActionType_value)
	proto.RegisterEnum("pl.cloudapi.AutocompleteEntityKind", AutocompleteEntityKind_name, AutocompleteEntityKind_value)
	proto.RegisterType((*LoginRequest)(nil), "pl.cloudapi.LoginRequest")
	proto.RegisterType((*LoginReply)(nil), "pl.cloudapi.LoginReply")
	proto.RegisterType((*GetImageCredentialsRequest)(nil), "pl.cloudapi.GetImageCredentialsRequest")
	proto.RegisterType((*GetImageCredentialsResponse)(nil), "pl.cloudapi.GetImageCredentialsResponse")
	proto.RegisterType((*ArtifactSet)(nil), "pl.cloudapi.ArtifactSet")
	proto.RegisterType((*Artifact)(nil), "pl.cloudapi.Artifact")
	proto.RegisterType((*GetArtifactListRequest)(nil), "pl.cloudapi.GetArtifactListRequest")
	proto.RegisterType((*GetDownloadLinkRequest)(nil), "pl.cloudapi.GetDownloadLinkRequest")
	proto.RegisterType((*GetDownloadLinkResponse)(nil), "pl.cloudapi.GetDownloadLinkResponse")
	proto.RegisterType((*CreateClusterRequest)(nil), "pl.cloudapi.CreateClusterRequest")
	proto.RegisterType((*CreateClusterResponse)(nil), "pl.cloudapi.CreateClusterResponse")
	proto.RegisterType((*UpdateOrInstallClusterRequest)(nil), "pl.cloudapi.UpdateOrInstallClusterRequest")
	proto.RegisterType((*UpdateOrInstallClusterResponse)(nil), "pl.cloudapi.UpdateOrInstallClusterResponse")
	proto.RegisterType((*VizierConfig)(nil), "pl.cloudapi.VizierConfig")
	proto.RegisterType((*VizierConfigUpdate)(nil), "pl.cloudapi.VizierConfigUpdate")
	proto.RegisterType((*GetClusterInfoRequest)(nil), "pl.cloudapi.GetClusterInfoRequest")
	proto.RegisterType((*ClusterInfo)(nil), "pl.cloudapi.ClusterInfo")
	proto.RegisterType((*GetClusterInfoResponse)(nil), "pl.cloudapi.GetClusterInfoResponse")
	proto.RegisterType((*GetClusterConnectionInfoRequest)(nil), "pl.cloudapi.GetClusterConnectionInfoRequest")
	proto.RegisterType((*GetClusterConnectionInfoResponse)(nil), "pl.cloudapi.GetClusterConnectionInfoResponse")
	proto.RegisterType((*UpdateClusterVizierConfigRequest)(nil), "pl.cloudapi.UpdateClusterVizierConfigRequest")
	proto.RegisterType((*UpdateClusterVizierConfigResponse)(nil), "pl.cloudapi.UpdateClusterVizierConfigResponse")
	proto.RegisterType((*GetLiveViewsReq)(nil), "pl.cloudapi.GetLiveViewsReq")
	proto.RegisterType((*LiveViewMetadata)(nil), "pl.cloudapi.LiveViewMetadata")
	proto.RegisterType((*GetLiveViewsResp)(nil), "pl.cloudapi.GetLiveViewsResp")
	proto.RegisterType((*GetLiveViewContentsReq)(nil), "pl.cloudapi.GetLiveViewContentsReq")
	proto.RegisterType((*GetLiveViewContentsResp)(nil), "pl.cloudapi.GetLiveViewContentsResp")
	proto.RegisterType((*GetScriptsReq)(nil), "pl.cloudapi.GetScriptsReq")
	proto.RegisterType((*ScriptMetadata)(nil), "pl.cloudapi.ScriptMetadata")
	proto.RegisterType((*GetScriptsResp)(nil), "pl.cloudapi.GetScriptsResp")
	proto.RegisterType((*GetScriptContentsReq)(nil), "pl.cloudapi.GetScriptContentsReq")
	proto.RegisterType((*GetScriptContentsResp)(nil), "pl.cloudapi.GetScriptContentsResp")
	proto.RegisterType((*AutocompleteRequest)(nil), "pl.cloudapi.AutocompleteRequest")
	proto.RegisterType((*TabSuggestion)(nil), "pl.cloudapi.TabSuggestion")
	proto.RegisterType((*AutocompleteSuggestion)(nil), "pl.cloudapi.AutocompleteSuggestion")
	proto.RegisterType((*AutocompleteResponse)(nil), "pl.cloudapi.AutocompleteResponse")
}

func init() {
	proto.RegisterFile("src/cloud/cloudapipb/cloudapi.proto", fileDescriptor_c309ce7890afda1a)
}

var fileDescriptor_c309ce7890afda1a = []byte{
	// 2260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0xd7, 0x48, 0x8e, 0x23, 0x3d, 0x49, 0xb6, 0xd2, 0x71, 0xbc, 0x5a, 0x25, 0x91, 0x9d, 0x31,
	0x54, 0x4c, 0x96, 0x95, 0x59, 0xed, 0x6e, 0x16, 0x6a, 0xf9, 0x37, 0x96, 0x84, 0xa3, 0xc4, 0x51,
	0x5c, 0x23, 0xd9, 0xbb, 0x0b, 0x14, 0x53, 0x2d, 0xa9, 0x2d, 0x0d, 0x19, 0xcd, 0x0c, 0xd3, 0x2d,
	0xc7, 0xde, 0xe2, 0xc0, 0x05, 0xb8, 0x50, 0x05, 0x14, 0x17, 0x4e, 0x9c, 0xb7, 0x8a, 0x0b, 0x47,
	0xbe, 0x00, 0x55, 0x1c, 0x73, 0xdc, 0x53, 0x8a, 0x28, 0x45, 0x15, 0x55, 0x5c, 0xf2, 0x11, 0xa8,
	0xee, 0xe9, 0x19, 0xcd, 0xc8, 0x92, 0x93, 0x00, 0x17, 0x95, 0xde, 0xeb, 0xdf, 0x7b, 0xef, 0x37,
	0xef, 0xbd, 0x9e, 0x7e, 0x3d, 0xb0, 0x45, 0xbd, 0xde, 0x4e, 0xcf, 0x72, 0xc6, 0x7d, 0xff, 0x17,
	0xbb, 0xa6, 0xdb, 0x0d, 0xff, 0x56, 0x5c, 0xcf, 0x61, 0x0e, 0xca, 0xba, 0x56, 0x25, 0x50, 0x95,
	0xde, 0x1d, 0x98, 0x6c, 0x38, 0xee, 0x56, 0x7a, 0xce, 0x68, 0x67, 0xe0, 0x0c, 0x9c, 0x1d, 0x81,
	0xe9, 0x8e, 0x8f, 0x85, 0x24, 0x04, 0xf1, 0xcf, 0xb7, 0x2d, 0x6d, 0x0c, 0x1c, 0x67, 0x60, 0x91,
	0x29, 0x8a, 0x99, 0x23, 0x42, 0x19, 0x1e, 0xb9, 0x12, 0x50, 0x9e, 0x05, 0x3c, 0xf1, 0xb0, 0xeb,
	0x12, 0x8f, 0xca, 0xf5, 0x4d, 0xc1, 0xd0, 0x19, 0x8d, 0x1c, 0x7b, 0x67, 0x3c, 0x36, 0xfb, 0x3e,
	0x50, 0xfc, 0x95, 0x88, 0x12, 0x47, 0xd0, 0x21, 0xf6, 0x48, 0x7f, 0xe7, 0xc4, 0xa4, 0x6e, 0x97,
	0xff, 0xfa, 0x6b, 0xea, 0x7b, 0x90, 0xdb, 0x77, 0x06, 0xa6, 0xad, 0x93, 0x9f, 0x8d, 0x09, 0x65,
	0xe8, 0x16, 0xe4, 0x70, 0xaf, 0x47, 0x28, 0x35, 0x98, 0xf3, 0x98, 0xd8, 0x45, 0x65, 0x53, 0xd9,
	0xce, 0xe8, 0x59, 0x5f, 0xd7, 0xe1, 0x2a, 0x55, 0x03, 0x90, 0x26, 0xae, 0x75, 0x86, 0xd6, 0xe0,
	0x52, 0x14, 0xe9, 0x0b, 0xe8, 0x26, 0x00, 0x39, 0x75, 0x4d, 0x8f, 0x50, 0x03, 0xb3, 0x62, 0x72,
	0x53, 0xd9, 0x4e, 0xe9, 0x19, 0xa9, 0xd1, 0x98, 0x7a, 0x03, 0x4a, 0x7b, 0x84, 0x35, 0x47, 0x78,
	0x40, 0x6a, 0x1e, 0xe9, 0x13, 0x9b, 0x99, 0xd8, 0xa2, 0x92, 0x83, 0xfa, 0x3e, 0x5c, 0x9f, 0xbb,
	0x4a, 0x5d, 0xc7, 0xa6, 0x84, 0x47, 0xec, 0x79, 0xa4, 0x4f, 0x83, 0x88, 0x42, 0x50, 0x3b, 0x90,
	0xd5, 0x3c, 0x66, 0x1e, 0xe3, 0x1e, 0x6b, 0x13, 0x86, 0x10, 0x2c, 0xd9, 0x78, 0x44, 0x24, 0x46,
	0xfc, 0x47, 0xef, 0x41, 0x1a, 0x4b, 0x48, 0x31, 0xb9, 0x99, 0xda, 0xce, 0x56, 0xaf, 0x55, 0x22,
	0x95, 0xab, 0x04, 0xf6, 0x7a, 0x08, 0x53, 0x5f, 0x2a, 0x90, 0x0e, 0xd4, 0xe8, 0x9b, 0x90, 0x09,
	0x8b, 0x23, 0x1c, 0x67, 0xab, 0xa5, 0x8a, 0x5f, 0x9d, 0x4a, 0x50, 0x9d, 0x4a, 0x27, 0x40, 0xe8,
	0x53, 0x30, 0xda, 0x80, 0x2c, 0xaf, 0x90, 0xc9, 0x8c, 0x21, 0xa6, 0x43, 0x91, 0x8f, 0x8c, 0x0e,
	0xbe, 0xea, 0x1e, 0xa6, 0x43, 0x0e, 0x38, 0x21, 0x1e, 0x35, 0x1d, 0xdb, 0xa0, 0xcc, 0x2b, 0xa6,
	0x7c, 0x80, 0x54, 0xb5, 0x99, 0x87, 0xee, 0xc3, 0x55, 0x7c, 0x82, 0x4d, 0x0b, 0x77, 0x2d, 0x62,
	0x04, 0xf4, 0x68, 0x71, 0x69, 0x33, 0xb5, 0xbd, 0x52, 0x7d, 0x7b, 0xee, 0x63, 0x74, 0xce, 0x5c,
	0xa2, 0xa3, 0xd0, 0x2a, 0x50, 0x53, 0x74, 0x03, 0x32, 0xbd, 0x21, 0xb6, 0x07, 0xc4, 0x72, 0x06,
	0xc5, 0x4b, 0x22, 0xd4, 0x54, 0xa1, 0xfe, 0x41, 0x81, 0xf5, 0x3d, 0xc2, 0x02, 0xf8, 0xbe, 0x49,
	0x59, 0xd0, 0x1c, 0x5b, 0x90, 0x0f, 0x42, 0x1b, 0x91, 0xec, 0xe6, 0x02, 0x65, 0x8b, 0x67, 0xf9,
	0xbb, 0x11, 0x10, 0x3b, 0x73, 0x89, 0x78, 0xda, 0x0b, 0x39, 0x86, 0xf6, 0x5c, 0xe2, 0xe5, 0xb5,
	0xcc, 0x91, 0xc9, 0x44, 0x12, 0x52, 0xba, 0x2f, 0xa8, 0x7f, 0xf2, 0x59, 0xd5, 0x9d, 0x27, 0xb6,
	0xe5, 0xe0, 0xfe, 0xbe, 0x69, 0x3f, 0x7e, 0x23, 0x56, 0x33, 0x09, 0x4e, 0x9e, 0x4b, 0xf0, 0x39,
	0xda, 0xa9, 0x37, 0xa2, 0xad, 0xfe, 0x46, 0x81, 0xb7, 0xce, 0x11, 0x94, 0x1d, 0x5b, 0x80, 0xd4,
	0xd8, 0xb3, 0x24, 0x2f, 0xfe, 0x17, 0xa9, 0xb0, 0x4c, 0x87, 0xb8, 0xfa, 0xe1, 0x5d, 0x9f, 0xc9,
	0x2e, 0x4c, 0x9e, 0x6d, 0x2c, 0xb7, 0xef, 0x69, 0xd5, 0x0f, 0xef, 0xea, 0x72, 0x05, 0x7d, 0x0c,
	0xd9, 0x13, 0x6c, 0x99, 0x7d, 0x63, 0x6c, 0x33, 0xd3, 0x12, 0x7c, 0x2e, 0x6e, 0x38, 0x10, 0xf0,
	0x43, 0x8e, 0x56, 0xd7, 0x61, 0xad, 0xe6, 0x11, 0xcc, 0x48, 0xcd, 0x1a, 0x53, 0x46, 0xbc, 0x60,
	0x6f, 0x1d, 0xc1, 0xb5, 0x19, 0xbd, 0xe4, 0xf8, 0x1d, 0x80, 0x9e, 0xaf, 0x32, 0xcc, 0xbe, 0xec,
	0xee, 0x55, 0xfe, 0xf0, 0xfc, 0x45, 0xe2, 0x76, 0x2b, 0x87, 0x87, 0xcd, 0xfa, 0x6e, 0x7e, 0xf2,
	0x6c, 0x23, 0x23, 0x2d, 0x9b, 0x75, 0x3d, 0x23, 0x2d, 0x9a, 0x7d, 0xf5, 0x14, 0x6e, 0x1e, 0xba,
	0x7d, 0xcc, 0xc8, 0x23, 0xaf, 0x69, 0x53, 0x86, 0x2d, 0x2b, 0x1e, 0xf8, 0x7f, 0xf4, 0x8f, 0x8a,
	0x70, 0x59, 0x16, 0x4b, 0xd6, 0x2e, 0x10, 0xd5, 0x3d, 0x28, 0x2f, 0x8a, 0x2c, 0x1f, 0xed, 0xab,
	0xb0, 0x32, 0x16, 0x08, 0x83, 0x32, 0xec, 0x31, 0xe2, 0x87, 0x4f, 0xeb, 0x79, 0x5f, 0xdb, 0xf6,
	0x95, 0xea, 0xf7, 0x20, 0x77, 0x64, 0x7e, 0x6e, 0x12, 0xaf, 0xe6, 0xd8, 0xc7, 0xe6, 0x00, 0xed,
	0xc0, 0x55, 0x17, 0x53, 0xca, 0x86, 0x9e, 0x33, 0x1e, 0x0c, 0x0d, 0x62, 0xf3, 0x5d, 0x14, 0xd8,
	0xa2, 0xc8, 0x52, 0xc3, 0x5f, 0x51, 0x31, 0xa0, 0xa8, 0x03, 0x9f, 0x15, 0x7a, 0xb0, 0xd8, 0xcd,
	0xbc, 0x72, 0xee, 0x3a, 0x8e, 0x75, 0x84, 0xad, 0x31, 0x99, 0x1b, 0xe2, 0xfb, 0x70, 0x6d, 0x8f,
	0xb0, 0x20, 0x43, 0xf6, 0xb1, 0x13, 0xa4, 0xf7, 0x36, 0x24, 0x17, 0xa7, 0x75, 0x79, 0xf2, 0x6c,
	0x23, 0xd9, 0xac, 0xeb, 0x49, 0xb3, 0xaf, 0xfe, 0x3b, 0x09, 0xd9, 0x88, 0xfd, 0x6b, 0x1b, 0xa2,
	0x2a, 0x2c, 0x53, 0x86, 0xd9, 0x98, 0xca, 0x0d, 0x5d, 0x8a, 0xed, 0x0c, 0xe9, 0xb2, 0x2d, 0x10,
	0xba, 0x44, 0xa2, 0x6d, 0x58, 0xb5, 0x30, 0x65, 0xf7, 0x08, 0xf6, 0x58, 0x97, 0x60, 0xd6, 0xa2,
	0x72, 0x57, 0xcf, 0xaa, 0xd1, 0x7b, 0xb0, 0xdc, 0x13, 0x59, 0x2b, 0x2e, 0x09, 0x2a, 0xf1, 0x7d,
	0x17, 0x4d, 0xab, 0x2e, 0x81, 0x68, 0x07, 0xb2, 0x41, 0x47, 0x8d, 0xcd, 0xbe, 0xff, 0x22, 0xdb,
	0x5d, 0x99, 0x3c, 0xdb, 0x00, 0x49, 0xe6, 0xb0, 0x59, 0xd7, 0x83, 0xa6, 0x3b, 0x34, 0xfb, 0xfc,
	0x6c, 0x0b, 0x0c, 0xc4, 0x7b, 0x62, 0xd9, 0x3f, 0xdb, 0xa4, 0x4e, 0xbc, 0x26, 0x6e, 0xc3, 0x6a,
	0x00, 0x09, 0xda, 0xed, 0xb2, 0x40, 0xad, 0x48, 0xf5, 0x91, 0xaf, 0xe5, 0x3d, 0x75, 0x22, 0x48,
	0x85, 0xb8, 0xb4, 0xc0, 0xe5, 0x7d, 0xad, 0x84, 0xa9, 0x2d, 0xf1, 0xd6, 0x8a, 0xd5, 0x4b, 0x36,
	0xe5, 0x07, 0x90, 0x96, 0x2e, 0xf9, 0x41, 0xc6, 0x0f, 0xa3, 0xe2, 0xbc, 0x84, 0x0a, 0x9b, 0x10,
	0xa9, 0xde, 0x87, 0x8d, 0xa9, 0xbf, 0x9a, 0x63, 0xdb, 0xa4, 0xc7, 0x4c, 0xc7, 0xfe, 0xaf, 0x3a,
	0x81, 0xc0, 0xe6, 0x62, 0x5f, 0x92, 0xe5, 0x3b, 0x90, 0x31, 0x5d, 0xad, 0xdf, 0xf7, 0x08, 0x95,
	0xe7, 0xad, 0xbf, 0x47, 0x9b, 0x07, 0x52, 0xa9, 0x4f, 0xd7, 0xa7, 0xa3, 0x40, 0x32, 0x32, 0x0a,
	0xa8, 0xbf, 0x57, 0x60, 0xd3, 0xdf, 0x0a, 0x32, 0x54, 0xac, 0x98, 0x6f, 0x48, 0x1a, 0xd5, 0x21,
	0xef, 0x97, 0xdf, 0xf0, 0x37, 0xaf, 0x88, 0x95, 0xad, 0x6e, 0x2c, 0x6c, 0x17, 0x3f, 0xb4, 0x9e,
	0xeb, 0x45, 0x24, 0x75, 0x0b, 0x6e, 0x5d, 0x40, 0xc9, 0x7f, 0x76, 0xf5, 0x0a, 0xac, 0xee, 0x11,
	0xb6, 0x6f, 0x9e, 0x90, 0x23, 0x93, 0x3c, 0xe1, 0xd3, 0x89, 0xaa, 0x43, 0x21, 0x90, 0x1f, 0x12,
	0x86, 0xfb, 0x98, 0x61, 0xb4, 0x1e, 0x52, 0xcf, 0xc4, 0x98, 0x22, 0x58, 0xea, 0x13, 0xda, 0x93,
	0xc9, 0x10, 0xff, 0xc3, 0xa9, 0x24, 0x35, 0x9d, 0x4a, 0xd4, 0x03, 0x28, 0xc4, 0xc3, 0x50, 0x17,
	0x7d, 0x1b, 0xc0, 0x32, 0x4f, 0x88, 0x71, 0xc2, 0x35, 0xb2, 0x3d, 0x6e, 0xc6, 0x1e, 0x71, 0x96,
	0x86, 0x9e, 0xb1, 0x02, 0x0f, 0xea, 0x7d, 0xd1, 0x74, 0x01, 0xa2, 0xe6, 0xd8, 0x8c, 0xd8, 0x8c,
	0xf3, 0x47, 0xdf, 0x80, 0x5c, 0xe8, 0xd7, 0x08, 0x59, 0x8b, 0x3d, 0x13, 0xc0, 0xf9, 0x9e, 0x09,
	0x5c, 0x35, 0xfb, 0xea, 0x1f, 0xfd, 0x63, 0xed, 0xbc, 0x33, 0xea, 0xa2, 0x6f, 0x41, 0x7a, 0x24,
	0xc3, 0xcb, 0xd2, 0xbd, 0x82, 0x63, 0x08, 0xe7, 0x5b, 0xd1, 0x3d, 0xb5, 0x8c, 0x9e, 0x74, 0x27,
	0x93, 0x94, 0x75, 0x4f, 0xad, 0x20, 0x02, 0xda, 0x80, 0xd4, 0x89, 0x49, 0xe5, 0xb1, 0x97, 0xe7,
	0x8e, 0xc5, 0xec, 0x5a, 0x39, 0x32, 0xa9, 0xce, 0x57, 0xd4, 0x55, 0xc8, 0xef, 0x11, 0xd6, 0xee,
	0x79, 0xa6, 0x2b, 0x9e, 0x4e, 0x65, 0xb0, 0xe2, 0x4b, 0xff, 0xaf, 0xda, 0x20, 0x15, 0xf2, 0x43,
	0x4c, 0x8d, 0x30, 0x67, 0xe2, 0xe5, 0x94, 0xd6, 0xb3, 0x43, 0x4c, 0x83, 0x87, 0x53, 0xf7, 0x60,
	0x25, 0x4a, 0x83, 0xba, 0xe8, 0x43, 0xb8, 0x4c, 0x7d, 0x51, 0x96, 0xee, 0x7a, 0x2c, 0x2d, 0x71,
	0x8e, 0x7a, 0x80, 0x55, 0x35, 0x58, 0x0b, 0x1d, 0x45, 0x8b, 0xf6, 0x35, 0xc8, 0xf8, 0x90, 0x69,
	0xc5, 0x72, 0x93, 0x67, 0x1b, 0x69, 0x1f, 0xd9, 0xac, 0xeb, 0x69, 0x7f, 0xb9, 0xd9, 0x57, 0x2d,
	0x71, 0x3c, 0xcc, 0xba, 0xa0, 0x2e, 0xfa, 0xe8, 0x5c, 0xa9, 0x2e, 0xe4, 0x34, 0x2d, 0x54, 0x09,
	0xd2, 0x33, 0x45, 0x0a, 0x65, 0xf5, 0xd7, 0x0a, 0x5c, 0xd5, 0xc6, 0xcc, 0xe9, 0x39, 0x23, 0xd7,
	0x22, 0x8c, 0x04, 0x9b, 0x79, 0x0d, 0x2e, 0x99, 0xb6, 0x3b, 0x66, 0xc1, 0x80, 0x2e, 0x04, 0x7e,
	0x25, 0xe8, 0x8d, 0x3d, 0xea, 0x78, 0x86, 0xeb, 0xd0, 0xe0, 0x4a, 0xe0, 0x6b, 0x0e, 0x1c, 0x8a,
	0x3e, 0x86, 0x65, 0x2c, 0xde, 0x3f, 0x72, 0xf0, 0xda, 0x8a, 0x0f, 0x5e, 0x91, 0x30, 0x9a, 0x80,
	0x89, 0x11, 0x4c, 0x9a, 0xa8, 0x7f, 0x56, 0x20, 0xdf, 0xc1, 0xdd, 0xf6, 0x78, 0x30, 0x20, 0x94,
	0x6b, 0xd0, 0x75, 0xc8, 0x30, 0xdc, 0x35, 0x4c, 0xbb, 0x4f, 0x4e, 0x05, 0x8f, 0x94, 0x9e, 0x66,
	0xb8, 0xdb, 0xe4, 0x32, 0xba, 0x0b, 0x6f, 0x91, 0x53, 0xd2, 0x1b, 0x33, 0x7f, 0x9a, 0x3e, 0xe6,
	0xaf, 0x7b, 0x4a, 0x2c, 0xd2, 0xf3, 0xaf, 0x2a, 0x69, 0xfd, 0xda, 0x74, 0x59, 0xe3, 0xab, 0x6d,
	0xb1, 0x88, 0x1a, 0x90, 0xa5, 0x61, 0x08, 0xde, 0x9a, 0xbc, 0xb8, 0x8b, 0x89, 0x4e, 0xe9, 0xe8,
	0x51, 0x3b, 0xf5, 0x2f, 0x0a, 0xac, 0xcf, 0xc7, 0xa1, 0x8f, 0x60, 0xe9, 0xb1, 0x69, 0xfb, 0x65,
	0xbe, 0x28, 0x07, 0x0d, 0x9b, 0x99, 0xec, 0xec, 0x81, 0x69, 0xf7, 0x75, 0x61, 0x10, 0x76, 0x6f,
	0x32, 0xd2, 0xbd, 0x9b, 0x90, 0xe5, 0x9d, 0xcd, 0x2b, 0x1b, 0xe4, 0x35, 0xa3, 0x47, 0x55, 0xfc,
	0xb8, 0x1b, 0x61, 0xd6, 0x1b, 0x92, 0xbe, 0x9f, 0x29, 0xe2, 0xdf, 0x28, 0x52, 0xfa, 0x8a, 0x54,
	0x37, 0x7d, 0xad, 0xfa, 0x85, 0x02, 0x6b, 0xf1, 0x52, 0xcb, 0x03, 0xe2, 0x36, 0xac, 0x1e, 0x3b,
	0xde, 0x08, 0x33, 0x26, 0x7c, 0x4c, 0xab, 0xbe, 0x12, 0xaa, 0x9b, 0xa2, 0xfc, 0x5b, 0x90, 0x37,
	0xa9, 0x31, 0xcd, 0xab, 0xcc, 0x74, 0xce, 0xa4, 0x8d, 0x50, 0x87, 0x76, 0x61, 0x85, 0x45, 0xcb,
	0x18, 0xe4, 0x38, 0x3e, 0x6b, 0xc4, 0x2a, 0xad, 0xcf, 0x58, 0xdc, 0xf9, 0xa5, 0x02, 0xb9, 0xe8,
	0x9c, 0x8e, 0x56, 0x00, 0xb4, 0x8e, 0x71, 0xd8, 0x7a, 0xd0, 0x7a, 0xf4, 0x49, 0xab, 0x90, 0x40,
	0x08, 0x56, 0xb4, 0x8e, 0xb1, 0xdf, 0x6c, 0x1d, 0x7e, 0x6a, 0x68, 0x0f, 0xeb, 0x77, 0x3f, 0x28,
	0x28, 0xe8, 0x2a, 0xac, 0x6a, 0x1d, 0xa3, 0xae, 0xe9, 0x9f, 0x34, 0x5b, 0x52, 0x99, 0x44, 0x25,
	0x58, 0xd7, 0x3a, 0x46, 0xed, 0x51, 0xab, 0xa3, 0x35, 0x5b, 0x0d, 0xdd, 0x68, 0x37, 0x3a, 0xc6,
	0x67, 0xda, 0xc3, 0xfd, 0x76, 0xa1, 0x8a, 0x36, 0xe1, 0xc6, 0xb9, 0xb5, 0xa8, 0xcb, 0xfe, 0x9d,
	0xdf, 0x2a, 0x90, 0x8f, 0x4d, 0x45, 0x9c, 0x48, 0xad, 0x1d, 0x21, 0xe2, 0xcb, 0xf7, 0x1a, 0xda,
	0x7e, 0xe7, 0xde, 0x67, 0x05, 0x05, 0x15, 0x20, 0x27, 0xd6, 0x03, 0x4d, 0x92, 0xd3, 0xaa, 0xb5,
	0x8d, 0x7a, 0xb3, 0x5d, 0x7b, 0xd4, 0x6a, 0x35, 0x6a, 0x9d, 0x46, 0xbd, 0x90, 0x42, 0xab, 0x90,
	0xe5, 0xb0, 0x83, 0xba, 0xd6, 0x69, 0xb6, 0xf6, 0x0a, 0x4b, 0xd2, 0x6e, 0x0a, 0xb9, 0x84, 0xd6,
	0xa0, 0x10, 0x40, 0x1a, 0xc6, 0x0f, 0xb4, 0xe6, 0x7e, 0xa3, 0x5e, 0x58, 0xbe, 0xb3, 0x17, 0x6f,
	0xbb, 0xe9, 0x3e, 0xe2, 0x2e, 0xb5, 0x58, 0x8e, 0x72, 0x90, 0xe6, 0x8a, 0x46, 0xbd, 0xd9, 0x29,
	0x28, 0x22, 0x83, 0x5a, 0xc7, 0x68, 0x37, 0xf6, 0x1b, 0xb5, 0x4e, 0x21, 0x79, 0xe7, 0x38, 0xee,
	0x68, 0xda, 0x8c, 0xc2, 0x51, 0xe3, 0x41, 0xc4, 0x51, 0x16, 0x2e, 0x73, 0xc5, 0xc1, 0xa3, 0x7a,
	0x41, 0x09, 0x84, 0xf6, 0x51, 0xad, 0x90, 0x14, 0x4e, 0xb9, 0x50, 0xd3, 0x9b, 0x07, 0x9d, 0x42,
	0x0a, 0x5d, 0x81, 0x3c, 0x97, 0x5b, 0xda, 0xc3, 0x46, 0xfb, 0x40, 0xab, 0x35, 0x0a, 0x4b, 0xd5,
	0x7d, 0xc8, 0x6a, 0x63, 0x36, 0x6c, 0x13, 0xef, 0xc4, 0xec, 0xf1, 0x2b, 0xca, 0x25, 0xf1, 0xe1,
	0x01, 0xc5, 0x87, 0xc3, 0xe8, 0xf7, 0x8b, 0xd2, 0x5b, 0xf3, 0x96, 0x5c, 0xeb, 0x4c, 0x4d, 0x54,
	0x7f, 0xa5, 0x40, 0xd1, 0x3f, 0xe8, 0xc5, 0xa7, 0x05, 0xee, 0xd9, 0xf1, 0xcc, 0xcf, 0xb1, 0xd8,
	0x09, 0x3f, 0x85, 0xab, 0x73, 0xbe, 0x39, 0xa0, 0xdb, 0x31, 0x77, 0x8b, 0xbf, 0x59, 0x94, 0xb6,
	0x5f, 0x0d, 0x94, 0x63, 0x45, 0xa2, 0xfa, 0x37, 0x05, 0x56, 0xc3, 0x0e, 0xf5, 0x70, 0xef, 0x31,
	0xf1, 0x90, 0x2e, 0x86, 0x8d, 0xe8, 0xa5, 0x1b, 0x6d, 0xcd, 0xba, 0x9c, 0x73, 0x25, 0x2f, 0x15,
	0xe7, 0xde, 0x4f, 0xdb, 0x84, 0xa9, 0x09, 0xf4, 0x13, 0xe1, 0x33, 0x7a, 0x23, 0x3d, 0xef, 0x73,
	0xce, 0x85, 0xba, 0xf4, 0x95, 0x8b, 0x41, 0xe1, 0x73, 0xfc, 0x75, 0x09, 0xae, 0xc8, 0xc9, 0x29,
	0x72, 0xa1, 0xf8, 0x14, 0xf2, 0xb1, 0x1b, 0x26, 0xba, 0x15, 0x9f, 0x6b, 0xe7, 0xdc, 0x4a, 0x4b,
	0xea, 0x45, 0x90, 0x20, 0x1e, 0xfa, 0x91, 0x38, 0x69, 0xa3, 0xb1, 0xd4, 0x59, 0xa6, 0xe7, 0x6f,
	0x46, 0xa5, 0xad, 0x0b, 0x31, 0xa1, 0xf3, 0x33, 0x28, 0x2e, 0x9a, 0x86, 0xd1, 0xd7, 0x17, 0xb8,
	0x98, 0x3b, 0x80, 0x97, 0xde, 0x7d, 0x4d, 0x74, 0x18, 0xfa, 0xe7, 0xf0, 0xf6, 0xc2, 0x69, 0x14,
	0xc5, 0xbd, 0xbd, 0x6a, 0x90, 0x2e, 0x55, 0x5e, 0x17, 0x1e, 0x46, 0xa7, 0xb0, 0x3e, 0xff, 0xfe,
	0x8c, 0xee, 0xcc, 0xf1, 0xb5, 0xe0, 0x7a, 0x5f, 0x7a, 0xe7, 0xb5, 0xb0, 0x61, 0xeb, 0xfc, 0x33,
	0x09, 0x19, 0x39, 0x73, 0x0c, 0x3c, 0xf4, 0x10, 0x72, 0xd1, 0x11, 0x18, 0xdd, 0x98, 0xcd, 0x60,
	0x74, 0x08, 0x2f, 0xdd, 0xbc, 0x60, 0x95, 0xba, 0x6a, 0x02, 0x75, 0xc5, 0x5e, 0x9e, 0x1d, 0x59,
	0xcf, 0xf7, 0xfe, 0x9c, 0x09, 0xf9, 0x7c, 0xef, 0xcf, 0x9b, 0x7c, 0xd5, 0x04, 0xda, 0x03, 0x98,
	0x4e, 0x7d, 0xa8, 0x34, 0x6b, 0x35, 0x9d, 0x4a, 0x4b, 0xd7, 0x17, 0xae, 0x09, 0x47, 0x3f, 0x86,
	0x2b, 0xe7, 0x46, 0xb6, 0x99, 0x2d, 0x33, 0x6f, 0x2a, 0x2c, 0xa9, 0xaf, 0x82, 0x70, 0xef, 0x55,
	0x2b, 0x3e, 0xa1, 0x05, 0x6f, 0xd2, 0x43, 0xc8, 0x45, 0xd5, 0x68, 0x73, 0xe1, 0xa0, 0x11, 0xd4,
	0xf7, 0xd6, 0x05, 0x88, 0xa0, 0xaa, 0xbb, 0xd6, 0xd3, 0xe7, 0xe5, 0xc4, 0x97, 0xcf, 0xcb, 0x89,
	0x97, 0xcf, 0xcb, 0xca, 0x2f, 0x26, 0x65, 0xe5, 0x8b, 0x49, 0x59, 0xf9, 0xfb, 0xa4, 0xac, 0x3c,
	0x9d, 0x94, 0x95, 0x7f, 0x4c, 0xca, 0xca, 0xbf, 0x26, 0xe5, 0xc4, 0xcb, 0x49, 0x59, 0xf9, 0xdd,
	0x8b, 0x72, 0xe2, 0xe9, 0x8b, 0x72, 0xe2, 0xcb, 0x17, 0xe5, 0xc4, 0x0f, 0xef, 0xba, 0xe6, 0xa9,
	0x49, 0x2c, 0xdc, 0xa5, 0x15, 0x6c, 0xee, 0x84, 0xc2, 0xce, 0xbc, 0x2f, 0xef, 0x1f, 0x4f, 0xff,
	0x76, 0x97, 0xc5, 0x37, 0x93, 0xf7, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x77, 0x8a, 0x13, 0xc1,
	0xa3, 0x17, 0x00, 0x00,
}

func (x ArtifactType) String() string {
	s, ok := ArtifactType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ClusterStatus) String() string {
	s, ok := ClusterStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AutocompleteActionType) String() string {
	s, ok := AutocompleteActionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AutocompleteEntityKind) String() string {
	s, ok := AutocompleteEntityKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LoginRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginRequest)
	if !ok {
		that2, ok := that.(LoginRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	return true
}
func (this *LoginReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginReply)
	if !ok {
		that2, ok := that.(LoginReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	return true
}
func (this *GetImageCredentialsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetImageCredentialsRequest)
	if !ok {
		that2, ok := that.(GetImageCredentialsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetImageCredentialsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetImageCredentialsResponse)
	if !ok {
		that2, ok := that.(GetImageCredentialsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Creds != that1.Creds {
		return false
	}
	return true
}
func (this *ArtifactSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArtifactSet)
	if !ok {
		that2, ok := that.(ArtifactSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Artifact) != len(that1.Artifact) {
		return false
	}
	for i := range this.Artifact {
		if !this.Artifact[i].Equal(that1.Artifact[i]) {
			return false
		}
	}
	return true
}
func (this *Artifact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Artifact)
	if !ok {
		that2, ok := that.(Artifact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.CommitHash != that1.CommitHash {
		return false
	}
	if this.VersionStr != that1.VersionStr {
		return false
	}
	if len(this.AvailableArtifacts) != len(that1.AvailableArtifacts) {
		return false
	}
	for i := range this.AvailableArtifacts {
		if this.AvailableArtifacts[i] != that1.AvailableArtifacts[i] {
			return false
		}
	}
	if this.Changelog != that1.Changelog {
		return false
	}
	return true
}
func (this *GetArtifactListRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetArtifactListRequest)
	if !ok {
		that2, ok := that.(GetArtifactListRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ArtifactName != that1.ArtifactName {
		return false
	}
	if this.ArtifactType != that1.ArtifactType {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *GetDownloadLinkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetDownloadLinkRequest)
	if !ok {
		that2, ok := that.(GetDownloadLinkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ArtifactName != that1.ArtifactName {
		return false
	}
	if this.VersionStr != that1.VersionStr {
		return false
	}
	if this.ArtifactType != that1.ArtifactType {
		return false
	}
	return true
}
func (this *GetDownloadLinkResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetDownloadLinkResponse)
	if !ok {
		that2, ok := that.(GetDownloadLinkResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.SHA256 != that1.SHA256 {
		return false
	}
	if !this.ValidUntil.Equal(that1.ValidUntil) {
		return false
	}
	return true
}
func (this *CreateClusterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateClusterRequest)
	if !ok {
		that2, ok := that.(CreateClusterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CreateClusterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateClusterResponse)
	if !ok {
		that2, ok := that.(CreateClusterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterID.Equal(that1.ClusterID) {
		return false
	}
	return true
}
func (this *UpdateOrInstallClusterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateOrInstallClusterRequest)
	if !ok {
		that2, ok := that.(UpdateOrInstallClusterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterID.Equal(that1.ClusterID) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *UpdateOrInstallClusterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateOrInstallClusterResponse)
	if !ok {
		that2, ok := that.(UpdateOrInstallClusterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpdateStarted != that1.UpdateStarted {
		return false
	}
	return true
}
func (this *VizierConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VizierConfig)
	if !ok {
		that2, ok := that.(VizierConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PassthroughEnabled != that1.PassthroughEnabled {
		return false
	}
	return true
}
func (this *VizierConfigUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VizierConfigUpdate)
	if !ok {
		that2, ok := that.(VizierConfigUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassthroughEnabled.Equal(that1.PassthroughEnabled) {
		return false
	}
	return true
}
func (this *GetClusterInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterInfoRequest)
	if !ok {
		that2, ok := that.(GetClusterInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *ClusterInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClusterInfo)
	if !ok {
		that2, ok := that.(ClusterInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.LastHeartbeatNs != that1.LastHeartbeatNs {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if this.ClusterUID != that1.ClusterUID {
		return false
	}
	if this.ClusterName != that1.ClusterName {
		return false
	}
	if this.ClusterVersion != that1.ClusterVersion {
		return false
	}
	if this.VizierVersion != that1.VizierVersion {
		return false
	}
	return true
}
func (this *GetClusterInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterInfoResponse)
	if !ok {
		that2, ok := that.(GetClusterInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Clusters) != len(that1.Clusters) {
		return false
	}
	for i := range this.Clusters {
		if !this.Clusters[i].Equal(that1.Clusters[i]) {
			return false
		}
	}
	return true
}
func (this *GetClusterConnectionInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterConnectionInfoRequest)
	if !ok {
		that2, ok := that.(GetClusterConnectionInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *GetClusterConnectionInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetClusterConnectionInfoResponse)
	if !ok {
		that2, ok := that.(GetClusterConnectionInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IPAddress != that1.IPAddress {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *UpdateClusterVizierConfigRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateClusterVizierConfigRequest)
	if !ok {
		that2, ok := that.(UpdateClusterVizierConfigRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.ConfigUpdate.Equal(that1.ConfigUpdate) {
		return false
	}
	return true
}
func (this *UpdateClusterVizierConfigResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateClusterVizierConfigResponse)
	if !ok {
		that2, ok := that.(UpdateClusterVizierConfigResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetLiveViewsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetLiveViewsReq)
	if !ok {
		that2, ok := that.(GetLiveViewsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *LiveViewMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiveViewMetadata)
	if !ok {
		that2, ok := that.(LiveViewMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GetLiveViewsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetLiveViewsResp)
	if !ok {
		that2, ok := that.(GetLiveViewsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LiveViews) != len(that1.LiveViews) {
		return false
	}
	for i := range this.LiveViews {
		if !this.LiveViews[i].Equal(that1.LiveViews[i]) {
			return false
		}
	}
	return true
}
func (this *GetLiveViewContentsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetLiveViewContentsReq)
	if !ok {
		that2, ok := that.(GetLiveViewContentsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LiveViewID != that1.LiveViewID {
		return false
	}
	return true
}
func (this *GetLiveViewContentsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetLiveViewContentsResp)
	if !ok {
		that2, ok := that.(GetLiveViewContentsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.PxlContents != that1.PxlContents {
		return false
	}
	if !this.Vis.Equal(that1.Vis) {
		return false
	}
	return true
}
func (this *GetScriptsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetScriptsReq)
	if !ok {
		that2, ok := that.(GetScriptsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ScriptMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScriptMetadata)
	if !ok {
		that2, ok := that.(ScriptMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.HasLiveView != that1.HasLiveView {
		return false
	}
	return true
}
func (this *GetScriptsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetScriptsResp)
	if !ok {
		that2, ok := that.(GetScriptsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Scripts) != len(that1.Scripts) {
		return false
	}
	for i := range this.Scripts {
		if !this.Scripts[i].Equal(that1.Scripts[i]) {
			return false
		}
	}
	return true
}
func (this *GetScriptContentsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetScriptContentsReq)
	if !ok {
		that2, ok := that.(GetScriptContentsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScriptID != that1.ScriptID {
		return false
	}
	return true
}
func (this *GetScriptContentsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetScriptContentsResp)
	if !ok {
		that2, ok := that.(GetScriptContentsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.Contents != that1.Contents {
		return false
	}
	return true
}
func (this *AutocompleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteRequest)
	if !ok {
		that2, ok := that.(AutocompleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Input != that1.Input {
		return false
	}
	if this.CursorPos != that1.CursorPos {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *TabSuggestion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TabSuggestion)
	if !ok {
		that2, ok := that.(TabSuggestion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TabIndex != that1.TabIndex {
		return false
	}
	if this.ExecutableAfterSelect != that1.ExecutableAfterSelect {
		return false
	}
	if len(this.Suggestions) != len(that1.Suggestions) {
		return false
	}
	for i := range this.Suggestions {
		if !this.Suggestions[i].Equal(that1.Suggestions[i]) {
			return false
		}
	}
	return true
}
func (this *AutocompleteSuggestion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteSuggestion)
	if !ok {
		that2, ok := that.(AutocompleteSuggestion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.MatchedIndexes) != len(that1.MatchedIndexes) {
		return false
	}
	for i := range this.MatchedIndexes {
		if this.MatchedIndexes[i] != that1.MatchedIndexes[i] {
			return false
		}
	}
	return true
}
func (this *AutocompleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutocompleteResponse)
	if !ok {
		that2, ok := that.(AutocompleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FormattedInput != that1.FormattedInput {
		return false
	}
	if this.IsExecutable != that1.IsExecutable {
		return false
	}
	if len(this.TabSuggestions) != len(that1.TabSuggestions) {
		return false
	}
	for i := range this.TabSuggestions {
		if !this.TabSuggestions[i].Equal(that1.TabSuggestions[i]) {
			return false
		}
	}
	return true
}
func (this *LoginRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.LoginRequest{")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.LoginReply{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "ExpiresAt: "+fmt.Sprintf("%#v", this.ExpiresAt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetImageCredentialsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.GetImageCredentialsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetImageCredentialsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetImageCredentialsResponse{")
	s = append(s, "Creds: "+fmt.Sprintf("%#v", this.Creds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArtifactSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.ArtifactSet{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Artifact != nil {
		s = append(s, "Artifact: "+fmt.Sprintf("%#v", this.Artifact)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Artifact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloudapipb.Artifact{")
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	}
	s = append(s, "CommitHash: "+fmt.Sprintf("%#v", this.CommitHash)+",\n")
	s = append(s, "VersionStr: "+fmt.Sprintf("%#v", this.VersionStr)+",\n")
	s = append(s, "AvailableArtifacts: "+fmt.Sprintf("%#v", this.AvailableArtifacts)+",\n")
	s = append(s, "Changelog: "+fmt.Sprintf("%#v", this.Changelog)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetArtifactListRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetArtifactListRequest{")
	s = append(s, "ArtifactName: "+fmt.Sprintf("%#v", this.ArtifactName)+",\n")
	s = append(s, "ArtifactType: "+fmt.Sprintf("%#v", this.ArtifactType)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetDownloadLinkRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetDownloadLinkRequest{")
	s = append(s, "ArtifactName: "+fmt.Sprintf("%#v", this.ArtifactName)+",\n")
	s = append(s, "VersionStr: "+fmt.Sprintf("%#v", this.VersionStr)+",\n")
	s = append(s, "ArtifactType: "+fmt.Sprintf("%#v", this.ArtifactType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetDownloadLinkResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetDownloadLinkResponse{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "SHA256: "+fmt.Sprintf("%#v", this.SHA256)+",\n")
	if this.ValidUntil != nil {
		s = append(s, "ValidUntil: "+fmt.Sprintf("%#v", this.ValidUntil)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateClusterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.CreateClusterRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateClusterResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.CreateClusterResponse{")
	if this.ClusterID != nil {
		s = append(s, "ClusterID: "+fmt.Sprintf("%#v", this.ClusterID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateOrInstallClusterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.UpdateOrInstallClusterRequest{")
	if this.ClusterID != nil {
		s = append(s, "ClusterID: "+fmt.Sprintf("%#v", this.ClusterID)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateOrInstallClusterResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.UpdateOrInstallClusterResponse{")
	s = append(s, "UpdateStarted: "+fmt.Sprintf("%#v", this.UpdateStarted)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VizierConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.VizierConfig{")
	s = append(s, "PassthroughEnabled: "+fmt.Sprintf("%#v", this.PassthroughEnabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VizierConfigUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.VizierConfigUpdate{")
	if this.PassthroughEnabled != nil {
		s = append(s, "PassthroughEnabled: "+fmt.Sprintf("%#v", this.PassthroughEnabled)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterInfoRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClusterInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&cloudapipb.ClusterInfo{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "LastHeartbeatNs: "+fmt.Sprintf("%#v", this.LastHeartbeatNs)+",\n")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "ClusterUID: "+fmt.Sprintf("%#v", this.ClusterUID)+",\n")
	s = append(s, "ClusterName: "+fmt.Sprintf("%#v", this.ClusterName)+",\n")
	s = append(s, "ClusterVersion: "+fmt.Sprintf("%#v", this.ClusterVersion)+",\n")
	s = append(s, "VizierVersion: "+fmt.Sprintf("%#v", this.VizierVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterInfoResponse{")
	if this.Clusters != nil {
		s = append(s, "Clusters: "+fmt.Sprintf("%#v", this.Clusters)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterConnectionInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetClusterConnectionInfoRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetClusterConnectionInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.GetClusterConnectionInfoResponse{")
	s = append(s, "IPAddress: "+fmt.Sprintf("%#v", this.IPAddress)+",\n")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateClusterVizierConfigRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.UpdateClusterVizierConfigRequest{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.ConfigUpdate != nil {
		s = append(s, "ConfigUpdate: "+fmt.Sprintf("%#v", this.ConfigUpdate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateClusterVizierConfigResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.UpdateClusterVizierConfigResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetLiveViewsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.GetLiveViewsReq{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LiveViewMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.LiveViewMetadata{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetLiveViewsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetLiveViewsResp{")
	if this.LiveViews != nil {
		s = append(s, "LiveViews: "+fmt.Sprintf("%#v", this.LiveViews)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetLiveViewContentsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetLiveViewContentsReq{")
	s = append(s, "LiveViewID: "+fmt.Sprintf("%#v", this.LiveViewID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetLiveViewContentsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.GetLiveViewContentsResp{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "PxlContents: "+fmt.Sprintf("%#v", this.PxlContents)+",\n")
	if this.Vis != nil {
		s = append(s, "Vis: "+fmt.Sprintf("%#v", this.Vis)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetScriptsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloudapipb.GetScriptsReq{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScriptMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloudapipb.ScriptMetadata{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "HasLiveView: "+fmt.Sprintf("%#v", this.HasLiveView)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetScriptsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetScriptsResp{")
	if this.Scripts != nil {
		s = append(s, "Scripts: "+fmt.Sprintf("%#v", this.Scripts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetScriptContentsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudapipb.GetScriptContentsReq{")
	s = append(s, "ScriptID: "+fmt.Sprintf("%#v", this.ScriptID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetScriptContentsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudapipb.GetScriptContentsResp{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "Contents: "+fmt.Sprintf("%#v", this.Contents)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.AutocompleteRequest{")
	s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	s = append(s, "CursorPos: "+fmt.Sprintf("%#v", this.CursorPos)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TabSuggestion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.TabSuggestion{")
	s = append(s, "TabIndex: "+fmt.Sprintf("%#v", this.TabIndex)+",\n")
	s = append(s, "ExecutableAfterSelect: "+fmt.Sprintf("%#v", this.ExecutableAfterSelect)+",\n")
	if this.Suggestions != nil {
		s = append(s, "Suggestions: "+fmt.Sprintf("%#v", this.Suggestions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteSuggestion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloudapipb.AutocompleteSuggestion{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "MatchedIndexes: "+fmt.Sprintf("%#v", this.MatchedIndexes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudapipb.AutocompleteResponse{")
	s = append(s, "FormattedInput: "+fmt.Sprintf("%#v", this.FormattedInput)+",\n")
	s = append(s, "IsExecutable: "+fmt.Sprintf("%#v", this.IsExecutable)+",\n")
	if this.TabSuggestions != nil {
		s = append(s, "TabSuggestions: "+fmt.Sprintf("%#v", this.TabSuggestions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloudapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error) {
	out := new(LoginReply)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.AuthService/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginReply, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) Login(ctx context.Context, req *LoginRequest) (*LoginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.AuthService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// VizierImageAuthorizationClient is the client API for VizierImageAuthorization service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VizierImageAuthorizationClient interface {
	GetImageCredentials(ctx context.Context, in *GetImageCredentialsRequest, opts ...grpc.CallOption) (*GetImageCredentialsResponse, error)
}

type vizierImageAuthorizationClient struct {
	cc *grpc.ClientConn
}

func NewVizierImageAuthorizationClient(cc *grpc.ClientConn) VizierImageAuthorizationClient {
	return &vizierImageAuthorizationClient{cc}
}

func (c *vizierImageAuthorizationClient) GetImageCredentials(ctx context.Context, in *GetImageCredentialsRequest, opts ...grpc.CallOption) (*GetImageCredentialsResponse, error) {
	out := new(GetImageCredentialsResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierImageAuthorization/GetImageCredentials", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VizierImageAuthorizationServer is the server API for VizierImageAuthorization service.
type VizierImageAuthorizationServer interface {
	GetImageCredentials(context.Context, *GetImageCredentialsRequest) (*GetImageCredentialsResponse, error)
}

// UnimplementedVizierImageAuthorizationServer can be embedded to have forward compatible implementations.
type UnimplementedVizierImageAuthorizationServer struct {
}

func (*UnimplementedVizierImageAuthorizationServer) GetImageCredentials(ctx context.Context, req *GetImageCredentialsRequest) (*GetImageCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageCredentials not implemented")
}

func RegisterVizierImageAuthorizationServer(s *grpc.Server, srv VizierImageAuthorizationServer) {
	s.RegisterService(&_VizierImageAuthorization_serviceDesc, srv)
}

func _VizierImageAuthorization_GetImageCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierImageAuthorizationServer).GetImageCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierImageAuthorization/GetImageCredentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierImageAuthorizationServer).GetImageCredentials(ctx, req.(*GetImageCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VizierImageAuthorization_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.VizierImageAuthorization",
	HandlerType: (*VizierImageAuthorizationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetImageCredentials",
			Handler:    _VizierImageAuthorization_GetImageCredentials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// ArtifactTrackerClient is the client API for ArtifactTracker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArtifactTrackerClient interface {
	GetArtifactList(ctx context.Context, in *GetArtifactListRequest, opts ...grpc.CallOption) (*ArtifactSet, error)
	GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error)
}

type artifactTrackerClient struct {
	cc *grpc.ClientConn
}

func NewArtifactTrackerClient(cc *grpc.ClientConn) ArtifactTrackerClient {
	return &artifactTrackerClient{cc}
}

func (c *artifactTrackerClient) GetArtifactList(ctx context.Context, in *GetArtifactListRequest, opts ...grpc.CallOption) (*ArtifactSet, error) {
	out := new(ArtifactSet)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ArtifactTracker/GetArtifactList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artifactTrackerClient) GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error) {
	out := new(GetDownloadLinkResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ArtifactTracker/GetDownloadLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArtifactTrackerServer is the server API for ArtifactTracker service.
type ArtifactTrackerServer interface {
	GetArtifactList(context.Context, *GetArtifactListRequest) (*ArtifactSet, error)
	GetDownloadLink(context.Context, *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error)
}

// UnimplementedArtifactTrackerServer can be embedded to have forward compatible implementations.
type UnimplementedArtifactTrackerServer struct {
}

func (*UnimplementedArtifactTrackerServer) GetArtifactList(ctx context.Context, req *GetArtifactListRequest) (*ArtifactSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifactList not implemented")
}
func (*UnimplementedArtifactTrackerServer) GetDownloadLink(ctx context.Context, req *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDownloadLink not implemented")
}

func RegisterArtifactTrackerServer(s *grpc.Server, srv ArtifactTrackerServer) {
	s.RegisterService(&_ArtifactTracker_serviceDesc, srv)
}

func _ArtifactTracker_GetArtifactList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactTrackerServer).GetArtifactList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ArtifactTracker/GetArtifactList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactTrackerServer).GetArtifactList(ctx, req.(*GetArtifactListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtifactTracker_GetDownloadLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactTrackerServer).GetDownloadLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ArtifactTracker/GetDownloadLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactTrackerServer).GetDownloadLink(ctx, req.(*GetDownloadLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArtifactTracker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.ArtifactTracker",
	HandlerType: (*ArtifactTrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetArtifactList",
			Handler:    _ArtifactTracker_GetArtifactList_Handler,
		},
		{
			MethodName: "GetDownloadLink",
			Handler:    _ArtifactTracker_GetDownloadLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// VizierClusterInfoClient is the client API for VizierClusterInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VizierClusterInfoClient interface {
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error)
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	GetClusterConnectionInfo(ctx context.Context, in *GetClusterConnectionInfoRequest, opts ...grpc.CallOption) (*GetClusterConnectionInfoResponse, error)
	UpdateClusterVizierConfig(ctx context.Context, in *UpdateClusterVizierConfigRequest, opts ...grpc.CallOption) (*UpdateClusterVizierConfigResponse, error)
	UpdateOrInstallCluster(ctx context.Context, in *UpdateOrInstallClusterRequest, opts ...grpc.CallOption) (*UpdateOrInstallClusterResponse, error)
}

type vizierClusterInfoClient struct {
	cc *grpc.ClientConn
}

func NewVizierClusterInfoClient(cc *grpc.ClientConn) VizierClusterInfoClient {
	return &vizierClusterInfoClient{cc}
}

func (c *vizierClusterInfoClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error) {
	out := new(CreateClusterResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/CreateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) GetClusterConnectionInfo(ctx context.Context, in *GetClusterConnectionInfoRequest, opts ...grpc.CallOption) (*GetClusterConnectionInfoResponse, error) {
	out := new(GetClusterConnectionInfoResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/GetClusterConnectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) UpdateClusterVizierConfig(ctx context.Context, in *UpdateClusterVizierConfigRequest, opts ...grpc.CallOption) (*UpdateClusterVizierConfigResponse, error) {
	out := new(UpdateClusterVizierConfigResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/UpdateClusterVizierConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vizierClusterInfoClient) UpdateOrInstallCluster(ctx context.Context, in *UpdateOrInstallClusterRequest, opts ...grpc.CallOption) (*UpdateOrInstallClusterResponse, error) {
	out := new(UpdateOrInstallClusterResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.VizierClusterInfo/UpdateOrInstallCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VizierClusterInfoServer is the server API for VizierClusterInfo service.
type VizierClusterInfoServer interface {
	CreateCluster(context.Context, *CreateClusterRequest) (*CreateClusterResponse, error)
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	GetClusterConnectionInfo(context.Context, *GetClusterConnectionInfoRequest) (*GetClusterConnectionInfoResponse, error)
	UpdateClusterVizierConfig(context.Context, *UpdateClusterVizierConfigRequest) (*UpdateClusterVizierConfigResponse, error)
	UpdateOrInstallCluster(context.Context, *UpdateOrInstallClusterRequest) (*UpdateOrInstallClusterResponse, error)
}

// UnimplementedVizierClusterInfoServer can be embedded to have forward compatible implementations.
type UnimplementedVizierClusterInfoServer struct {
}

func (*UnimplementedVizierClusterInfoServer) CreateCluster(ctx context.Context, req *CreateClusterRequest) (*CreateClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (*UnimplementedVizierClusterInfoServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (*UnimplementedVizierClusterInfoServer) GetClusterConnectionInfo(ctx context.Context, req *GetClusterConnectionInfoRequest) (*GetClusterConnectionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterConnectionInfo not implemented")
}
func (*UnimplementedVizierClusterInfoServer) UpdateClusterVizierConfig(ctx context.Context, req *UpdateClusterVizierConfigRequest) (*UpdateClusterVizierConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterVizierConfig not implemented")
}
func (*UnimplementedVizierClusterInfoServer) UpdateOrInstallCluster(ctx context.Context, req *UpdateOrInstallClusterRequest) (*UpdateOrInstallClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrInstallCluster not implemented")
}

func RegisterVizierClusterInfoServer(s *grpc.Server, srv VizierClusterInfoServer) {
	s.RegisterService(&_VizierClusterInfo_serviceDesc, srv)
}

func _VizierClusterInfo_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_GetClusterConnectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterConnectionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).GetClusterConnectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/GetClusterConnectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).GetClusterConnectionInfo(ctx, req.(*GetClusterConnectionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_UpdateClusterVizierConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterVizierConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).UpdateClusterVizierConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/UpdateClusterVizierConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).UpdateClusterVizierConfig(ctx, req.(*UpdateClusterVizierConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VizierClusterInfo_UpdateOrInstallCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrInstallClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VizierClusterInfoServer).UpdateOrInstallCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.VizierClusterInfo/UpdateOrInstallCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VizierClusterInfoServer).UpdateOrInstallCluster(ctx, req.(*UpdateOrInstallClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VizierClusterInfo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.VizierClusterInfo",
	HandlerType: (*VizierClusterInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _VizierClusterInfo_CreateCluster_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _VizierClusterInfo_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetClusterConnectionInfo",
			Handler:    _VizierClusterInfo_GetClusterConnectionInfo_Handler,
		},
		{
			MethodName: "UpdateClusterVizierConfig",
			Handler:    _VizierClusterInfo_UpdateClusterVizierConfig_Handler,
		},
		{
			MethodName: "UpdateOrInstallCluster",
			Handler:    _VizierClusterInfo_UpdateOrInstallCluster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// ScriptMgrClient is the client API for ScriptMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ScriptMgrClient interface {
	GetLiveViews(ctx context.Context, in *GetLiveViewsReq, opts ...grpc.CallOption) (*GetLiveViewsResp, error)
	GetLiveViewContents(ctx context.Context, in *GetLiveViewContentsReq, opts ...grpc.CallOption) (*GetLiveViewContentsResp, error)
	GetScripts(ctx context.Context, in *GetScriptsReq, opts ...grpc.CallOption) (*GetScriptsResp, error)
	GetScriptContents(ctx context.Context, in *GetScriptContentsReq, opts ...grpc.CallOption) (*GetScriptContentsResp, error)
}

type scriptMgrClient struct {
	cc *grpc.ClientConn
}

func NewScriptMgrClient(cc *grpc.ClientConn) ScriptMgrClient {
	return &scriptMgrClient{cc}
}

func (c *scriptMgrClient) GetLiveViews(ctx context.Context, in *GetLiveViewsReq, opts ...grpc.CallOption) (*GetLiveViewsResp, error) {
	out := new(GetLiveViewsResp)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ScriptMgr/GetLiveViews", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scriptMgrClient) GetLiveViewContents(ctx context.Context, in *GetLiveViewContentsReq, opts ...grpc.CallOption) (*GetLiveViewContentsResp, error) {
	out := new(GetLiveViewContentsResp)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ScriptMgr/GetLiveViewContents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scriptMgrClient) GetScripts(ctx context.Context, in *GetScriptsReq, opts ...grpc.CallOption) (*GetScriptsResp, error) {
	out := new(GetScriptsResp)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ScriptMgr/GetScripts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scriptMgrClient) GetScriptContents(ctx context.Context, in *GetScriptContentsReq, opts ...grpc.CallOption) (*GetScriptContentsResp, error) {
	out := new(GetScriptContentsResp)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.ScriptMgr/GetScriptContents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScriptMgrServer is the server API for ScriptMgr service.
type ScriptMgrServer interface {
	GetLiveViews(context.Context, *GetLiveViewsReq) (*GetLiveViewsResp, error)
	GetLiveViewContents(context.Context, *GetLiveViewContentsReq) (*GetLiveViewContentsResp, error)
	GetScripts(context.Context, *GetScriptsReq) (*GetScriptsResp, error)
	GetScriptContents(context.Context, *GetScriptContentsReq) (*GetScriptContentsResp, error)
}

// UnimplementedScriptMgrServer can be embedded to have forward compatible implementations.
type UnimplementedScriptMgrServer struct {
}

func (*UnimplementedScriptMgrServer) GetLiveViews(ctx context.Context, req *GetLiveViewsReq) (*GetLiveViewsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiveViews not implemented")
}
func (*UnimplementedScriptMgrServer) GetLiveViewContents(ctx context.Context, req *GetLiveViewContentsReq) (*GetLiveViewContentsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiveViewContents not implemented")
}
func (*UnimplementedScriptMgrServer) GetScripts(ctx context.Context, req *GetScriptsReq) (*GetScriptsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScripts not implemented")
}
func (*UnimplementedScriptMgrServer) GetScriptContents(ctx context.Context, req *GetScriptContentsReq) (*GetScriptContentsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScriptContents not implemented")
}

func RegisterScriptMgrServer(s *grpc.Server, srv ScriptMgrServer) {
	s.RegisterService(&_ScriptMgr_serviceDesc, srv)
}

func _ScriptMgr_GetLiveViews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveViewsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScriptMgrServer).GetLiveViews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ScriptMgr/GetLiveViews",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScriptMgrServer).GetLiveViews(ctx, req.(*GetLiveViewsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScriptMgr_GetLiveViewContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveViewContentsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScriptMgrServer).GetLiveViewContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ScriptMgr/GetLiveViewContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScriptMgrServer).GetLiveViewContents(ctx, req.(*GetLiveViewContentsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScriptMgr_GetScripts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScriptsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScriptMgrServer).GetScripts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ScriptMgr/GetScripts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScriptMgrServer).GetScripts(ctx, req.(*GetScriptsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScriptMgr_GetScriptContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScriptContentsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScriptMgrServer).GetScriptContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.ScriptMgr/GetScriptContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScriptMgrServer).GetScriptContents(ctx, req.(*GetScriptContentsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScriptMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.ScriptMgr",
	HandlerType: (*ScriptMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLiveViews",
			Handler:    _ScriptMgr_GetLiveViews_Handler,
		},
		{
			MethodName: "GetLiveViewContents",
			Handler:    _ScriptMgr_GetLiveViewContents_Handler,
		},
		{
			MethodName: "GetScripts",
			Handler:    _ScriptMgr_GetScripts_Handler,
		},
		{
			MethodName: "GetScriptContents",
			Handler:    _ScriptMgr_GetScriptContents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

// AutocompleteServiceClient is the client API for AutocompleteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutocompleteServiceClient interface {
	Autocomplete(ctx context.Context, in *AutocompleteRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error)
}

type autocompleteServiceClient struct {
	cc *grpc.ClientConn
}

func NewAutocompleteServiceClient(cc *grpc.ClientConn) AutocompleteServiceClient {
	return &autocompleteServiceClient{cc}
}

func (c *autocompleteServiceClient) Autocomplete(ctx context.Context, in *AutocompleteRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error) {
	out := new(AutocompleteResponse)
	err := c.cc.Invoke(ctx, "/pl.cloudapi.AutocompleteService/Autocomplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutocompleteServiceServer is the server API for AutocompleteService service.
type AutocompleteServiceServer interface {
	Autocomplete(context.Context, *AutocompleteRequest) (*AutocompleteResponse, error)
}

// UnimplementedAutocompleteServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAutocompleteServiceServer struct {
}

func (*UnimplementedAutocompleteServiceServer) Autocomplete(ctx context.Context, req *AutocompleteRequest) (*AutocompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Autocomplete not implemented")
}

func RegisterAutocompleteServiceServer(s *grpc.Server, srv AutocompleteServiceServer) {
	s.RegisterService(&_AutocompleteService_serviceDesc, srv)
}

func _AutocompleteService_Autocomplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutocompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutocompleteServiceServer).Autocomplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pl.cloudapi.AutocompleteService/Autocomplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutocompleteServiceServer).Autocomplete(ctx, req.(*AutocompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutocompleteService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pl.cloudapi.AutocompleteService",
	HandlerType: (*AutocompleteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Autocomplete",
			Handler:    _AutocompleteService_Autocomplete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/cloud/cloudapipb/cloudapi.proto",
}

func (m *LoginRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImageCredentialsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageCredentialsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageCredentialsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetImageCredentialsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageCredentialsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageCredentialsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creds) > 0 {
		i -= len(m.Creds)
		copy(dAtA[i:], m.Creds)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Creds)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Artifact) > 0 {
		for iNdEx := len(m.Artifact) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifact[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changelog) > 0 {
		i -= len(m.Changelog)
		copy(dAtA[i:], m.Changelog)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Changelog)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AvailableArtifacts) > 0 {
		dAtA2 := make([]byte, len(m.AvailableArtifacts)*10)
		var j1 int
		for _, num := range m.AvailableArtifacts {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCloudapi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VersionStr) > 0 {
		i -= len(m.VersionStr)
		copy(dAtA[i:], m.VersionStr)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VersionStr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CommitHash) > 0 {
		i -= len(m.CommitHash)
		copy(dAtA[i:], m.CommitHash)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.CommitHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetArtifactListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetArtifactListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetArtifactListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.ArtifactType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ArtifactType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ArtifactName) > 0 {
		i -= len(m.ArtifactName)
		copy(dAtA[i:], m.ArtifactName)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ArtifactName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDownloadLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDownloadLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDownloadLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ArtifactType != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.ArtifactType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VersionStr) > 0 {
		i -= len(m.VersionStr)
		copy(dAtA[i:], m.VersionStr)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VersionStr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ArtifactName) > 0 {
		i -= len(m.ArtifactName)
		copy(dAtA[i:], m.ArtifactName)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ArtifactName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDownloadLinkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDownloadLinkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDownloadLinkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != nil {
		{
			size, err := m.ValidUntil.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SHA256) > 0 {
		i -= len(m.SHA256)
		copy(dAtA[i:], m.SHA256)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.SHA256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateClusterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CreateClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterID != nil {
		{
			size, err := m.ClusterID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOrInstallClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOrInstallClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOrInstallClusterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterID != nil {
		{
			size, err := m.ClusterID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOrInstallClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOrInstallClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOrInstallClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateStarted {
		i--
		if m.UpdateStarted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VizierConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VizierConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VizierConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PassthroughEnabled {
		i--
		if m.PassthroughEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VizierConfigUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VizierConfigUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VizierConfigUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PassthroughEnabled != nil {
		{
			size, err := m.PassthroughEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VizierVersion) > 0 {
		i -= len(m.VizierVersion)
		copy(dAtA[i:], m.VizierVersion)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.VizierVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClusterVersion) > 0 {
		i -= len(m.ClusterVersion)
		copy(dAtA[i:], m.ClusterVersion)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ClusterVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClusterUID) > 0 {
		i -= len(m.ClusterUID)
		copy(dAtA[i:], m.ClusterUID)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ClusterUID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LastHeartbeatNs != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.LastHeartbeatNs))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConnectionInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConnectionInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConnectionInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterConnectionInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterConnectionInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterConnectionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IPAddress) > 0 {
		i -= len(m.IPAddress)
		copy(dAtA[i:], m.IPAddress)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.IPAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateClusterVizierConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClusterVizierConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClusterVizierConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigUpdate != nil {
		{
			size, err := m.ConfigUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateClusterVizierConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClusterVizierConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClusterVizierConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetLiveViewsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveViewsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLiveViewsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LiveViewMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiveViewMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiveViewMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLiveViewsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveViewsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLiveViewsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LiveViews) > 0 {
		for iNdEx := len(m.LiveViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LiveViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLiveViewContentsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveViewContentsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLiveViewContentsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LiveViewID) > 0 {
		i -= len(m.LiveViewID)
		copy(dAtA[i:], m.LiveViewID)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.LiveViewID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLiveViewContentsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveViewContentsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLiveViewContentsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vis != nil {
		{
			size, err := m.Vis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PxlContents) > 0 {
		i -= len(m.PxlContents)
		copy(dAtA[i:], m.PxlContents)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.PxlContents)))
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetScriptsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScriptsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScriptsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ScriptMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScriptMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScriptMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasLiveView {
		i--
		if m.HasLiveView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetScriptsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScriptsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScriptsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scripts) > 0 {
		for iNdEx := len(m.Scripts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scripts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetScriptContentsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScriptContentsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScriptContentsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScriptID) > 0 {
		i -= len(m.ScriptID)
		copy(dAtA[i:], m.ScriptID)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.ScriptID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetScriptContentsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScriptContentsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScriptContentsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contents) > 0 {
		i -= len(m.Contents)
		copy(dAtA[i:], m.Contents)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Contents)))
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCloudapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if m.CursorPos != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.CursorPos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Input) > 0 {
		i -= len(m.Input)
		copy(dAtA[i:], m.Input)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Input)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TabSuggestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabSuggestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TabSuggestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Suggestions) > 0 {
		for iNdEx := len(m.Suggestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Suggestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExecutableAfterSelect {
		i--
		if m.ExecutableAfterSelect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TabIndex != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.TabIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteSuggestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteSuggestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteSuggestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MatchedIndexes) > 0 {
		dAtA18 := make([]byte, len(m.MatchedIndexes)*10)
		var j17 int
		for _, num1 := range m.MatchedIndexes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintCloudapi(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintCloudapi(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TabSuggestions) > 0 {
		for iNdEx := len(m.TabSuggestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TabSuggestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsExecutable {
		i--
		if m.IsExecutable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FormattedInput) > 0 {
		i -= len(m.FormattedInput)
		copy(dAtA[i:], m.FormattedInput)
		i = encodeVarintCloudapi(dAtA, i, uint64(len(m.FormattedInput)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloudapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloudapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LoginRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *LoginReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovCloudapi(uint64(m.ExpiresAt))
	}
	return n
}

func (m *GetImageCredentialsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetImageCredentialsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creds)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *ArtifactSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.Artifact) > 0 {
		for _, e := range m.Artifact {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.CommitHash)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.VersionStr)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.AvailableArtifacts) > 0 {
		l = 0
		for _, e := range m.AvailableArtifacts {
			l += sovCloudapi(uint64(e))
		}
		n += 1 + sovCloudapi(uint64(l)) + l
	}
	l = len(m.Changelog)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetArtifactListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ArtifactName)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ArtifactType != 0 {
		n += 1 + sovCloudapi(uint64(m.ArtifactType))
	}
	if m.Limit != 0 {
		n += 1 + sovCloudapi(uint64(m.Limit))
	}
	return n
}

func (m *GetDownloadLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ArtifactName)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.VersionStr)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ArtifactType != 0 {
		n += 1 + sovCloudapi(uint64(m.ArtifactType))
	}
	return n
}

func (m *GetDownloadLinkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.SHA256)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ValidUntil != nil {
		l = m.ValidUntil.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *CreateClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != nil {
		l = m.ClusterID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateOrInstallClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != nil {
		l = m.ClusterID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateOrInstallClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateStarted {
		n += 2
	}
	return n
}

func (m *VizierConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassthroughEnabled {
		n += 2
	}
	return n
}

func (m *VizierConfigUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassthroughEnabled != nil {
		l = m.PassthroughEnabled.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *ClusterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCloudapi(uint64(m.Status))
	}
	if m.LastHeartbeatNs != 0 {
		n += 1 + sovCloudapi(uint64(m.LastHeartbeatNs))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.ClusterUID)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.ClusterVersion)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.VizierVersion)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *GetClusterConnectionInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetClusterConnectionInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateClusterVizierConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.ConfigUpdate != nil {
		l = m.ConfigUpdate.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *UpdateClusterVizierConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetLiveViewsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LiveViewMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetLiveViewsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LiveViews) > 0 {
		for _, e := range m.LiveViews {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *GetLiveViewContentsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LiveViewID)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetLiveViewContentsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.PxlContents)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.Vis != nil {
		l = m.Vis.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetScriptsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ScriptMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.HasLiveView {
		n += 2
	}
	return n
}

func (m *GetScriptsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scripts) > 0 {
		for _, e := range m.Scripts {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *GetScriptContentsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScriptID)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *GetScriptContentsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	return n
}

func (m *AutocompleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.CursorPos != 0 {
		n += 1 + sovCloudapi(uint64(m.CursorPos))
	}
	if m.Action != 0 {
		n += 1 + sovCloudapi(uint64(m.Action))
	}
	return n
}

func (m *TabSuggestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabIndex != 0 {
		n += 1 + sovCloudapi(uint64(m.TabIndex))
	}
	if m.ExecutableAfterSelect {
		n += 2
	}
	if len(m.Suggestions) > 0 {
		for _, e := range m.Suggestions {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func (m *AutocompleteSuggestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovCloudapi(uint64(m.Kind))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if len(m.MatchedIndexes) > 0 {
		l = 0
		for _, e := range m.MatchedIndexes {
			l += sovCloudapi(uint64(e))
		}
		n += 1 + sovCloudapi(uint64(l)) + l
	}
	return n
}

func (m *AutocompleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FormattedInput)
	if l > 0 {
		n += 1 + l + sovCloudapi(uint64(l))
	}
	if m.IsExecutable {
		n += 2
	}
	if len(m.TabSuggestions) > 0 {
		for _, e := range m.TabSuggestions {
			l = e.Size()
			n += 1 + l + sovCloudapi(uint64(l))
		}
	}
	return n
}

func sovCloudapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloudapi(x uint64) (n int) {
	return sovCloudapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LoginRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginRequest{`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginReply{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`ExpiresAt:` + fmt.Sprintf("%v", this.ExpiresAt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetImageCredentialsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetImageCredentialsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetImageCredentialsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetImageCredentialsResponse{`,
		`Creds:` + fmt.Sprintf("%v", this.Creds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArtifactSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArtifact := "[]*Artifact{"
	for _, f := range this.Artifact {
		repeatedStringForArtifact += strings.Replace(f.String(), "Artifact", "Artifact", 1) + ","
	}
	repeatedStringForArtifact += "}"
	s := strings.Join([]string{`&ArtifactSet{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Artifact:` + repeatedStringForArtifact + `,`,
		`}`,
	}, "")
	return s
}
func (this *Artifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Artifact{`,
		`Timestamp:` + strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`CommitHash:` + fmt.Sprintf("%v", this.CommitHash) + `,`,
		`VersionStr:` + fmt.Sprintf("%v", this.VersionStr) + `,`,
		`AvailableArtifacts:` + fmt.Sprintf("%v", this.AvailableArtifacts) + `,`,
		`Changelog:` + fmt.Sprintf("%v", this.Changelog) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetArtifactListRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetArtifactListRequest{`,
		`ArtifactName:` + fmt.Sprintf("%v", this.ArtifactName) + `,`,
		`ArtifactType:` + fmt.Sprintf("%v", this.ArtifactType) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetDownloadLinkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetDownloadLinkRequest{`,
		`ArtifactName:` + fmt.Sprintf("%v", this.ArtifactName) + `,`,
		`VersionStr:` + fmt.Sprintf("%v", this.VersionStr) + `,`,
		`ArtifactType:` + fmt.Sprintf("%v", this.ArtifactType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetDownloadLinkResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetDownloadLinkResponse{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`SHA256:` + fmt.Sprintf("%v", this.SHA256) + `,`,
		`ValidUntil:` + strings.Replace(fmt.Sprintf("%v", this.ValidUntil), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateClusterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateClusterRequest{`,
		`}`,
	}, "")
	return s
}
func (this *CreateClusterResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateClusterResponse{`,
		`ClusterID:` + strings.Replace(fmt.Sprintf("%v", this.ClusterID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateOrInstallClusterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateOrInstallClusterRequest{`,
		`ClusterID:` + strings.Replace(fmt.Sprintf("%v", this.ClusterID), "UUID", "proto1.UUID", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateOrInstallClusterResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateOrInstallClusterResponse{`,
		`UpdateStarted:` + fmt.Sprintf("%v", this.UpdateStarted) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VizierConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VizierConfig{`,
		`PassthroughEnabled:` + fmt.Sprintf("%v", this.PassthroughEnabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VizierConfigUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VizierConfigUpdate{`,
		`PassthroughEnabled:` + strings.Replace(fmt.Sprintf("%v", this.PassthroughEnabled), "BoolValue", "types.BoolValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterInfoRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClusterInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClusterInfo{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastHeartbeatNs:` + fmt.Sprintf("%v", this.LastHeartbeatNs) + `,`,
		`Config:` + strings.Replace(this.Config.String(), "VizierConfig", "VizierConfig", 1) + `,`,
		`ClusterUID:` + fmt.Sprintf("%v", this.ClusterUID) + `,`,
		`ClusterName:` + fmt.Sprintf("%v", this.ClusterName) + `,`,
		`ClusterVersion:` + fmt.Sprintf("%v", this.ClusterVersion) + `,`,
		`VizierVersion:` + fmt.Sprintf("%v", this.VizierVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForClusters := "[]*ClusterInfo{"
	for _, f := range this.Clusters {
		repeatedStringForClusters += strings.Replace(f.String(), "ClusterInfo", "ClusterInfo", 1) + ","
	}
	repeatedStringForClusters += "}"
	s := strings.Join([]string{`&GetClusterInfoResponse{`,
		`Clusters:` + repeatedStringForClusters + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterConnectionInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterConnectionInfoRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetClusterConnectionInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetClusterConnectionInfoResponse{`,
		`IPAddress:` + fmt.Sprintf("%v", this.IPAddress) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateClusterVizierConfigRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateClusterVizierConfigRequest{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "proto1.UUID", 1) + `,`,
		`ConfigUpdate:` + strings.Replace(this.ConfigUpdate.String(), "VizierConfigUpdate", "VizierConfigUpdate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateClusterVizierConfigResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateClusterVizierConfigResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetLiveViewsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetLiveViewsReq{`,
		`}`,
	}, "")
	return s
}
func (this *LiveViewMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiveViewMetadata{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetLiveViewsResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLiveViews := "[]*LiveViewMetadata{"
	for _, f := range this.LiveViews {
		repeatedStringForLiveViews += strings.Replace(f.String(), "LiveViewMetadata", "LiveViewMetadata", 1) + ","
	}
	repeatedStringForLiveViews += "}"
	s := strings.Join([]string{`&GetLiveViewsResp{`,
		`LiveViews:` + repeatedStringForLiveViews + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetLiveViewContentsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetLiveViewContentsReq{`,
		`LiveViewID:` + fmt.Sprintf("%v", this.LiveViewID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetLiveViewContentsResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetLiveViewContentsResp{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "LiveViewMetadata", "LiveViewMetadata", 1) + `,`,
		`PxlContents:` + fmt.Sprintf("%v", this.PxlContents) + `,`,
		`Vis:` + strings.Replace(fmt.Sprintf("%v", this.Vis), "Vis", "vispb.Vis", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetScriptsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetScriptsReq{`,
		`}`,
	}, "")
	return s
}
func (this *ScriptMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScriptMetadata{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`HasLiveView:` + fmt.Sprintf("%v", this.HasLiveView) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetScriptsResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForScripts := "[]*ScriptMetadata{"
	for _, f := range this.Scripts {
		repeatedStringForScripts += strings.Replace(f.String(), "ScriptMetadata", "ScriptMetadata", 1) + ","
	}
	repeatedStringForScripts += "}"
	s := strings.Join([]string{`&GetScriptsResp{`,
		`Scripts:` + repeatedStringForScripts + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetScriptContentsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetScriptContentsReq{`,
		`ScriptID:` + fmt.Sprintf("%v", this.ScriptID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetScriptContentsResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetScriptContentsResp{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "ScriptMetadata", "ScriptMetadata", 1) + `,`,
		`Contents:` + fmt.Sprintf("%v", this.Contents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutocompleteRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`CursorPos:` + fmt.Sprintf("%v", this.CursorPos) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TabSuggestion) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSuggestions := "[]*AutocompleteSuggestion{"
	for _, f := range this.Suggestions {
		repeatedStringForSuggestions += strings.Replace(f.String(), "AutocompleteSuggestion", "AutocompleteSuggestion", 1) + ","
	}
	repeatedStringForSuggestions += "}"
	s := strings.Join([]string{`&TabSuggestion{`,
		`TabIndex:` + fmt.Sprintf("%v", this.TabIndex) + `,`,
		`ExecutableAfterSelect:` + fmt.Sprintf("%v", this.ExecutableAfterSelect) + `,`,
		`Suggestions:` + repeatedStringForSuggestions + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteSuggestion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutocompleteSuggestion{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`MatchedIndexes:` + fmt.Sprintf("%v", this.MatchedIndexes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTabSuggestions := "[]*TabSuggestion{"
	for _, f := range this.TabSuggestions {
		repeatedStringForTabSuggestions += strings.Replace(f.String(), "TabSuggestion", "TabSuggestion", 1) + ","
	}
	repeatedStringForTabSuggestions += "}"
	s := strings.Join([]string{`&AutocompleteResponse{`,
		`FormattedInput:` + fmt.Sprintf("%v", this.FormattedInput) + `,`,
		`IsExecutable:` + fmt.Sprintf("%v", this.IsExecutable) + `,`,
		`TabSuggestions:` + repeatedStringForTabSuggestions + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCloudapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LoginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageCredentialsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageCredentialsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageCredentialsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageCredentialsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageCredentialsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageCredentialsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifact = append(m.Artifact, &Artifact{})
			if err := m.Artifact[len(m.Artifact)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v ArtifactType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ArtifactType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AvailableArtifacts = append(m.AvailableArtifacts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCloudapi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCloudapi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AvailableArtifacts) == 0 {
					m.AvailableArtifacts = make([]ArtifactType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ArtifactType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ArtifactType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AvailableArtifacts = append(m.AvailableArtifacts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableArtifacts", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changelog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changelog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetArtifactListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetArtifactListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetArtifactListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArtifactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactType", wireType)
			}
			m.ArtifactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactType |= ArtifactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDownloadLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDownloadLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDownloadLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArtifactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactType", wireType)
			}
			m.ArtifactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactType |= ArtifactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDownloadLinkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDownloadLinkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDownloadLinkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHA256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SHA256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidUntil == nil {
				m.ValidUntil = &types.Timestamp{}
			}
			if err := m.ValidUntil.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterID == nil {
				m.ClusterID = &proto1.UUID{}
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOrInstallClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOrInstallClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOrInstallClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterID == nil {
				m.ClusterID = &proto1.UUID{}
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOrInstallClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOrInstallClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOrInstallClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStarted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStarted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VizierConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VizierConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VizierConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassthroughEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassthroughEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VizierConfigUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VizierConfigUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VizierConfigUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassthroughEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassthroughEnabled == nil {
				m.PassthroughEnabled = &types.BoolValue{}
			}
			if err := m.PassthroughEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ClusterStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeatNs", wireType)
			}
			m.LastHeartbeatNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeatNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &VizierConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VizierVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VizierVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &ClusterInfo{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConnectionInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConnectionInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConnectionInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterConnectionInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterConnectionInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterConnectionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateClusterVizierConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &proto1.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigUpdate == nil {
				m.ConfigUpdate = &VizierConfigUpdate{}
			}
			if err := m.ConfigUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateClusterVizierConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClusterVizierConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveViewsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveViewsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveViewsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiveViewMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveViewMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveViewMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveViewsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveViewsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveViewsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveViews = append(m.LiveViews, &LiveViewMetadata{})
			if err := m.LiveViews[len(m.LiveViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveViewContentsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveViewContentsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveViewContentsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveViewID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveViewID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveViewContentsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveViewContentsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveViewContentsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &LiveViewMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PxlContents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PxlContents = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vis == nil {
				m.Vis = &vispb.Vis{}
			}
			if err := m.Vis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScriptsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScriptsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScriptsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScriptMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScriptMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScriptMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLiveView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasLiveView = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScriptsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScriptsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScriptsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scripts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scripts = append(m.Scripts, &ScriptMetadata{})
			if err := m.Scripts[len(m.Scripts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScriptContentsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScriptContentsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScriptContentsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScriptContentsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScriptContentsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScriptContentsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ScriptMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorPos", wireType)
			}
			m.CursorPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CursorPos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= AutocompleteActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabSuggestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabSuggestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabSuggestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabIndex", wireType)
			}
			m.TabIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutableAfterSelect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecutableAfterSelect = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suggestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suggestions = append(m.Suggestions, &AutocompleteSuggestion{})
			if err := m.Suggestions[len(m.Suggestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteSuggestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteSuggestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteSuggestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= AutocompleteEntityKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MatchedIndexes = append(m.MatchedIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCloudapi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCloudapi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MatchedIndexes) == 0 {
					m.MatchedIndexes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MatchedIndexes = append(m.MatchedIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedIndexes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormattedInput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormattedInput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExecutable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExecutable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabSuggestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TabSuggestions = append(m.TabSuggestions, &TabSuggestion{})
			if err := m.TabSuggestions[len(m.TabSuggestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloudapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloudapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloudapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloudapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloudapi = fmt.Errorf("proto: unexpected end of group")
)
