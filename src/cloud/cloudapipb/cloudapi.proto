syntax = "proto3";

/**********************************************************************
 * NOTICE: INTERNAL
 * This file is meant as the external protobuf interface for the cloud.
 * Please do not include dependencies that are outside of /src/common
 **********************************************************************/

package pl.cloudapi;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "src/common/uuid/proto/uuid.proto";
import "google/protobuf/timestamp.proto";

import "google/protobuf/wrappers.proto";

option go_package = "pixielabs.ai/pixielabs/src/cloud/cloudapipb;cloudapipb";

service AuthService {
  // Get a refresh token.
  rpc Login(LoginRequest) returns (LoginReply) {}
}

message LoginRequest {
  // The auth0 access token.
  string access_token = 1;
}

message LoginReply {
  // The opaque access token generated by our system. This is a JWT claim
  // that is used to identify the user. This token can be treated as the refresh token
  // and should not be sent to insecure clients.
  string token = 1;
  // When this login expires.
  int64 expires_at      = 2;
}

// VizierImageAuthorization is the service responsible for giving authorization to fetch vizier image.
service VizierImageAuthorization {
  rpc GetImageCredentials(GetImageCredentialsRequest) returns (GetImageCredentialsResponse) {}
}

message GetImageCredentialsRequest {}

// GetImageCredentialsResponse returns the docker credentials.
message GetImageCredentialsResponse {
  string creds = 1;
}

// ArtifactType is the type of artifact that was released.
enum ArtifactType {
    AT_UNKNOWN = 0;
    AT_LINUX_AMD64 = 1;
    AT_DARWIN_AMD64 = 2;

    AT_CONTAINER_SET_YAMLS = 50;
    AT_CONTAINER_SET_LINUX_AMD64 = 100;
}

// ArtifactSet stores a list artifacts. This is typically stored in a VERSIONS file in JSON format.
message ArtifactSet {
    // The name of the artifact: (cli, vizier).
    string name = 1;
    // List of artifacts, sorted by release date.
    repeated Artifact artifact = 2;
}

// Artifact stores information about a specific artifact version.
message Artifact {
    // The timestamp that this artifact was released.
    google.protobuf.Timestamp timestamp = 1;
    // The commit hash that this artifact was built using.
    string commit_hash = 2;
    // The version string of the artifact (in either CalVer or SemVer).
    string version_str = 3;
    // This is a list of artifact types that are available. The artifacts need to be in a canonical location:
    // gs://<artifact_bucket>/<name>/version_str/<name>_<type>[.sha256]. The location is only valid for artifacts that
    // are individual binaries. For example, the linux "cli" will of version 2019.10.03-1 will be located at:
    // gs://<artifact_bucket>/cli/2019.10.03-1/cli_linux_amd64 with it's sha hash at:
    // gs://<artifact_bucket>/cli/2019.10.03-1/cli_linux_amd64.sha256.
    // For container_sets, the path is typically gcr.io/..../image_name:<version_str>.
    repeated ArtifactType available_artifacts = 4;
    // The changelog for this version (in markdown format).
    string changelog = 5;
}


// ArtifactTracker tracks versions of released artifacts.
service ArtifactTracker {
    // GetArtifactList is used to request a list of artifacts.
    rpc GetArtifactList(GetArtifactListRequest) returns(ArtifactSet) {}
    // GetDownloadLink is used to request a signed URL.
    rpc GetDownloadLink(GetDownloadLinkRequest) returns(GetDownloadLinkResponse) {}
}

message GetArtifactListRequest {
    string artifact_name = 1;
    // Select the type of artifact to look for and filter by.
    ArtifactType artifact_type = 2;
    // Limit the number of responses, ordered by time.
    int64 limit = 3;
}

// GetDownloadLinkRequest is used to get a signed URL for a specific artifact. Only singular
// artifacts are currently supported.
message GetDownloadLinkRequest {
    string artifact_name = 1;
    string version_str = 2;
    ArtifactType artifact_type = 3;
}

// GetDownloadLinkResponse returns a signed url that can be used to download the artifact.
message GetDownloadLinkResponse {
    string url = 1;
    // The sha256 of the artifact.
    string sha256 = 2 [
                          (gogoproto.customname) = "SHA256"
                      ];

    google.protobuf.Timestamp valid_until = 3;
}

message CreateClusterRequest {}

message CreateClusterResponse {
    pl.uuidpb.UUID cluster_id = 1 [
                          (gogoproto.customname) = "ClusterID"
                          ];
}

service VizierClusterInfo {
    rpc CreateCluster(CreateClusterRequest) returns(CreateClusterResponse) {}
    rpc GetClusterInfo(GetClusterInfoRequest) returns(GetClusterInfoResponse) {}
    rpc GetClusterConnectionInfo(GetClusterConnectionInfoRequest) returns(GetClusterConnectionInfoResponse) {}
    rpc UpdateClusterVizierConfig(UpdateClusterVizierConfigRequest) returns(UpdateClusterVizierConfigResponse) {}
}

message VizierConfig {
    bool passthrough_enabled = 1;
}

message VizierConfigUpdate {
    google.protobuf.BoolValue passthrough_enabled = 1;
}

message GetClusterInfoRequest {
    // Optional. If specified, get cluster info only for the specified cluster.
    pl.uuidpb.UUID id = 1 [
                          (gogoproto.customname) = "ID"
                          ];
}

enum ClusterStatus {
    CS_UNKNOWN = 0;
    CS_HEALTHY = 1;
    CS_UNHEALTHY = 2;
    CS_DISCONNECTED = 3;
}

message ClusterInfo {
    pl.uuidpb.UUID id = 1 [
                          (gogoproto.customname) = "ID"
                          ];
    ClusterStatus status = 2;
    int64 lastHeartbeatNs = 3;
    VizierConfig config = 4;
}

message GetClusterInfoResponse {
    repeated ClusterInfo clusters = 1;
}

message GetClusterConnectionInfoRequest {
     pl.uuidpb.UUID id = 1 [
                           (gogoproto.customname) = "ID"
                           ];
}

message GetClusterConnectionInfoResponse {
    string ipAddress = 1 [
                         (gogoproto.customname) = "IPAddress"
                         ];
    string token = 2;
}

message UpdateClusterVizierConfigRequest {
    pl.uuidpb.UUID id = 1 [
                           (gogoproto.customname) = "ID"
                           ];
    VizierConfigUpdate config_update = 2;
}

message UpdateClusterVizierConfigResponse {}

service ScriptMgr {
}

// AutocompleteService responds to autocomplete requests.
service AutocompleteService {
    rpc Autocomplete(AutocompleteRequest) returns(AutocompleteResponse) {}
}

enum AutocompleteActionType {
  AAT_UNKNOWN = 0;
  // An edit action indicates the user has made an edit to the input text,
  // such as adding/deleting/pasting characters.
  AAT_EDIT = 1;
  // A select action occurs when the user has selected a suggestion. This
  // indicates that the cursor should be moved to the next tabIndex that
  // should be autocompleted.
  AAT_SELECT = 2;
}

enum AutocompleteEntityKind {
  AEK_UNKNOWN = 0;
  AEK_POD = 1;
  AEK_SVC = 2;
  AEK_SCRIPT = 3;
  AEK_NAMESPACE = 4;
}

message AutocompleteRequest {
  // The input is the text that the user currently sees on the screen,
  // unformatted: "script:px/svc_info svc:pl/front-end"
  string input = 1;
  // The cursor position is the index of the user's cursor in the input string.
  // In the following examples, | indicates where the cursor is:
  // CursorPos: 0, |script:px/svc_info
  // CursorPos: 1, s|cript:px/svc_info
  int64 cursor_pos = 2;
  // The action is the user's action the user took to trigger the autocomplete request.
  AutocompleteActionType action = 3;
}

message TabSuggestion {
  // The TabIndex is the index for which these suggestions are for.
  // For example, if the formattedInput is: ${1:run} ${2:test}, and the tabIndex is
  // 2, this represents the suggestions for ${2:test}.
  int64 tab_index = 1;
  // Whether the command will be executable if the user makes a selection for this
  // tab index.
  bool executable_after_select = 2;
  repeated AutocompleteSuggestion suggestions = 3;
}

message AutocompleteSuggestion {
  // The kind of the suggestion.
  AutocompleteEntityKind kind = 1;
  // The name of the suggestion.
  string name = 2;
  // A description of the suggestion.
  string description = 3;
}

message AutocompleteResponse {
  // The formatted input is the user's input parsed and formatted with the correct
  // tab index information. Ex: ${1:run} {$2:script:px/svc_info} {$3:svc:pl/front-end}$0
  string formatted_input = 1;
  // Whether the user provided input is executable without needing to make any
  // further selections.
  bool is_executable = 2;
  // The suggestions available for each tab.
  repeated TabSuggestion tabSuggestions = 3;
}
