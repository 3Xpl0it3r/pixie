syntax = "proto3";
import "google/protobuf/wrappers.proto";
import "src/shared/types/proto/types.proto";

package pl.carnot.carnotpb;

option go_package = "carnotpb";

// The plan is composed of multiple fragments which each
// define a part of the plan that needs to be executed sequentially
// in order to resolve dependencies (ex. Blocking Join).
message Plan {
  // The DAG which stores the connection information of the plan fragments.
  DAG dag = 1;
  // List of plan fragments referenced by the DAG.
  repeated PlanFragment nodes = 2;
}

// Each plan fragment is a DAG represented in a format similar to an adjacency
// list: a list of nodes and interconnections between nodes.
message PlanFragment {
  // The ID of the plan fragment.
  uint64 id = 1;
  // The DAG which stores the connection information.
  DAG dag = 2;
  // List of nodes referenced by the DAG.
  repeated PlanNode nodes = 3;
}

// The DAG simply stores the dependencies for each node.
message DAG {
  // DAG node stores information about each node and it's dependencies.
  message DAGNode {
    // The ID of the node. This is the same as the ID used for PlanNode or PlanFragment.
    uint64 id = 1;
    // The dependencies of this DAG node stored as the PlanNode/PlanFragment IDs.
    repeated uint64 sorted_deps = 2;
  }
  // List of dependencies.
  repeated DAGNode nodes = 1;
}

// A execution node used by the query plan.
message PlanNode {
  // A unique ID used to reference this node.
  uint64 id = 1;
  // The operation that this node performs.
  Operator op = 2;
}

enum OperatorType {
  OPERATOR_TYPE_UNKNOWN = 0;
  // Source operators are rangs 1000 - 2000.
  MEMORY_SOURCE_OPERATOR = 1000;
  // Regular operators are range 2000 - 10000.
  MAP_OPERATOR = 2000;
  BLOCKING_AGGREGATE_OPERATOR = 2100;
  FILTER_OPERATOR = 2200;
  // Sink operators are range 9000-10000.
  MEMORY_SINK_OPERATOR = 9000;
}

// The Logical operation performed. Each operator needs and entry in this
// message.
message Operator {
  OperatorType op_type = 1;
  oneof op {
    // Fetches data from in memory storage.
    MemorySourceOperator mem_source_op = 2;
    // Performs a simple Map operation.
    MapOperator map_op = 3;
    // Performs a blocking aggregate (instead of streaming/non-blocking aggregate).
    BlockingAggregateOperator blocking_agg_op = 4;
    // Operator that stores data to memory.
    MemorySinkOperator mem_sink_op = 5;
    // Performs a compacting Filter operation.
    FilterOperator filter_op = 6;
  }
}

// Fetches data from in-memory source.
message MemorySourceOperator {
  // Name of the table.
  string name = 1;
  // The column indexes to fetch.
  repeated int64 column_idxs = 2;
  // The names for the columns.
  repeated string column_names = 3;
  // The types of the columns.
  repeated pl.types.DataType column_types = 4;
  // The start time (can be omitted if not time series).
  google.protobuf.Int64Value start_time = 5;
  // The stop time (can be omitted if not time series).
  google.protobuf.Int64Value stop_time = 6;
}

// Writes to in-memory storage.
message MemorySinkOperator {
  // Storage is organized as tables, this specifies the name of the table.
  string name = 1;
  // The types of the columns.
  repeated pl.types.DataType column_types = 2;
  // The names of the columns.
  repeated string column_names = 3;
}

// Performs map operation.
message MapOperator {
  // Each scalar operator defines an output column.
  // In order for columns to be copied they must be references by
  // the scalar expression.
  repeated ScalarExpression expressions = 1;
  repeated string column_names = 2;
}

// Aggregate does a group by the "group" Columns and computes
// the aggregates based on aggregate expression. Number of
// output columns is equal to the len(values).
message BlockingAggregateOperator {
  // The functions to execute for this aggregate.
  // Note that only agg funcs are valid here.
  repeated AggregateExpression values = 1;
  // The columns to use for grouping. For grouping involving a function
  // a map operation will need to be performed first.
  repeated Column groups = 2;
  // The names of the output groups.
  repeated string group_names = 3;
  // The names of values.
  repeated string value_names = 4;
}

// Performs a compacting filter
message FilterOperator {
  // The scalar expression defines the filtering expression that will be run on the data.
  ScalarExpression expression = 1;
  // Defines the columns that are passed from the previous operator.
  repeated Column columns = 2;
}

// Scalar expression is any single valued expression.
message ScalarExpression {
  oneof value {
    // A constant value.
    ScalarValue constant = 1;
    // A value that is a column reference.
    Column column = 2;
    // A value that is a function applied on a set of columns.
    ScalarFunc func = 3;
  }
}

// ScalarValues reference a single constant value.
message ScalarValue {
  // We need to store the type to handle the null case and make sure we have the
  // "correct" null value. This type takes precedence on the one of value below.
  // If they mismatch a null value will be used.
  pl.types.DataType data_type = 1;
  oneof value {
    bool bool_value = 2;
    int64 int64_value = 3;
    double float64_value = 4;
    string string_value = 5;
    int64 time64_ns_value = 6;
  }
}

// ScalarFuncs perform an operator on a set of arguments and produce a single
// valued output.
// TODO(zasgar). What do to about multi value output?
// Should they produce a list that is flattened, or a struct?
message ScalarFunc {
  // The name of the function. Should exist in UDF/UDAF registry.
  string name = 1;
  // The constructor arguments.
  repeated ScalarValue init_args = 2;
  // The arguments used during evaluation.
  repeated ScalarExpression args = 3;
  int64 id = 4;
}

// AggregateExpressions perform an operator on a set of arguments and produce a single
// valued output.
message AggregateExpression {
  message Arg {
    oneof value {
      // A constant value.
      ScalarValue constant = 1;
      // A value that is a column reference.
      Column column = 2;
    }
  }
  // The name of the function. Should exist in UDA registry.
  string name = 3;
  // The constructor arguments.
  repeated ScalarValue init_args = 4;
  repeated Arg args = 5;
  int64 id = 6;
}

// A column reference.
message Column {
  // The node that produces the output.
  uint64 node = 1;
  // The index of the column.
  uint64 index = 2;
}
