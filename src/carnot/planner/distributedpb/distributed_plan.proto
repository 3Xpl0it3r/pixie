syntax = "proto3";

import "src/carnot/planpb/plan.proto";
import "src/common/base/proto/status.proto";
import "src/shared/bloomfilterpb/bloomfilter.proto";
import "src/shared/metadatapb/metadata.proto";
import "src/table_store/proto/schema.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "src/common/uuid/proto/uuid.proto";

package pl.carnot.planner.distributedpb;

option go_package = "distributedpb";

// Info about the Metadata stored on a Carnot instance.
message MetadataInfo {
  // A list of the metadata fields that are stored in MetadataInfo.
  // If we don't store a particular field in metadata_fields, the compiler shouldn't
  // use it for pruning query plans.
  repeated pl.shared.metadatapb.MetadataType metadata_fields = 1;
  // A structure such as a bloom filter, that contains all of the values
  // for the carnot's metadata, such as container id, service name, pod id, namespace.
  // This structure may contain false positives but not false negatives.
  oneof filter {
      pl.shared.bloomfilterpb.XXHash64BloomFilter xxhash64_bloom_filter = 2 [
        (gogoproto.customname) = "XXHash64BloomFilter"
      ];
  }
}

// Info about the Distributed characteristics of a Carnot instance.
message CarnotInfo {
  // The unique address used by the query broker to contact this instance.
  string query_broker_address = 1;
  // The unique ID of this agent.
  uuidpb.UUID agent_id = 10 [ (gogoproto.customname) = "AgentID" ];
  // Flag if the Carnot instance hosts a GRPC server.
  bool has_grpc_server = 2 [ (gogoproto.customname) = "HasGRPCServer" ];
  // The address of the GRPC server hosted by the Carnot instance, it has a GRPC
  // server.
  string grpc_address = 3 [ (gogoproto.customname) = "GRPCAddress" ];
  // Flag if the carnot instance has an in-memory store of data.
  // E.g. agents stores data, but some Kelvin instances might only be used for
  // computation.
  bool has_data_store = 4;
  // Flag whether this Carnot instance can process data.
  // E.g. the query broker only wants to accept data and pass it up to the UI.
  bool processes_data = 5;
  // Flag if this Carnot instance accepts remote sources.
  // E.g. Kelvin instances accept remote sources - they are arbitrary workers,
  // agents are not.
  bool accepts_remote_sources = 6;
  // Info about the tables for the Carnot instance.
  repeated TableInfo table_info = 7;
  // The asid of the Agent running the Carnot.
  uint32 asid = 8 [ (gogoproto.customname) = "ASID" ];
  // Information about the metadata stored on a Carnot instance.
  MetadataInfo metadata_info = 9;
}

// Information about the table structure as well as the tablet keys.
message TableInfo {
  // The table that is associated with the tablets.
  string table = 1;
  // The tabletization key of the table.
  string tabletization_key = 2;
  // The tablet values to use.
  repeated string tablets = 3;
}

// SchemaInfo maps the available schemas in Vizier to the agents that can
// actually use them. We use inverted mapping to save space, especially on large
// clusters where we might have many entries for CarnotInfo::TableInfo.
message SchemaInfo {
  // The name of the table.
  string name = 1;
  // The relation for the table.
  pl.table_store.schemapb.Relation relation = 2;
  // The list of agents that hold this schema.
  repeated uuidpb.UUID agent_list = 3;
}

// The Distributed state of the distributed Carnot instances.
message DistributedState {
  // Info about all available Carnot instances in Vizier.
  repeated CarnotInfo carnot_info = 1;
  // Schemas definitions and which agents hold tables corresponding to those
  // schemas.
  repeated SchemaInfo schema_info = 2;
}

// The Distributed Plan message that describes the graph of the plans
// and which plans should execute on each Carnot instance.
message DistributedPlan {
  // Map query broker address of Carnot instance to the Plan it will execute.
  map<string, pl.carnot.planpb.Plan> qb_address_to_plan = 1;
  // Map from query broker address to the id used in the dag.
  map<string, uint64> qb_address_to_dag_id = 2;
  // The DAG describing the connections between the Distributed nodes.
  pl.carnot.planpb.DAG dag = 3;
}

// LogicalPlannerState contains the information necessary to create the Logical
// Plan. This message is used by the query broker to send to the logical
// planner.
message LogicalPlannerState {
  // Previously used to store a global schema for the agents.
  reserved 1;
  // The distributed state of all Carnot instances in the system.
  DistributedState distributed_state = 2;
  // The query options for how the plans should be executed.
  pl.carnot.planpb.PlanOptions plan_options = 3;
  // The address to which the query results should be sent.
  string result_address = 4;
}

// The result for the planner. Contains a status to track any errors
message LogicalPlannerResult {
  pl.statuspb.Status status = 1;
  DistributedPlan plan = 2;
}
