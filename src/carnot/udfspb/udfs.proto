syntax = "proto3";
import "src/shared/types/proto/types.proto";
import "src/table_store/proto/schema.proto";

package pl.carnot.udfspb;

option go_package = "udfspb";

// UDASpec stores the specification of a single UDA.
message UDASpec {
  // The name of the function.
  string name = 1;
  // Will be an empty list if there is no init function.
  repeated pl.types.DataType init_arg_types = 2;
  // The argument types of the update function. UDAs are allowed to overload based on
  // these types.
  repeated pl.types.DataType update_arg_types = 3;
  // The argument types of the finalize return.
  pl.types.DataType finalize_type = 4;
}

// ScalarUDFSpec stores the specification of a single UDF.
message ScalarUDFSpec {
  // The name of the function.
  string name = 1;
  // Will be an empty list if there is no init function.
  repeated pl.types.DataType init_arg_types = 2;
  // The argument types of the exec args. UDFs are allowed to overload based on
  // these types.
  repeated pl.types.DataType exec_arg_types = 3;
  // The return type of the exec function.
  pl.types.DataType return_type = 4;
}

// UDFInfo stores all the registered UDF/UDAs in the system.
message UDFInfo {
  // A list of the UDAs.
  repeated UDASpec udas = 1;
  // A list of the ScalarUDFs.
  repeated ScalarUDFSpec scalar_udfs = 2;
  // A description of the UDTFs.
  repeated UDTFSourceSpec udtfs = 3;
}

// The type of the table func to write.
enum UDTFSourceExecutor {
  UDTF_UNSPECIFIED = 0;
  UDTF_ALL_AGENTS = 1;
  UDTF_ALL_PEM = 2;
  UDTF_ALL_KELVIN = 3;
  UDTF_SUBSET_PEM = 4;
  UDTF_SUBSET_KELVIN = 5;
  UDTF_ONE_KELVIN = 6;
}

// UDTFSourceSpec stores the information necessary to execute a UDTFSource.
message UDTFSourceSpec {
  // Argument object that contains name, and arg_type and the list.
  message Arg {
    string name = 1;
    pl.types.DataType arg_type = 2;
    pl.types.SemanticType semantic_type = 3;
  }

  // The type of filter to use on the semantic argument.
  // At the current moment specifying this means that you want to exactly match
  // the user's passed in argument to filter.
  message SemanticArgFilter {
    // The index of the argument that is semantic.
    int64 idx = 1;
  }
  message Filter {
    oneof filter {
      SemanticArgFilter semantic_filter = 1;
    }
  }
  // Name of the UDTFSource.
  string name = 1;
  // The types of the arguments of the UDTFSource. Must be the same length as arg_names.
  repeated Arg args = 2;
  // Which agents the table function should execute on.
  UDTFSourceExecutor executor = 3;
  // The filter to use when the executor uses a subset.
  repeated Filter filters = 4;
  // The relation that this UDTF generates.
  pl.table_store.schemapb.Relation relation = 5;
}
