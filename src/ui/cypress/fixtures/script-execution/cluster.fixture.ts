/*
 * Copyright 2018- The Pixie Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/* eslint-disable max-len */

export const ExecuteScriptRequestString = ''
 + 'AAAAR/AKoIcBIyBDb3B5cmlnaHQgMjAxOC0gVGhlIFBpeGllIEF1dGhvcnMuCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiMKIyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKIyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KIyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiMgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiMKIyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMAoKJycnIENsdXN0ZXIgT3ZlcnZpZXcKClRoaXMgdmlldyBsaXN0cyB0aGUgbmFtZXNwYWNlcyBhbmQgdGhlIG5vZGVzIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiB0aGUgY3VycmVudCBjbHVzdGVyLgoKJycnCmltcG9ydCBweAoKCiMgRmxhZyB0byBmaWx0ZXIgb3V0IGhlYWx0aCBjaGVja3MgZnJvbSB0aGUgZGF0YS4KZmlsdGVyX2hlYWx0aF9jaGVja3MgPSBUcnVlCgojIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdHJhZmZpYyBmcm9tIElQcyB0aGF0IGRvbid0IHJlc29sdmUgdG8gYSBrbm93biBwb2Qvc2VydmljZS4KaW5jbHVkZV9pcHMgPSBUcnVlCgoKIyBIYWNrIHRvIGdldCB0aGUgdGltZSB3aW5kb3cgZm9yIHRoZSBzY3JpcHQuCiMgVE9ETyhwaGlsa3V6KTogUmVwbGFjZSB0aGlzIHdpdGggYSBidWlsdC1pbi4KZGVmIGdldF90aW1lX3dpbmRvdyhzdGFydF90aW1lOiBzdHIpOgogICAgJycnIENvbnZlcnRzIHRoZSBzdGFydF90aW1lIHN0cmluZyBpbnRvIGEgdGFibGUgd2l0aCBhIHNpbmdsZSBjb2x1bW4gYW5kIHNpbmdsZSByb3cuCiAgICBUaGUgYXBwcm9hY2ggaXMgaGFja3ksIGFuZCB3aWxsIHJvdW5kIHRvIHJvdWdobHkgMSBzZWNvbmQuCiAgICAnJycKICAgIGRmID0gcHguRGF0YUZyYW1lKCdwcm9jZXNzX3N0YXRzJywgc3RhcnRfdGltZT1zdGFydF90aW1lKQoKICAgIGRmID0gZGYuYWdnKAogICAgICAgIHRpbWVfbWluPSgndGltZV8nLCBweC5taW4pLAogICAgICAgIHRpbWVfbWF4PSgndGltZV8nLCBweC5tYXgpLAogICAgKQoKICAgIGRmLndpbmRvdyA9IHB4LkR1cmF0aW9uTmFub3MoZGYudGltZV9tYXggLSBkZi50aW1lX21pbikKICAgIGRmID0gZGZbWyd3aW5kb3cnXV0KCiAgICByZXR1cm4gZGYKCgpkZWYgYWRkX3RpbWVfd2luZG93X2NvbHVtbihkZiwgc3RhcnRfdGltZSk6CiAgICB0dyA9IGdldF90aW1lX3dpbmRvdyhzdGFydF90aW1lKQogICAgZGYgPSBkZi5tZXJnZSh0dywgaG93PSdpbm5lcicsIGxlZnRfb249W10sIHJpZ2h0X29uPVtdKQogICAgcmV0dXJuIGRmCgoKZGVmIHByb2Nlc3Nfc3RhdHNfYnlfZW50aXR5KHN0YXJ0X3RpbWU6IHN0ciwgZW50aXR5OiBzdHIpOgogICAgJycnIEdldHMgdGhlIHdpbmRvd2VkIHByb2Nlc3Mgc3RhdHMgKENQVSwgbWVtb3J5LCBldGMpIHBlciBub2RlIG9yIHBvZC4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZSBTdGFydGluZyB0aW1lIG9mIHRoZSBkYXRhIHRvIGV4YW1pbmUuCiAgICBAZW50aXR5OiBFaXRoZXIgcG9kIG9yIG5vZGVfbmFtZS4KICAgICcnJwogICAgIyBXaW5kb3cgc2l6ZSB0byB1c2Ugb24gdGltZV8gY29sdW1uIGZvciBidWNrZXRpbmcuCiAgICBuc19wZXJfcyA9IDEwMDAgKiAxMDAwICogMTAwMAogICAgd2luZG93X25zID0gcHguRHVyYXRpb25OYW5vcygxMCAqIG5zX3Blcl9zKQoKICAgIGRmID0gcHguRGF0YUZyYW1lKHRhYmxlPSdwcm9jZXNzX3N0YXRzJywgc3RhcnRfdGltZT1zdGFydF90aW1lKQogICAgZGZbZW50aXR5XSA9IGRmLmN0eFtlbnRpdHldCiAgICBkZi50aW1lc3RhbXAgPSBweC5iaW4oZGYudGltZV8sIHdpbmRvd19ucykKICAgICMgRmlyc3QgY2FsY3VsYXRlIENQVSB1c2FnZSBieSBwcm9jZXNzIChVUElEKSBpbiBlYWNoIGs4c19vYmplY3QKICAgICMgb3ZlciBhbGwgd2luZG93cy4KICAgIGRmID0gZGYuZ3JvdXBieShbZW50aXR5LCAndXBpZCcsICd0aW1lc3RhbXAnXSkuYWdnKAogICAgICAgIHJzcz0oJ3Jzc19ieXRlcycsIHB4Lm1lYW4pLAogICAgICAgIHZzaXplPSgndnNpemVfYnl0ZXMnLCBweC5tZWFuKSwKICAgICAgICAjIFRoZSBmaWVsZHMgYmVsb3cgYXJlIGNvdW50ZXJzLCBzbyB3ZSB0YWtlIHRoZSBtaW4gYW5kIHRoZSBtYXggdG8gc3VidHJhY3QgdGhlbS4KICAgICAgICBjcHVfdXRpbWVfbnNfbWF4PSgnY3B1X3V0aW1lX25zJywgcHgubWF4KSwKICAgICAgICBjcHVfdXRpbWVfbnNfbWluPSgnY3B1X3V0aW1lX25zJywgcHgubWluKSwKICAgICAgICBjcHVfa3RpbWVfbnNfbWF4PSgnY3B1X2t0aW1lX25zJywgcHgubWF4KSwKICAgICAgICBjcHVfa3RpbWVfbnNfbWluPSgnY3B1X2t0aW1lX25zJywgcHgubWluKSwKICAgICAgICByZWFkX2J5dGVzX21heD0oJ3JlYWRfYnl0ZXMnLCBweC5tYXgpLAogICAgICAgIHJlYWRfYnl0ZXNfbWluPSgncmVhZF9ieXRlcycsIHB4Lm1pbiksCiAgICAgICAgd3JpdGVfYnl0ZXNfbWF4PSgnd3JpdGVfYnl0ZXMnLCBweC5tYXgpLAogICAgICAgIHdyaXRlX2J5dGVzX21pbj0oJ3dyaXRlX2J5dGVzJywgcHgubWluKSwKICAgICAgICByY2hhcl9ieXRlc19tYXg9KCdyY2hhcl9ieXRlcycsIHB4Lm1heCksCiAgICAgICAgcmNoYXJfYnl0ZXNfbWluPSgncmNoYXJfYnl0ZXMnLCBweC5taW4pLAogICAgICAgIHdjaGFyX2J5dGVzX21heD0oJ3djaGFyX2J5dGVzJywgcHgubWF4KSwKICAgICAgICB3Y2hhcl9ieXRlc19taW49KCd3Y2hhcl9ieXRlcycsIHB4Lm1pbiksCiAgICApCiAgICAjIE5leHQgY2FsY3VsYXRlIGNwdSB1c2FnZSBhbmQgbWVtb3J5IHN0YXRzIHBlciB3aW5kb3cuCiAgICBkZi5jcHVfdXRpbWVfbnMgPSBkZi5jcHVfdXRpbWVfbnNfbWF4IC0gZGYuY3B1X3V0aW1lX25zX21pbgogICAgZGYuY3B1X2t0aW1lX25zID0gZGYuY3B1X2t0aW1lX25zX21heCAtIGRmLmNwdV9rdGltZV9uc19taW4KICAgIGRmLnJlYWRfYnl0ZXMgPSBkZi5yZWFkX2J5dGVzX21heCAtIGRmLnJlYWRfYnl0ZXNfbWluCiAgICBkZi53cml0ZV9ieXRlcyA9IGRmLndyaXRlX2J5dGVzX21heCAtIGRmLndyaXRlX2J5dGVzX21pbgogICAgZGYucmNoYXJfYnl0ZXMgPSBkZi5yY2hhcl9ieXRlc19tYXggLSBkZi5yY2hhcl9ieXRlc19taW4KICAgIGRmLndjaGFyX2J5dGVzID0gZGYud2NoYXJfYnl0ZXNfbWF4IC0gZGYud2NoYXJfYnl0ZXNfbWluCiAgICAjIFN1bSBieSBVUElELgogICAgZGYgPSBkZi5ncm91cGJ5KFtlbnRpdHksICd0aW1lc3RhbXAnXSkuYWdnKAogICAgICAgIGNwdV9rdGltZV9ucz0oJ2NwdV9rdGltZV9ucycsIHB4LnN1bSksCiAgICAgICAgY3B1X3V0aW1lX25zPSgnY3B1X3V0aW1lX25zJywgcHguc3VtKSwKICAgICAgICByZWFkX2J5dGVzPSgncmVhZF9ieXRlcycsIHB4LnN1bSksCiAgICAgICAgd3JpdGVfYnl0ZXM9KCd3cml0ZV9ieXRlcycsIHB4LnN1bSksCiAgICAgICAgcmNoYXJfYnl0ZXM9KCdyY2hhcl9ieXRlcycsIHB4LnN1bSksCiAgICAgICAgd2NoYXJfYnl0ZXM9KCd3Y2hhcl9ieXRlcycsIHB4LnN1bSksCiAgICAgICAgcnNzPSgncnNzJywgcHguc3VtKSwKICAgICAgICB2c2l6ZT0oJ3ZzaXplJywgcHguc3VtKSwKICAgICkKICAgIGRmLmFjdHVhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dCA9IGRmLnJlYWRfYnl0ZXMgLyB3aW5kb3dfbnMKICAgIGRmLmFjdHVhbF9kaXNrX3dyaXRlX3Rocm91Z2hwdXQgPSBkZi53cml0ZV9ieXRlcyAvIHdpbmRvd19ucwogICAgZGYudG90YWxfZGlza19yZWFkX3Rocm91Z2hwdXQgPSBkZi5yY2hhcl9ieXRlcyAvIHdpbmRvd19ucwogICAgZGYudG90YWxfZGlza193cml0ZV90aHJvdWdocHV0ID0gZGYud2NoYXJfYnl0ZXMgLyB3aW5kb3dfbnMKICAgICMgTm93IHRha2UgdGhlIG1lYW4gdmFsdWUgb3ZlciB0aGUgdmFyaW91cyB0aW1lc3RhbXBzLgogICAgZGYgPSBkZi5ncm91cGJ5KGVudGl0eSkuYWdnKAogICAgICAgIGNwdV9rdGltZV9ucz0oJ2NwdV9rdGltZV9ucycsIHB4Lm1lYW4pLAogICAgICAgIGNwdV91dGltZV9ucz0oJ2NwdV91dGltZV9ucycsIHB4Lm1lYW4pLAogICAgICAgIGFjdHVhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dD0oJ2FjdHVhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dCcsIHB4Lm1lYW4pLAogICAgICAgIGFjdHVhbF9kaXNrX3dyaXRlX3Rocm91Z2hwdXQ9KCdhY3R1YWxfZGlza193cml0ZV90aHJvdWdocHV0JywgcHgubWVhbiksCiAgICAgICAgdG90YWxfZGlza19yZWFkX3Rocm91Z2hwdXQ9KCd0b3RhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dCcsIHB4Lm1lYW4pLAogICAgICAgIHRvdGFsX2Rpc2tfd3JpdGVfdGhyb3VnaHB1dD0oJ3RvdGFsX2Rpc2tfd3JpdGVfdGhyb3VnaHB1dCcsIHB4Lm1lYW4pLAogICAgICAgIGF2Z19yc3M9KCdyc3MnLCBweC5tZWFuKSwKICAgICAgICBhdmdfdnNpemU9KCd2c2l6ZScsIHB4Lm1lYW4pLAogICAgKQogICAgIyBGaW5hbGx5LCBjYWxjdWxhdGUgdG90YWwgKGtlcm5lbCArIHVzZXIgdGltZSkgIHBlcmNlbnRhZ2UgdXNlZCBvdmVyIHdpbmRvdy4KICAgIGRmLmNwdV91c2FnZSA9IHB4LlBlcmNlbnQoKGRmLmNwdV9rdGltZV9ucyArIGRmLmNwdV91dGltZV9ucykgLyB3aW5kb3dfbnMpCiAgICByZXR1cm4gZGYuZHJvcChbJ2NwdV9rdGltZV9ucycsICdjcHVfdXRpbWVfbnMnXSkKCgpkZWYgbm9kZXNfZm9yX2NsdXN0ZXIoc3RhcnRfdGltZTogc3RyKToKICAgICcnJyBHZXRzIGEgbGlzdCBvZiBub2RlcyBpbiB0aGUgY3VycmVudCBjbHVzdGVyIHNpbmNlIGBzdGFydF90aW1lYC4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZSBTdGFydCB0aW1lIG9mIHRoZSBkYXRhIHRvIGV4YW1pbmUuCiAgICAnJycKICAgIGRmID0gcHguRGF0YUZyYW1lKHRhYmxlPSdwcm9jZXNzX3N0YXRzJywgc3RhcnRfdGltZT1zdGFydF90aW1lKQogICAgZGYubm9kZSA9IGRmLmN0eFsnbm9kZV9uYW1lJ10KICAgIGRmLnBvZCA9IGRmLmN0eFsncG9kX25hbWUnXQogICAgYWdnID0gZGYuZ3JvdXBieShbJ25vZGUnLCAncG9kJ10pLmFnZygpCiAgICBub2RlcyA9IGFnZy5ncm91cGJ5KCdub2RlJykuYWdnKHBvZF9jb3VudD0oJ3BvZCcsIHB4LmNvdW50KSkKICAgIHByb2Nlc3Nfc3RhdHMgPSBwcm9jZXNzX3N0YXRzX2J5X2VudGl0eShzdGFydF90aW1lLCAnbm9kZScpCiAgICBvdXRwdXQgPSBwcm9jZXNzX3N0YXRzLm1lcmdlKG5vZGVzLCBob3c9J2lubmVyJywgbGVmdF9vbj0nbm9kZScsIHJpZ2h0X29uPSdub2RlJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ZXM9WycnLCAnX3gnXSkKICAgIHJldHVybiBvdXRwdXRbWydub2RlJywgJ2NwdV91c2FnZScsICdwb2RfY291bnQnXV0KCgpkZWYgcG9kc19mb3JfY2x1c3RlcihzdGFydF90aW1lOiBzdHIpOgogICAgJycnIEEgbGlzdCBvZiBwb2RzIGluIGBuYW1lc3BhY2VgLgogICAgQXJnczoKICAgIEBzdGFydF90aW1lOiBUaGUgdGltZXN0YW1wIG9mIGRhdGEgdG8gc3RhcnQgYXQuCiAgICBAbmFtZXNwYWNlOiBUaGUgbmFtZSBvZiB0aGUgbmFtZXNwYWNlIHRvIGZpbHRlciBvbi4KICAgICcnJwogICAgZGYgPSBweC5EYXRhRnJhbWUodGFibGU9J3Byb2Nlc3Nfc3RhdHMnLCBzdGFydF90aW1lPXN0YXJ0X3RpbWUpCiAgICBkZi5wb2QgPSBkZi5jdHhbJ3BvZF9uYW1lJ10KICAgIGRmLm5vZGUgPSBkZi5jdHhbJ25vZGVfbmFtZSddCiAgICBkZi5jb250YWluZXIgPSBkZi5jdHhbJ2NvbnRhaW5lcl9uYW1lJ10KICAgIGRmID0gZGYuZ3JvdXBieShbJ3BvZCcsICdub2RlJywgJ2NvbnRhaW5lciddKS5hZ2coKQogICAgZGYgPSBkZi5ncm91cGJ5KFsncG9kJywgJ25vZGUnXSkuYWdnKGNvbnRhaW5lcl9jb3VudD0oJ2NvbnRhaW5lcicsIHB4LmNvdW50KSkKICAgIGRmLnN0YXJ0X3RpbWUgPSBweC5wb2RfbmFtZV90b19zdGFydF90aW1lKGRmLnBvZCkKICAgIGRmLnN0YXR1cyA9IHB4LnBvZF9uYW1lX3RvX3N0YXR1cyhkZi5wb2QpCiAgICBwcm9jZXNzX3N0YXRzID0gcHJvY2Vzc19zdGF0c19ieV9lbnRpdHkoc3RhcnRfdGltZSwgJ3BvZCcpCiAgICBvdXRwdXQgPSBwcm9jZXNzX3N0YXRzLm1lcmdlKGRmLCBob3c9J2lubmVyJywgbGVmdF9vbj0ncG9kJywgcmlnaHRfb249J3BvZCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeGVzPVsnJywgJ194J10pCiAgICByZXR1cm4gb3V0cHV0W1sncG9kJywgJ2NwdV91c2FnZScsICd0b3RhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dCcsCiAgICAgICAgICAgICAgICAgICAndG90YWxfZGlza193cml0ZV90aHJvdWdocHV0JywgJ2NvbnRhaW5lcl9jb3VudCcsCiAgICAgICAgICAgICAgICAgICAnbm9kZScsICdzdGFydF90aW1lJywgJ3N0YXR1cyddXQoKCmRlZiBuYW1lc3BhY2VzX2Zvcl9jbHVzdGVyKHN0YXJ0X3RpbWU6IHN0cik6CiAgICAnJycgR2V0cyBhIG92ZXJ2aWV3IG9mIG5hbWVzcGFjZXMgaW4gdGhlIGN1cnJlbnQgY2x1c3RlciBzaW5jZSBgc3RhcnRfdGltZWAuCiAgICBBcmdzOgogICAgQHN0YXJ0X3RpbWUgU3RhcnQgdGltZSBvZiB0aGUgZGF0YSB0byBleGFtaW5lLgogICAgJycnCiAgICBkZiA9IHB4LkRhdGFGcmFtZSh0YWJsZT0ncHJvY2Vzc19zdGF0cycsIHN0YXJ0X3RpbWU9c3RhcnRfdGltZSkKICAgIGRmLnNlcnZpY2UgPSBkZi5jdHhbJ3NlcnZpY2VfbmFtZSddCiAgICBkZi5wb2QgPSBkZi5jdHhbJ3BvZF9uYW1lJ10KICAgIGRmLm5hbWVzcGFjZSA9IGRmLmN0eFsnbmFtZXNwYWNlJ10KICAgIGFnZyA9IGRmLmdyb3VwYnkoWydzZXJ2aWNlJywgJ3BvZCcsICduYW1lc3BhY2UnXSkuYWdnKCkKICAgIHBvZF9jb3VudCA9IGFnZy5ncm91cGJ5KFsnbmFtZXNwYWNlJywgJ3BvZCddKS5hZ2coKQogICAgcG9kX2NvdW50ID0gcG9kX2NvdW50Lmdyb3VwYnkoJ25hbWVzcGFjZScpLmFnZyhwb2RfY291bnQ9KCdwb2QnLCBweC5jb3VudCkpCiAgICBzdmNfY291bnQgPSBhZ2cuZ3JvdXBieShbJ25hbWVzcGFjZScsICdzZXJ2aWNlJ10pLmFnZygpCiAgICBzdmNfY291bnQgPSBzdmNfY291bnQuZ3JvdXBieSgnbmFtZXNwYWNlJykuYWdnKHNlcnZpY2VfY291bnQ9KCdzZXJ2aWNlJywgcHguY291bnQpKQogICAgcG9kX2FuZF9zdmNfY291bnQgPSBwb2RfY291bnQubWVyZ2Uoc3ZjX2NvdW50LCBob3c9J2lubmVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRfb249J25hbWVzcGFjZScsIHJpZ2h0X29uPSduYW1lc3BhY2UnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ZXM9WycnLCAnX3gnXSkKICAgIHByb2Nlc3Nfc3RhdHMgPSBwcm9jZXNzX3N0YXRzX2J5X2VudGl0eShzdGFydF90aW1lLCAnbmFtZXNwYWNlJykKICAgIG91dHB1dCA9IHByb2Nlc3Nfc3RhdHMubWVyZ2UocG9kX2FuZF9zdmNfY291bnQsIGhvdz0naW5uZXInLCBsZWZ0X29uPSduYW1lc3BhY2UnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodF9vbj0nbmFtZXNwYWNlJywgc3VmZml4ZXM9WycnLCAnX3knXSkKICAgIHJldHVybiBvdXRwdXRbWyduYW1lc3BhY2UnLCAncG9kX2NvdW50JywgJ3NlcnZpY2VfY291bnQnLCAnYXZnX3ZzaXplJywgJ2F2Z19yc3MnXV0KCgpkZWYgc2VydmljZXNfZm9yX2NsdXN0ZXIoc3RhcnRfdGltZTogc3RyKToKICAgICcnJyBHZXQgYW4gb3ZlcnZpZXcgb2YgdGhlIHNlcnZpY2VzIGluIHRoZSBjdXJyZW50IGNsdXN0ZXIuCiAgICBBcmdzOgogICAgQHN0YXJ0X3RpbWU6IFRoZSB0aW1lc3RhbXAgb2YgZGF0YSB0byBzdGFydCBhdC4KICAgICcnJwogICAgZGYgPSBweC5EYXRhRnJhbWUodGFibGU9J3Byb2Nlc3Nfc3RhdHMnLCBzdGFydF90aW1lPXN0YXJ0X3RpbWUpCiAgICBkZi5zZXJ2aWNlID0gZGYuY3R4WydzZXJ2aWNlJ10KICAgIGRmID0gZGZbZGYuc2VydmljZSAhPSAnJ10KICAgIGRmLnBvZCA9IGRmLmN0eFsncG9kJ10KICAgIGRmID0gZGYuZ3JvdXBieShbJ3NlcnZpY2UnLCAncG9kJ10pLmFnZygpCiAgICBkZiA9IGRmLmdyb3VwYnkoJ3NlcnZpY2UnKS5hZ2cocG9kX2NvdW50PSgncG9kJywgcHguY291bnQpKQogICAgc2VydmljZV9sZXQgPSBzZXJ2aWNlX2xldF9zdW1tYXJ5KHN0YXJ0X3RpbWUpCiAgICBqb2luZWQgPSBkZi5tZXJnZShzZXJ2aWNlX2xldCwgaG93PSdsZWZ0JywgbGVmdF9vbj0nc2VydmljZScsIHJpZ2h0X29uPSdzZXJ2aWNlJywKICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeGVzPVsnJywgJ194J10pCiAgICByZXR1cm4gam9pbmVkLmRyb3AoJ3NlcnZpY2VfeCcpCgoKZGVmIGh0dHBfc3RhdHMoc3RhcnRfdGltZTogc3RyKToKICAgICcnJyBHZXQgYSBkYXRhZnJhbWUgb2YgSFRUUCBldmVudHMuCiAgICBDZXJ0YWluIHRyYWZmaWMgKGxpa2UgaGVhbHRoIGNoZWNrcykgYXJlIGF1dG8gcmVtb3ZlZCwgYW5kIHNvbWUgc3RhbmRhcmQgZmllbGRzIGFyZSBhZGRlZC4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZTogVGhlIHRpbWVzdGFtcCBvZiBkYXRhIHRvIHN0YXJ0IGF0LgogICAgJycnCiAgICBkZiA9IHB4LkRhdGFGcmFtZSh0YWJsZT0naHR0cF9ldmVudHMnLCBzdGFydF90aW1lPXN0YXJ0X3RpbWUpCgogICAgIyBBZGQgSzhzIG1ldGFkYXRhLgogICAgZGYuc2VydmljZSA9IGRmLmN0eFsnc2VydmljZSddCiAgICBkZi5wb2QgPSBkZi5jdHhbJ3BvZCddCgogICAgIyBGaWx0ZXIgb3V0IG5vbi1rOHMgZW50aXRpZXMuCiAgICBkZiA9IGRmW2RmLnBvZCAhPSAnJ10KCiAgICAjIEFkZGl0aW9uYWwgSFRUUCBmaWVsZHMsIHByZS1jb21wdXRlZCBmb3IgY29udmVuaWVuY2UuCiAgICBkZi5mYWlsdXJlID0gZGYucmVzcF9zdGF0dXMgPj0gNDAwCgogICAgIyBSZW1vdmUgaGVhbHRoIGNoZWNrcywgYW5kIGFueXRoaW5nIHdpdGggbm8gcmVtb3RlIGFkZHJlc3MuCiAgICBoZWFsdGhfY2hlY2tfcmVxID0gKChkZi5yZXFfcGF0aCA9PSAnL2hlYWx0aHonIG9yIGRmLnJlcV9wYXRoID09ICcvcmVhZHl6Jykgb3IgZGYucmVxX3BhdGggPT0gJy9saXZleicpCiAgICBmaWx0ZXJfb3V0X2NvbmRzID0gKGhlYWx0aF9jaGVja19yZXEgYW5kIGZpbHRlcl9oZWFsdGhfY2hlY2tzKSBvciAoZGZbJ3JlbW90ZV9hZGRyJ10gPT0gJy0nKQogICAgZGYgPSBkZltub3QgZmlsdGVyX291dF9jb25kc10KCiAgICByZXR1cm4gZGYKCgpkZWYgaHR0cF9zdGF0c19ieV9zZXJ2aWNlKHN0YXJ0X3RpbWU6IHN0cik6CiAgICAnJycgR2V0IGEgZGF0YSBmcmFtZSBvZiBIVFRQIHN0YXRzIHBlciBzZXJ2aWNlLiBUaGUgSFRUUCBzdGF0cyBhcmUgZm9yIGluYm91bmQgdHJhZmZpYywKICAgIGFuZCBpbmNsdWRlcyBIVFRQIHJlcXVlc3QgY291bnQsIGVycm9yIGNvdW50IGFuZCBsYXRlbmN5IHF1YW50aWxlcy4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZTogVGhlIHRpbWVzdGFtcCBvZiBkYXRhIHRvIHN0YXJ0IGF0LgogICAgJycnCiAgICBkZiA9IGh0dHBfc3RhdHMoc3RhcnRfdGltZSkKCiAgICAjIEZpbHRlciBvbmx5IHRvIGluYm91bmQgc2VydmljZSB0cmFmZmljIChzZXJ2ZXItc2lkZSkuCiAgICAjIERvbid0IGluY2x1ZGUgdHJhZmZpYyBpbml0aWF0ZWQgYnkgdGhpcyBzZXJ2aWNlIHRvIGFuIGV4dGVybmFsIGxvY2F0aW9uLgogICAgZGYgPSBkZltkZi50cmFjZV9yb2xlID09IDJdCgogICAgIyBDb21wdXRlIEhUVFAgbWV0cmljcy4KICAgIGRmID0gZGYuZ3JvdXBieShbJ3NlcnZpY2UnXSkuYWdnKAogICAgICAgIGh0dHBfcmVxX2NvdW50X2luPSgnbGF0ZW5jeScsIHB4LmNvdW50KSwKICAgICAgICBodHRwX2Vycm9yX2NvdW50X2luPSgnZmFpbHVyZScsIHB4LnN1bSksCiAgICAgICAgaHR0cF9sYXRlbmN5X2luPSgnbGF0ZW5jeScsIHB4LnF1YW50aWxlcykKICAgICkKCiAgICByZXR1cm4gZGYKCgpkZWYgY29ubl9zdGF0cyhzdGFydF90aW1lOiBzdHIpOgogICAgJycnIEdldCBhIGRhdGFmcmFtZSBvZiBjb25uZWN0aW9uIHN0YXRzLgogICAgRm9yIGVhY2ggY2xpZW50LXNlcnZlciBwYWlyLCB0aGUgcmVzdWx0aW5nIGRhdGEgZnJhbWUgaGFzIHRoZSBieXRlcyBzZW50IGFuZCByZWNlaXZlZC4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZTogVGhlIHRpbWVzdGFtcCBvZiBkYXRhIHRvIHN0YXJ0IGF0LgogICAgJycnCiAgICBkZiA9IHB4LkRhdGFGcmFtZSh0YWJsZT0nY29ubl9zdGF0cycsIHN0YXJ0X3RpbWU9c3RhcnRfdGltZSkKCiAgICBkZi5wb2QgPSBkZi5jdHhbJ3BvZCddCiAgICBkZi5zZXJ2aWNlID0gZGYuY3R4WydzZXJ2aWNlJ10KCiAgICBkZiA9IGRmW2RmLnNlcnZpY2UgIT0gJyddCgogICAgIyBGaW5kIG1pbi9tYXggYnl0ZXMgdHJhbnNmZXJyZWQgb3ZlciB0aGUgc2VsZWN0ZWQgdGltZSB3aW5kb3cgcGVyIHBvZC4KICAgIGRmID0gZGYuZ3JvdXBieShbJ3VwaWQnLCAncmVtb3RlX2FkZHInLCAncmVtb3RlX3BvcnQnLCAncG9kJywgJ3NlcnZpY2UnLCAndHJhY2Vfcm9sZSddKS5hZ2coCiAgICAgICAgYnl0ZXNfcmVjdl9taW49KCdieXRlc19yZWN2JywgcHgubWluKSwKICAgICAgICBieXRlc19yZWN2X21heD0oJ2J5dGVzX3JlY3YnLCBweC5tYXgpLAogICAgICAgIGJ5dGVzX3NlbnRfbWluPSgnYnl0ZXNfc2VudCcsIHB4Lm1pbiksCiAgICAgICAgYnl0ZXNfc2VudF9tYXg9KCdieXRlc19zZW50JywgcHgubWF4KSwKICAgICkKCiAgICAjIENhbGN1bGF0ZSBieXRlcyB0cmFuc2ZlcnJlZCBvdmVyIHRoZSB0aW1lIHdpbmRvdwogICAgZGYuYnl0ZXNfc2VudCA9IGRmLmJ5dGVzX3NlbnRfbWF4IC0gZGYuYnl0ZXNfc2VudF9taW4KICAgIGRmLmJ5dGVzX3JlY3YgPSBkZi5ieXRlc19yZWN2X21heCAtIGRmLmJ5dGVzX3JlY3ZfbWluCiAgICBkZiA9IGRmLmRyb3AoWydieXRlc19yZWN2X21pbicsICdieXRlc19yZWN2X21heCcsICdieXRlc19zZW50X21pbicsICdieXRlc19zZW50X21heCddKQoKICAgIHJldHVybiBkZgoKCmRlZiBjb25uX3N0YXRzX2J5X3NlcnZpY2Uoc3RhcnRfdGltZTogc3RyKToKICAgICcnJyBHZXQgYSBkYXRhZnJhbWUgb2YgY29ubmVjdGlvbiBzdGF0cyBhZ2dyZWdhdGVkIGJ5IHNlcnZpY2UuCiAgICBGb3IgZWFjaCBzZXJ2aWNlLCB0aGUgcmVzdWx0aW5nIGRhdGEgZnJhbWUgY29udGFpbnMgcngvdHggc3RhdHMgZm9yIHNlcnZlci1zaWRlIGFuZCBjbGllbnQtc2lkZSBjb25uZWN0aW9ucy4KICAgIEFyZ3M6CiAgICBAc3RhcnRfdGltZTogVGhlIHRpbWVzdGFtcCBvZiBkYXRhIHRvIHN0YXJ0IGF0LgogICAgJycnCiAgICBkZiA9IGNvbm5fc3RhdHMoc3RhcnRfdGltZSkKCiAgICAjIEdyb3VwIGJ5IHNlcnZpY2UgYW5kIHRyYWNlIHJvbGUuCiAgICAjIERvIHRoaXMgYWZ0ZXIgY29tcHV0aW5nIGJ5dGVzIHNlbnQvcmVjZWl2ZWQgYnkgY29ubl9zdGF0cyBrZXkgKHt1cGlkLCByZW1vdGVfYWRkciwgcmVtb3RlX3BvcnR9KS4KICAgICMgS2VlcGluZyB0cmFjZV9yb2xlIGFsbG93cyB1cyB0byBzZWUgd2hpY2ggdHJhZmZpYyB3YXMgcGFydCBvZiBzZXJ2ZXIgZHV0aWVzIHZzIGNsaWVudCBkdXRpZXMuCiAgICBkZiA9IGRmLmdyb3VwYnkoWydzZXJ2aWNlJywgJ3RyYWNlX3JvbGUnXSkuYWdnKAogICAgICAgIGJ5dGVzX3JlY3Y9KCdieXRlc19yZWN2JywgcHguc3VtKSwKICAgICAgICBieXRlc19zZW50PSgnYnl0ZXNfc2VudCcsIHB4LnN1bSksCiAgICApCgogICAgIyBHZXQgUlgvVFggc3RhdHMgZm9yIHRoZSBzZXJ2ZXIgc2lkZSBjb25uZWN0aW9ucy4KICAgIHNlcnZlcl9kZiA9IGRmW2RmLnRyYWNlX3JvbGUgPT0gMl0KICAgIHNlcnZlcl9kZi5yeF9zZXJ2ZXIgPSBzZXJ2ZXJfZGYuYnl0ZXNfcmVjdgogICAgc2VydmVyX2RmLnR4X3NlcnZlciA9IHNlcnZlcl9kZi5ieXRlc19zZW50CiAgICBzZXJ2ZXJfZGYgPSBzZXJ2ZXJfZGZbWydzZXJ2aWNlJywgJ3J4X3NlcnZlcicsICd0eF9zZXJ2ZXInXV0KCiAgICAjIEdldCBSWC9UWCBzdGF0cyBmb3IgdGhlIGNsaWVudCBzaWRlIGNvbm5lY3Rpb25zLgogICAgY2xpZW50X2RmID0gZGZbZGYudHJhY2Vfcm9sZSA9PSAxXQogICAgY2xpZW50X2RmLnJ4X2NsaWVudCA9IGNsaWVudF9kZi5ieXRlc19yZWN2CiAgICBjbGllbnRfZGYudHhfY2xpZW50ID0gY2xpZW50X2RmLmJ5dGVzX3NlbnQKICAgIGNsaWVudF9kZiA9IGNsaWVudF9kZltbJ3NlcnZpY2UnLCAncnhfY2xpZW50JywgJ3R4X2NsaWVudCddXQoKICAgICMgQ3JlYXRlIGEgZGF0YWZyYW1lIHRoYXQgY29udGFpbnMgYm90aCBzZXJ2ZXItc2lkZSBhbmQgY2xpZW50LXNpZGUgUlgvVFggc3RhdHMuCiAgICBkZiA9IHNlcnZlcl9kZi5tZXJnZShjbGllbnRfZGYsCiAgICAgICAgICAgICAgICAgICAgICAgICBob3c9J2xlZnQnLAogICAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9vbj0nc2VydmljZScsCiAgICAgICAgICAgICAgICAgICAgICAgICByaWdodF9vbj0nc2VydmljZScsCiAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXhlcz1bJycsICdfeCddKQogICAgZGYgPSBkZlsnc2VydmljZScsICdyeF9zZXJ2ZXInLCAndHhfc2VydmVyJywgJ3J4X2NsaWVudCcsICd0eF9jbGllbnQnXQoKICAgIHJldHVybiBkZgoKCmRlZiBzZXJ2aWNlX2xldF9zdW1tYXJ5KHN0YXJ0X3RpbWU6IHN0cik6CiAgICAnJycgQ29tcHV0ZSBhIHN1bW1hcnkgb2YgdHJhZmZpYyBieSByZXF1ZXN0aW5nIHNlcnZpY2UsIGZvciByZXF1ZXN0cwogICAgICAgIG9uIHNlcnZpY2VzIGluIHRoZSBjdXJyZW50IGNsdXN0ZXIuLgogICAgQXJnczoKICAgIEBzdGFydF90aW1lOiBUaGUgdGltZXN0YW1wIG9mIGRhdGEgdG8gc3RhcnQgYXQuCiAgICAnJycKICAgIGNvbm5fc3RhdHNfZGYgPSBjb25uX3N0YXRzX2J5X3NlcnZpY2Uoc3RhcnRfdGltZSkKICAgIGh0dHBfc3RhdHNfZGYgPSBodHRwX3N0YXRzX2J5X3NlcnZpY2Uoc3RhcnRfdGltZSkKCiAgICAjIE1lcmdlIGNvbm5fc3RhdHNfZGYgYW5kIGh0dHBfc3RhdHNfZGYuCiAgICBkZiA9IGNvbm5fc3RhdHNfZGYubWVyZ2UoaHR0cF9zdGF0c19kZiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3c9J2xlZnQnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRfb249J3NlcnZpY2UnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0X29uPSdzZXJ2aWNlJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXhlcz1bJycsICdfeCddKQoKICAgICMgQ29tcHV0ZSB0aW1lIHdpbmRvdyBmb3IgdGhlIHF1ZXJ5IGFuZCBhZGQgaXQgYXMgYSBjb2x1bW4uCiAgICBkZiA9IGFkZF90aW1lX3dpbmRvd19jb2x1bW4oZGYsIHN0YXJ0X3RpbWUpCgogICAgIyBDb21wdXRlIHRocm91Z2hwdXQgdmFsdWVzLgogICAgZGYuaHR0cF9yZXFfdGhyb3VnaHB1dF9pbiA9IGRmLmh0dHBfcmVxX2NvdW50X2luIC8gZGYud2luZG93CiAgICBkZi5odHRwX2Vycm9yX3JhdGVfaW4gPSBweC5QZXJjZW50KAogICAgICAgIHB4LnNlbGVjdChkZi5odHRwX3JlcV9jb3VudF9pbiAhPSAwLCBkZi5odHRwX2Vycm9yX2NvdW50X2luIC8gZGYuaHR0cF9yZXFfY291bnRfaW4sIDAuMCkpCiAgICBkZi5pbmJvdW5kX2Nvbm5zID0gKGRmLnJ4X3NlcnZlciArIGRmLnR4X3NlcnZlcikgLyBkZi53aW5kb3cKICAgIGRmLm91dGJvdW5kX2Nvbm5zID0gKGRmLnR4X2NsaWVudCArIGRmLnJ4X2NsaWVudCkgLyBkZi53aW5kb3cKCiAgICByZXR1cm4gZGZbWydzZXJ2aWNlJywgJ2h0dHBfbGF0ZW5jeV9pbicsICdodHRwX3JlcV90aHJvdWdocHV0X2luJywgJ2h0dHBfZXJyb3JfcmF0ZV9pbicsCiAgICAgICAgICAgICAgICdpbmJvdW5kX2Nvbm5zJywgJ291dGJvdW5kX2Nvbm5zJ11dCgoKZGVmIHNlcnZpY2VfbGV0X2dyYXBoKHN0YXJ0X3RpbWU6IHN0cik6CiAgICAnJycgQ29tcHV0ZSBhIHN1bW1hcnkgb2YgdHJhZmZpYyBieSByZXF1ZXN0aW5nIHNlcnZpY2UsIGZvciByZXF1ZXN0cyBvbiBzZXJ2aWNlcwogICAgICAgIGluIHRoZSBjdXJyZW50IGNsdXN0ZXIuIFNpbWlsYXIgdG8gYHNlcnZpY2VfbGV0X3N1bW1hcnlgIGJ1dCBhbHNvIGJyZWFrcyBkb3duCiAgICAgICAgYnkgcG9kIGluIGFkZGl0aW9uIHRvIHNlcnZpY2UuCiAgICBBcmdzOgogICAgQHN0YXJ0X3RpbWU6IFRoZSB0aW1lc3RhbXAgb2YgZGF0YSB0byBzdGFydCBhdC4KICAgICcnJwogICAgZGYgPSBodHRwX3N0YXRzKHN0YXJ0X3RpbWUpCiAgICBkZiA9IGRmLmdyb3VwYnkoWydzZXJ2aWNlJywgJ3JlbW90ZV9hZGRyJywgJ3BvZCcsICd0cmFjZV9yb2xlJ10pLmFnZygKICAgICAgICBodHRwX3JlcV9jb3VudF9pbj0oJ2xhdGVuY3knLCBweC5jb3VudCksCiAgICAgICAgaHR0cF9lcnJvcl9jb3VudF9pbj0oJ2ZhaWx1cmUnLCBweC5zdW0pLAogICAgICAgIGxhdGVuY3lfcXVhbnRpbGVzPSgnbGF0ZW5jeScsIHB4LnF1YW50aWxlcyksCiAgICAgICAgaW5ib3VuZF9ieXRlc190b3RhbD0oJ3JlcV9ib2R5X3NpemUnLCBweC5zdW0pLAogICAgICAgIG91dGJvdW5kX2J5dGVzX3RvdGFsPSgncmVzcF9ib2R5X3NpemUnLCBweC5zdW0pCiAgICApCgogICAgIyBHZXQgdGhlIHRyYWNlZCBhbmQgcmVtb3RlIHBvZC9zZXJ2aWNlL0lQIGluZm9ybWF0aW9uLgogICAgZGYudHJhY2VkX3BvZCA9IGRmLnBvZAogICAgZGYudHJhY2VkX3NlcnZpY2UgPSBkZi5zZXJ2aWNlCiAgICBkZi50cmFjZWRfaXAgPSBweC5wb2RfbmFtZV90b19wb2RfaXAoZGYucG9kKQogICAgZGYucmVtb3RlX3BvZCA9IHB4LnBvZF9pZF90b19wb2RfbmFtZShweC5pcF90b19wb2RfaWQoZGYucmVtb3RlX2FkZHIpKQogICAgZGYucmVtb3RlX3NlcnZpY2UgPSBweC5zZXJ2aWNlX2lkX3RvX3NlcnZpY2VfbmFtZShweC5pcF90b19zZXJ2aWNlX2lkKGRmLnJlbW90ZV9hZGRyKSkKICAgIGRmLnJlbW90ZV9pcCA9IGRmLnJlbW90ZV9hZGRyCiAgICAjIElmIGV4dGVybmFsIElQcyBhcmUgZXhjbHVkZWQgaW4gdGhlIHNlcnZpY2UgZ3JhcGgsIHRoZW4gd2UgYWxzbyBleGNsdWRlIGFueQogICAgIyB0cmFmZmljIHdoZXJlIHdlIGRvbid0IGtub3cgdGhlIHJlbW90ZSBwb2Qgb3IgcmVtb3RlIHNlcnZpY2UgbmFtZS4KICAgIGRmID0gZGZbaW5jbHVkZV9pcHMgb3IgKGRmLnJlbW90ZV9wb2QgIT0gJycgb3IgZGYucmVtb3RlX3NlcnZpY2UgIT0gJycpXQoKICAgICMgQXNzb2NpYXRlIGl0IHdpdGggQ2xpZW50L1NlcnZlciByb2xlcywgYmFzZWQgb24gdGhlIHRyYWNlIHJvbGUuCiAgICBkZi5pc19zZXJ2ZXJfc2lkZV90cmFjaW5nID0gZGYudHJhY2Vfcm9sZSA9PSAyCiAgICBkZi5yZXNwb25kZXJfcG9kID0gcHguc2VsZWN0KGRmLmlzX3NlcnZlcl9zaWRlX3RyYWNpbmcsIGRmLnRyYWNlZF9wb2QsIGRmLnJlbW90ZV9wb2QpCiAgICBkZi5yZXF1ZXN0b3JfcG9kID0gcHguc2VsZWN0KGRmLmlzX3NlcnZlcl9zaWRlX3RyYWNpbmcsIGRmLnJlbW90ZV9wb2QsIGRmLnRyYWNlZF9wb2QpCiAgICBkZi5yZXNwb25kZXJfc2VydmljZSA9IHB4LnNlbGVjdChkZi5pc19zZXJ2ZXJfc2lkZV90cmFjaW5nLCBkZi50cmFjZWRfc2VydmljZSwgZGYucmVtb3RlX3NlcnZpY2UpCiAgICBkZi5yZXF1ZXN0b3Jfc2VydmljZSA9IHB4LnNlbGVjdChkZi5pc19zZXJ2ZXJfc2lkZV90cmFjaW5nLCBkZi5yZW1vdGVfc2VydmljZSwgZGYudHJhY2VkX3NlcnZpY2UpCiAgICBkZi5yZXNwb25kZXJfaXAgPSBweC5zZWxlY3QoZGYuaXNfc2VydmVyX3NpZGVfdHJhY2luZywgZGYudHJhY2VkX2lwLCBkZi5yZW1vdGVfaXApCiAgICBkZi5yZXF1ZXN0b3JfaXAgPSBweC5zZWxlY3QoZGYuaXNfc2VydmVyX3NpZGVfdHJhY2luZywgZGYucmVtb3RlX2lwLCBkZi50cmFjZWRfaXApCgogICAgIyBDb21wdXRlIHN0YXRpc3RpY3MgYWJvdXQgZWFjaCBlZGdlIG9mIHRoZSBzZXJ2aWNlIGdyYXBoLgogICAgZGYubGF0ZW5jeV9wNTAgPSBweC5EdXJhdGlvbk5hbm9zKHB4LmZsb29yKHB4LnBsdWNrX2Zsb2F0NjQoZGYubGF0ZW5jeV9xdWFudGlsZXMsICdwNTAnKSkpCiAgICBkZi5sYXRlbmN5X3A5MCA9IHB4LkR1cmF0aW9uTmFub3MocHguZmxvb3IocHgucGx1Y2tfZmxvYXQ2NChkZi5sYXRlbmN5X3F1YW50aWxlcywgJ3A5MCcpKSkKICAgIGRmLmxhdGVuY3lfcDk5ID0gcHguRHVyYXRpb25OYW5vcyhweC5mbG9vcihweC5wbHVja19mbG9hdDY0KGRmLmxhdGVuY3lfcXVhbnRpbGVzLCAncDk5JykpKQogICAgZGYgPSBhZGRfdGltZV93aW5kb3dfY29sdW1uKGRmLCBzdGFydF90aW1lKQogICAgZGYucmVxdWVzdF90aHJvdWdocHV0ID0gZGYuaHR0cF9yZXFfY291bnRfaW4gLyBkZi53aW5kb3cKICAgIGRmLmluYm91bmRfdGhyb3VnaHB1dCA9IGRmLmluYm91bmRfYnl0ZXNfdG90YWwgLyBkZi53aW5kb3cKICAgIGRmLm91dGJvdW5kX3Rocm91Z2hwdXQgPSBkZi5vdXRib3VuZF9ieXRlc190b3RhbCAvIGRmLndpbmRvdwogICAgZGYuZXJyb3JfcmF0ZSA9IHB4LlBlcmNlbnQoZGYuaHR0cF9lcnJvcl9jb3VudF9pbiAvIGRmLmh0dHBfcmVxX2NvdW50X2luKQoKICAgIGRmID0gZGYuZ3JvdXBieShbJ3Jlc3BvbmRlcl9wb2QnLCAncmVxdWVzdG9yX3BvZCcsICdyZXNwb25kZXJfc2VydmljZScsCiAgICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0b3Jfc2VydmljZScsICdyZXNwb25kZXJfaXAnLCAncmVxdWVzdG9yX2lwJ10pLmFnZygKICAgICAgICBsYXRlbmN5X3A1MD0oJ2xhdGVuY3lfcDUwJywgcHgubWVhbiksCiAgICAgICAgbGF0ZW5jeV9wOTA9KCdsYXRlbmN5X3A5MCcsIHB4Lm1lYW4pLAogICAgICAgIGxhdGVuY3lfcDk5PSgnbGF0ZW5jeV9wOTknLCBweC5tZWFuKSwKICAgICAgICByZXF1ZXN0X3Rocm91Z2hwdXQ9KCdyZXF1ZXN0X3Rocm91Z2hwdXQnLCBweC5tZWFuKSwKICAgICAgICBlcnJvcl9yYXRlPSgnZXJyb3JfcmF0ZScsIHB4Lm1lYW4pLAogICAgICAgIGluYm91bmRfdGhyb3VnaHB1dD0oJ2luYm91bmRfdGhyb3VnaHB1dCcsIHB4Lm1lYW4pLAogICAgICAgIG91dGJvdW5kX3Rocm91Z2hwdXQ9KCdvdXRib3VuZF90aHJvdWdocHV0JywgcHgubWVhbiksCiAgICAgICAgdGhyb3VnaHB1dF90b3RhbD0oJ2h0dHBfcmVxX2NvdW50X2luJywgcHguc3VtKQogICAgKQoKICAgIHJldHVybiBkZgoaJGE1YTQ5YzAxLWFiYTktNGQ4NC04NDBlLWIzMTA1NWRjNjQwMCI4ChFzZXJ2aWNlX2xldF9ncmFwaBIRCgpzdGFydF90aW1lEgMtNW0aEEhUVFAgU2VydmljZSBNYXAiLQoRbm9kZXNfZm9yX2NsdXN0ZXISEQoKc3RhcnRfdGltZRIDLTVtGgVOb2RlcyI3ChZuYW1lc3BhY2VzX2Zvcl9jbHVzdGVyEhEKCnN0YXJ0X3RpbWUSAy01bRoKTmFtZXNwYWNlcyIzChRzZXJ2aWNlc19mb3JfY2x1c3RlchIRCgpzdGFydF90aW1lEgMtNW0aCFNlcnZpY2VzIisKEHBvZHNfZm9yX2NsdXN0ZXISEQoKc3RhcnRfdGltZRIDLTVtGgRQb2RzMp8GCoAGeyJhbGciOiJSU0EtT0FFUC0yNTYiLCJlIjoiQVFBQiIsImV4dCI6dHJ1ZSwia2V5X29wcyI6WyJlbmNyeXB0Il0sImt0eSI6IlJTQSIsIm4iOiJ6WER2WHI4N0g1bjI0eHVINUEwVDhQWWN6R3lYWW03b0hteHZYY0NpeloyaW5hU2IySkFfdFZYOUNFV0xVeXAxYXlWMndhT25fdHBzb3dpcEU5VGI5WVFSUlg3dXgwS3c2SjBwZ0VJN0hlODYwRVdzUFJ2VFRVZ2NzMnhDUThXZ245bVhwZmFodDFoLVoxN3Ezak9KZzFVQmU0dUVTZVRlcDlIYktUdVVXTDkzcHQ4MzltZ1Bobjd5UDJFVHRLYVVOSjBFSkFoSEl3anJkV1hXdnE0SDYwY1NKNlNpWEE1SjgzWkhpald0czVEMDZadW42Qk94OHMta0N3YmZoN25xSWZCTkQwNm5Fb3ljT2N2MTZhamFxTEdKZnJfMnBUaVBvVUpBNWZhTXljZFFCVUU4QW5HU3B2MjVpNXd6UkpVdkxMNkx5Ym1iLUtfUkJWSzZXN2tDWTlDcFZ1eDd3UDlDWm5UTFRSQU4xYzhFcGxxWHJEOEVFMTNUWlVSSy1tbUJROHU4ekZWTXcyU3VMYy1qTXFZaFV3TkI1aW5TbktnM2hzOUxhMG5uN3h6VnZNQXZjaU0tRUxic2tHRlVOVW1zM2JFMGEyeGxzSXQxQ0RialltdHFFOTBMeG93Ry1iVmlRMmVkTUk5eDF2TEpaeUwxOUpEM29pN0FSUjlWSnJGbktfM2ppbTZhRVFacUNudVRtNEJ3TWFJRnJHZDlUVWkyWW01MWE5VndqUXVWbUcxNEYzNWRyQWd3YVU2VWZwanBlMzJaRFoweTVXUDd2YnpGMmpGRml2X2Z2UDAwdmFhRjZuWVp3ZVFYRHJ3NEFmVThKZFJrSkQxVnU3NjM5NTdNdmM0UnBUaGZvRVE5Nm5DQ2w3eElPaW54dl80Z1VPZHlRLVB2SFZ0Um9YRSJ9EgxSU0EtT0FFUC0yNTYaB0EyNTZHQ00iA0RFRg==';

export const ExecuteScriptRequestJson = {
  'queryStr': [
    '# Copyright 2018- The Pixie Authors.',
    '#',
    '# Licensed under the Apache License, Version 2.0 (the "License");',
    '# you may not use this file except in compliance with the License.',
    '# You may obtain a copy of the License at',
    '#',
    '#     http://www.apache.org/licenses/LICENSE-2.0',
    '#',
    '# Unless required by applicable law or agreed to in writing, software',
    '# distributed under the License is distributed on an "AS IS" BASIS,',
    '# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.',
    '# See the License for the specific language governing permissions and',
    '# limitations under the License.',
    '#',
    '# SPDX-License-Identifier: Apache-2.0',
    '',
    "''' Cluster Overview",
    '',
    'This view lists the namespaces and the nodes that are available on the current cluster.',
    '',
    "'''",
    'import px',
    '',
    '',
    '# Flag to filter out health checks from the data.',
    'filter_health_checks = True',
    '',
    "# Whether or not to include traffic from IPs that don't resolve to a known pod/service.",
    'include_ips = True',
    '',
    '',
    '# Hack to get the time window for the script.',
    '# TODO(philkuz): Replace this with a built-in.',
    'def get_time_window(start_time: str):',
    "    ''' Converts the start_time string into a table with a single column and single row.",
    '    The approach is hacky, and will round to roughly 1 second.',
    "    '''",
    "    df = px.DataFrame('process_stats', start_time=start_time)",
    '',
    '    df = df.agg(',
    "        time_min=('time_', px.min),",
    "        time_max=('time_', px.max),",
    '    )',
    '',
    '    df.window = px.DurationNanos(df.time_max - df.time_min)',
    "    df = df[['window']]",
    '',
    '    return df',
    '',
    '',
    'def add_time_window_column(df, start_time):',
    '    tw = get_time_window(start_time)',
    "    df = df.merge(tw, how='inner', left_on=[], right_on=[])",
    '    return df',
    '',
    '',
    'def process_stats_by_entity(start_time: str, entity: str):',
    "    ''' Gets the windowed process stats (CPU, memory, etc) per node or pod.",
    '    Args:',
    '    @start_time Starting time of the data to examine.',
    '    @entity: Either pod or node_name.',
    "    '''",
    '    # Window size to use on time_ column for bucketing.',
    '    ns_per_s = 1000 * 1000 * 1000',
    '    window_ns = px.DurationNanos(10 * ns_per_s)',
    '',
    "    df = px.DataFrame(table='process_stats', start_time=start_time)",
    '    df[entity] = df.ctx[entity]',
    '    df.timestamp = px.bin(df.time_, window_ns)',
    '    # First calculate CPU usage by process (UPID) in each k8s_object',
    '    # over all windows.',
    "    df = df.groupby([entity, 'upid', 'timestamp']).agg(",
    "        rss=('rss_bytes', px.mean),",
    "        vsize=('vsize_bytes', px.mean),",
    '        # The fields below are counters, so we take the min and the max to subtract them.',
    "        cpu_utime_ns_max=('cpu_utime_ns', px.max),",
    "        cpu_utime_ns_min=('cpu_utime_ns', px.min),",
    "        cpu_ktime_ns_max=('cpu_ktime_ns', px.max),",
    "        cpu_ktime_ns_min=('cpu_ktime_ns', px.min),",
    "        read_bytes_max=('read_bytes', px.max),",
    "        read_bytes_min=('read_bytes', px.min),",
    "        write_bytes_max=('write_bytes', px.max),",
    "        write_bytes_min=('write_bytes', px.min),",
    "        rchar_bytes_max=('rchar_bytes', px.max),",
    "        rchar_bytes_min=('rchar_bytes', px.min),",
    "        wchar_bytes_max=('wchar_bytes', px.max),",
    "        wchar_bytes_min=('wchar_bytes', px.min),",
    '    )',
    '    # Next calculate cpu usage and memory stats per window.',
    '    df.cpu_utime_ns = df.cpu_utime_ns_max - df.cpu_utime_ns_min',
    '    df.cpu_ktime_ns = df.cpu_ktime_ns_max - df.cpu_ktime_ns_min',
    '    df.read_bytes = df.read_bytes_max - df.read_bytes_min',
    '    df.write_bytes = df.write_bytes_max - df.write_bytes_min',
    '    df.rchar_bytes = df.rchar_bytes_max - df.rchar_bytes_min',
    '    df.wchar_bytes = df.wchar_bytes_max - df.wchar_bytes_min',
    '    # Sum by UPID.',
    "    df = df.groupby([entity, 'timestamp']).agg(",
    "        cpu_ktime_ns=('cpu_ktime_ns', px.sum),",
    "        cpu_utime_ns=('cpu_utime_ns', px.sum),",
    "        read_bytes=('read_bytes', px.sum),",
    "        write_bytes=('write_bytes', px.sum),",
    "        rchar_bytes=('rchar_bytes', px.sum),",
    "        wchar_bytes=('wchar_bytes', px.sum),",
    "        rss=('rss', px.sum),",
    "        vsize=('vsize', px.sum),",
    '    )',
    '    df.actual_disk_read_throughput = df.read_bytes / window_ns',
    '    df.actual_disk_write_throughput = df.write_bytes / window_ns',
    '    df.total_disk_read_throughput = df.rchar_bytes / window_ns',
    '    df.total_disk_write_throughput = df.wchar_bytes / window_ns',
    '    # Now take the mean value over the various timestamps.',
    '    df = df.groupby(entity).agg(',
    "        cpu_ktime_ns=('cpu_ktime_ns', px.mean),",
    "        cpu_utime_ns=('cpu_utime_ns', px.mean),",
    "        actual_disk_read_throughput=('actual_disk_read_throughput', px.mean),",
    "        actual_disk_write_throughput=('actual_disk_write_throughput', px.mean),",
    "        total_disk_read_throughput=('total_disk_read_throughput', px.mean),",
    "        total_disk_write_throughput=('total_disk_write_throughput', px.mean),",
    "        avg_rss=('rss', px.mean),",
    "        avg_vsize=('vsize', px.mean),",
    '    )',
    '    # Finally, calculate total (kernel + user time)  percentage used over window.',
    '    df.cpu_usage = px.Percent((df.cpu_ktime_ns + df.cpu_utime_ns) / window_ns)',
    "    return df.drop(['cpu_ktime_ns', 'cpu_utime_ns'])",
    '',
    '',
    'def nodes_for_cluster(start_time: str):',
    "    ''' Gets a list of nodes in the current cluster since `start_time`.",
    '    Args:',
    '    @start_time Start time of the data to examine.',
    "    '''",
    "    df = px.DataFrame(table='process_stats', start_time=start_time)",
    "    df.node = df.ctx['node_name']",
    "    df.pod = df.ctx['pod_name']",
    "    agg = df.groupby(['node', 'pod']).agg()",
    "    nodes = agg.groupby('node').agg(pod_count=('pod', px.count))",
    "    process_stats = process_stats_by_entity(start_time, 'node')",
    "    output = process_stats.merge(nodes, how='inner', left_on='node', right_on='node',",
    "                                 suffixes=['', '_x'])",
    "    return output[['node', 'cpu_usage', 'pod_count']]",
    '',
    '',
    'def pods_for_cluster(start_time: str):',
    "    ''' A list of pods in `namespace`.",
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    '    @namespace: The name of the namespace to filter on.',
    "    '''",
    "    df = px.DataFrame(table='process_stats', start_time=start_time)",
    "    df.pod = df.ctx['pod_name']",
    "    df.node = df.ctx['node_name']",
    "    df.container = df.ctx['container_name']",
    "    df = df.groupby(['pod', 'node', 'container']).agg()",
    "    df = df.groupby(['pod', 'node']).agg(container_count=('container', px.count))",
    '    df.start_time = px.pod_name_to_start_time(df.pod)',
    '    df.status = px.pod_name_to_status(df.pod)',
    "    process_stats = process_stats_by_entity(start_time, 'pod')",
    "    output = process_stats.merge(df, how='inner', left_on='pod', right_on='pod',",
    "                                 suffixes=['', '_x'])",
    "    return output[['pod', 'cpu_usage', 'total_disk_read_throughput',",
    "                   'total_disk_write_throughput', 'container_count',",
    "                   'node', 'start_time', 'status']]",
    '',
    '',
    'def namespaces_for_cluster(start_time: str):',
    "    ''' Gets a overview of namespaces in the current cluster since `start_time`.",
    '    Args:',
    '    @start_time Start time of the data to examine.',
    "    '''",
    "    df = px.DataFrame(table='process_stats', start_time=start_time)",
    "    df.service = df.ctx['service_name']",
    "    df.pod = df.ctx['pod_name']",
    "    df.namespace = df.ctx['namespace']",
    "    agg = df.groupby(['service', 'pod', 'namespace']).agg()",
    "    pod_count = agg.groupby(['namespace', 'pod']).agg()",
    "    pod_count = pod_count.groupby('namespace').agg(pod_count=('pod', px.count))",
    "    svc_count = agg.groupby(['namespace', 'service']).agg()",
    "    svc_count = svc_count.groupby('namespace').agg(service_count=('service', px.count))",
    "    pod_and_svc_count = pod_count.merge(svc_count, how='inner',",
    "                                        left_on='namespace', right_on='namespace',",
    "                                        suffixes=['', '_x'])",
    "    process_stats = process_stats_by_entity(start_time, 'namespace')",
    "    output = process_stats.merge(pod_and_svc_count, how='inner', left_on='namespace',",
    "                                 right_on='namespace', suffixes=['', '_y'])",
    "    return output[['namespace', 'pod_count', 'service_count', 'avg_vsize', 'avg_rss']]",
    '',
    '',
    'def services_for_cluster(start_time: str):',
    "    ''' Get an overview of the services in the current cluster.",
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    "    df = px.DataFrame(table='process_stats', start_time=start_time)",
    "    df.service = df.ctx['service']",
    "    df = df[df.service != '']",
    "    df.pod = df.ctx['pod']",
    "    df = df.groupby(['service', 'pod']).agg()",
    "    df = df.groupby('service').agg(pod_count=('pod', px.count))",
    '    service_let = service_let_summary(start_time)',
    "    joined = df.merge(service_let, how='left', left_on='service', right_on='service',",
    "                      suffixes=['', '_x'])",
    "    return joined.drop('service_x')",
    '',
    '',
    'def http_stats(start_time: str):',
    "    ''' Get a dataframe of HTTP events.",
    '    Certain traffic (like health checks) are auto removed, and some standard fields are added.',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    "    df = px.DataFrame(table='http_events', start_time=start_time)",
    '',
    '    # Add K8s metadata.',
    "    df.service = df.ctx['service']",
    "    df.pod = df.ctx['pod']",
    '',
    '    # Filter out non-k8s entities.',
    "    df = df[df.pod != '']",
    '',
    '    # Additional HTTP fields, pre-computed for convenience.',
    '    df.failure = df.resp_status >= 400',
    '',
    '    # Remove health checks, and anything with no remote address.',
    "    health_check_req = ((df.req_path == '/healthz' or df.req_path == '/readyz') or df.req_path == '/livez')",
    "    filter_out_conds = (health_check_req and filter_health_checks) or (df['remote_addr'] == '-')",
    '    df = df[not filter_out_conds]',
    '',
    '    return df',
    '',
    '',
    'def http_stats_by_service(start_time: str):',
    "    ''' Get a data frame of HTTP stats per service. The HTTP stats are for inbound traffic,",
    '    and includes HTTP request count, error count and latency quantiles.',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    '    df = http_stats(start_time)',
    '',
    '    # Filter only to inbound service traffic (server-side).',
    "    # Don't include traffic initiated by this service to an external location.",
    '    df = df[df.trace_role == 2]',
    '',
    '    # Compute HTTP metrics.',
    "    df = df.groupby(['service']).agg(",
    "        http_req_count_in=('latency', px.count),",
    "        http_error_count_in=('failure', px.sum),",
    "        http_latency_in=('latency', px.quantiles)",
    '    )',
    '',
    '    return df',
    '',
    '',
    'def conn_stats(start_time: str):',
    "    ''' Get a dataframe of connection stats.",
    '    For each client-server pair, the resulting data frame has the bytes sent and received.',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    "    df = px.DataFrame(table='conn_stats', start_time=start_time)",
    '',
    "    df.pod = df.ctx['pod']",
    "    df.service = df.ctx['service']",
    '',
    "    df = df[df.service != '']",
    '',
    '    # Find min/max bytes transferred over the selected time window per pod.',
    "    df = df.groupby(['upid', 'remote_addr', 'remote_port', 'pod', 'service', 'trace_role']).agg(",
    "        bytes_recv_min=('bytes_recv', px.min),",
    "        bytes_recv_max=('bytes_recv', px.max),",
    "        bytes_sent_min=('bytes_sent', px.min),",
    "        bytes_sent_max=('bytes_sent', px.max),",
    '    )',
    '',
    '    # Calculate bytes transferred over the time window',
    '    df.bytes_sent = df.bytes_sent_max - df.bytes_sent_min',
    '    df.bytes_recv = df.bytes_recv_max - df.bytes_recv_min',
    "    df = df.drop(['bytes_recv_min', 'bytes_recv_max', 'bytes_sent_min', 'bytes_sent_max'])",
    '',
    '    return df',
    '',
    '',
    'def conn_stats_by_service(start_time: str):',
    "    ''' Get a dataframe of connection stats aggregated by service.",
    '    For each service, the resulting data frame contains rx/tx stats for server-side and client-side connections.',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    '    df = conn_stats(start_time)',
    '',
    '    # Group by service and trace role.',
    '    # Do this after computing bytes sent/received by conn_stats key ({upid, remote_addr, remote_port}).',
    '    # Keeping trace_role allows us to see which traffic was part of server duties vs client duties.',
    "    df = df.groupby(['service', 'trace_role']).agg(",
    "        bytes_recv=('bytes_recv', px.sum),",
    "        bytes_sent=('bytes_sent', px.sum),",
    '    )',
    '',
    '    # Get RX/TX stats for the server side connections.',
    '    server_df = df[df.trace_role == 2]',
    '    server_df.rx_server = server_df.bytes_recv',
    '    server_df.tx_server = server_df.bytes_sent',
    "    server_df = server_df[['service', 'rx_server', 'tx_server']]",
    '',
    '    # Get RX/TX stats for the client side connections.',
    '    client_df = df[df.trace_role == 1]',
    '    client_df.rx_client = client_df.bytes_recv',
    '    client_df.tx_client = client_df.bytes_sent',
    "    client_df = client_df[['service', 'rx_client', 'tx_client']]",
    '',
    '    # Create a dataframe that contains both server-side and client-side RX/TX stats.',
    '    df = server_df.merge(client_df,',
    "                         how='left',",
    "                         left_on='service',",
    "                         right_on='service',",
    "                         suffixes=['', '_x'])",
    "    df = df['service', 'rx_server', 'tx_server', 'rx_client', 'tx_client']",
    '',
    '    return df',
    '',
    '',
    'def service_let_summary(start_time: str):',
    "    ''' Compute a summary of traffic by requesting service, for requests",
    '        on services in the current cluster..',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    '    conn_stats_df = conn_stats_by_service(start_time)',
    '    http_stats_df = http_stats_by_service(start_time)',
    '',
    '    # Merge conn_stats_df and http_stats_df.',
    '    df = conn_stats_df.merge(http_stats_df,',
    "                             how='left',",
    "                             left_on='service',",
    "                             right_on='service',",
    "                             suffixes=['', '_x'])",
    '',
    '    # Compute time window for the query and add it as a column.',
    '    df = add_time_window_column(df, start_time)',
    '',
    '    # Compute throughput values.',
    '    df.http_req_throughput_in = df.http_req_count_in / df.window',
    '    df.http_error_rate_in = px.Percent(',
    '        px.select(df.http_req_count_in != 0, df.http_error_count_in / df.http_req_count_in, 0.0))',
    '    df.inbound_conns = (df.rx_server + df.tx_server) / df.window',
    '    df.outbound_conns = (df.tx_client + df.rx_client) / df.window',
    '',
    "    return df[['service', 'http_latency_in', 'http_req_throughput_in', 'http_error_rate_in',",
    "               'inbound_conns', 'outbound_conns']]",
    '',
    '',
    'def service_let_graph(start_time: str):',
    "    ''' Compute a summary of traffic by requesting service, for requests on services",
    '        in the current cluster. Similar to `service_let_summary` but also breaks down',
    '        by pod in addition to service.',
    '    Args:',
    '    @start_time: The timestamp of data to start at.',
    "    '''",
    '    df = http_stats(start_time)',
    "    df = df.groupby(['service', 'remote_addr', 'pod', 'trace_role']).agg(",
    "        http_req_count_in=('latency', px.count),",
    "        http_error_count_in=('failure', px.sum),",
    "        latency_quantiles=('latency', px.quantiles),",
    "        inbound_bytes_total=('req_body_size', px.sum),",
    "        outbound_bytes_total=('resp_body_size', px.sum)",
    '    )',
    '',
    '    # Get the traced and remote pod/service/IP information.',
    '    df.traced_pod = df.pod',
    '    df.traced_service = df.service',
    '    df.traced_ip = px.pod_name_to_pod_ip(df.pod)',
    '    df.remote_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))',
    '    df.remote_service = px.service_id_to_service_name(px.ip_to_service_id(df.remote_addr))',
    '    df.remote_ip = df.remote_addr',
    '    # If external IPs are excluded in the service graph, then we also exclude any',
    "    # traffic where we don't know the remote pod or remote service name.",
    "    df = df[include_ips or (df.remote_pod != '' or df.remote_service != '')]",
    '',
    '    # Associate it with Client/Server roles, based on the trace role.',
    '    df.is_server_side_tracing = df.trace_role == 2',
    '    df.responder_pod = px.select(df.is_server_side_tracing, df.traced_pod, df.remote_pod)',
    '    df.requestor_pod = px.select(df.is_server_side_tracing, df.remote_pod, df.traced_pod)',
    '    df.responder_service = px.select(df.is_server_side_tracing, df.traced_service, df.remote_service)',
    '    df.requestor_service = px.select(df.is_server_side_tracing, df.remote_service, df.traced_service)',
    '    df.responder_ip = px.select(df.is_server_side_tracing, df.traced_ip, df.remote_ip)',
    '    df.requestor_ip = px.select(df.is_server_side_tracing, df.remote_ip, df.traced_ip)',
    '',
    '    # Compute statistics about each edge of the service graph.',
    "    df.latency_p50 = px.DurationNanos(px.floor(px.pluck_float64(df.latency_quantiles, 'p50')))",
    "    df.latency_p90 = px.DurationNanos(px.floor(px.pluck_float64(df.latency_quantiles, 'p90')))",
    "    df.latency_p99 = px.DurationNanos(px.floor(px.pluck_float64(df.latency_quantiles, 'p99')))",
    '    df = add_time_window_column(df, start_time)',
    '    df.request_throughput = df.http_req_count_in / df.window',
    '    df.inbound_throughput = df.inbound_bytes_total / df.window',
    '    df.outbound_throughput = df.outbound_bytes_total / df.window',
    '    df.error_rate = px.Percent(df.http_error_count_in / df.http_req_count_in)',
    '',
    "    df = df.groupby(['responder_pod', 'requestor_pod', 'responder_service',",
    "                     'requestor_service', 'responder_ip', 'requestor_ip']).agg(",
    "        latency_p50=('latency_p50', px.mean),",
    "        latency_p90=('latency_p90', px.mean),",
    "        latency_p99=('latency_p99', px.mean),",
    "        request_throughput=('request_throughput', px.mean),",
    "        error_rate=('error_rate', px.mean),",
    "        inbound_throughput=('inbound_throughput', px.mean),",
    "        outbound_throughput=('outbound_throughput', px.mean),",
    "        throughput_total=('http_req_count_in', px.sum)",
    '    )',
    '',
    '    return df',
    '',
  ].join('\n'),
  'clusterId': 'a5a49c01-aba9-4d84-840e-b31055dc6400',
  'execFuncsList': [
    {
      'funcName': 'service_let_graph',
      'argValuesList': [
        {
          'name': 'start_time',
          'value': '-5m',
        },
      ],
      'outputTablePrefix': 'HTTP Service Map',
    },
    {
      'funcName': 'nodes_for_cluster',
      'argValuesList': [
        {
          'name': 'start_time',
          'value': '-5m',
        },
      ],
      'outputTablePrefix': 'Nodes',
    },
    {
      'funcName': 'namespaces_for_cluster',
      'argValuesList': [
        {
          'name': 'start_time',
          'value': '-5m',
        },
      ],
      'outputTablePrefix': 'Namespaces',
    },
    {
      'funcName': 'services_for_cluster',
      'argValuesList': [
        {
          'name': 'start_time',
          'value': '-5m',
        },
      ],
      'outputTablePrefix': 'Services',
    },
    {
      'funcName': 'pods_for_cluster',
      'argValuesList': [
        {
          'name': 'start_time',
          'value': '-5m',
        },
      ],
      'outputTablePrefix': 'Pods',
    },
  ],
  'mutation': false,
  'encryptionOptions': {
    'jwkKey': '{"alg":"RSA-OAEP-256","e":"AQAB","ext":true,"key_ops":["encrypt"],"kty":"RSA","n":"zXDvXr87H5n24xuH5A0T8PYczGyXYm7oHmxvXcCizZ2inaSb2JA_tVX9CEWLUyp1ayV2waOn_tpsowipE9Tb9YQRRX7ux0Kw6J0pgEI7He860EWsPRvTTUgcs2xCQ8Wgn9mXpfaht1h-Z17q3jOJg1UBe4uESeTep9HbKTuUWL93pt839mgPhn7yP2ETtKaUNJ0EJAhHIwjrdWXWvq4H60cSJ6SiXA5J83ZHijWts5D06Zun6BOx8s-kCwbfh7nqIfBND06nEoycOcv16ajaqLGJfr_2pTiPoUJA5faMycdQBUE8AnGSpv25i5wzRJUvLL6Lybmb-K_RBVK6W7kCY9CpVux7wP9CZnTLTRAN1c8EplqXrD8EE13TZURK-mmBQ8u8zFVMw2SuLc-jMqYhUwNB5inSnKg3hs9La0nn7xzVvMAvciM-ELbskGFUNUms3bE0a2xlsIt1CDbjYmtqE90LxowG-bViQ2edMI9x1vLJZyL19JD3oi7ARR9VJrFnK_3jim6aEQZqCnuTm4BwMaIFrGd9TUi2Ym51a9VwjQuVmG14F35drAgwaU6Ufpjpe32ZDZ0y5WP7vbzF2jFFiv_fvP00vaaF6nYZweQXDrw4AfU8JdRkJD1Vu763957Mvc4RpThfoEQ96nCCl7xIOinxv_4gUOdyQ-PvHVtRoXE"}',
    'keyAlg': 'RSA-OAEP-256',
    'contentAlg': 'A256GCM',
    'compressionAlg': 'DEF',
  },
  'queryId': '',
};

export const ExecuteScriptResponseString = ''
 + 'AAAAAaUSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYSL8AgrBAgoUCg1yZXNwb25kZXJfcG9kEAUgkAMKFAoNcmVxdWVzdG9yX3BvZBAFIJADChgKEXJlc3BvbmRlcl9zZXJ2aWNlEAUgrAIKGAoRcmVxdWVzdG9yX3NlcnZpY2UQBSCsAgoSCgxyZXNwb25kZXJfaXAQBSABChIKDHJlcXVlc3Rvcl9pcBAFIAEKEgoLbGF0ZW5jeV9wNTAQBCCFBwoSCgtsYXRlbmN5X3A5MBAEIIUHChIKC2xhdGVuY3lfcDk5EAQghQcKGQoScmVxdWVzdF90aHJvdWdocHV0EAQghgcKEQoKZXJyb3JfcmF0ZRAEIIQHChkKEmluYm91bmRfdGhyb3VnaHB1dBAEIIcHChoKE291dGJvdW5kX3Rocm91Z2hwdXQQBCCHBwoWChB0aHJvdWdocHV0X3RvdGFsEAIgARIQSFRUUCBTZXJ2aWNlIE1hcBokZDhjMGQyZWItY2Y5MC00MDBhLTg4MmYtMjA4N2ZmZThjOTAxAAAAAIcSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYSJfCjAKCwoEbm9kZRAFIPQDChAKCWNwdV91c2FnZRAEIIQHCg8KCXBvZF9jb3VudBACIAESBU5vZGVzGiQ4OThjMjEyYy0yMjE0LTQ0NWUtYmEwYi03ZDY1OGQ4ZWE5MjI=AAAAALcSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYSKOAQpaChAKCW5hbWVzcGFjZRAFILwFCg8KCXBvZF9jb3VudBACIAEKEwoNc2VydmljZV9jb3VudBACIAEKEAoJYXZnX3ZzaXplEAQgoAYKDgoHYXZnX3JzcxAEIKAGEgpOYW1lc3BhY2VzGiQzMWExODU5OC03ZGE3LTQzNGEtODE0Mi04ZGNlODY1NjMzNDA=AAAAAQISJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYSLZAQqqAQoKCgNwb2QQBSCQAwoQCgljcHVfdXNhZ2UQBCCEBwohChp0b3RhbF9kaXNrX3JlYWRfdGhyb3VnaHB1dBAEIIcHCiIKG3RvdGFsX2Rpc2tfd3JpdGVfdGhyb3VnaHB1dBAEIIcHChUKD2NvbnRhaW5lcl9jb3VudBACIAEKCwoEbm9kZRAFIPQDChAKCnN0YXJ0X3RpbWUQBiABCg0KBnN0YXR1cxAFIJIDEgRQb2RzGiQ4NzNlY2JjNC0zY2E1LTRhMWMtOTQ3Yy00MzRlY2YzYTc4NjU=AAAAAPwSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYSLTAQqgAQoOCgdzZXJ2aWNlEAUgrAIKDwoJcG9kX2NvdW50EAIgAQoWCg9odHRwX2xhdGVuY3lfaW4QBSDpBwodChZodHRwX3JlcV90aHJvdWdocHV0X2luEAQghgcKGQoSaHR0cF9lcnJvcl9yYXRlX2luEAQghAcKFAoNaW5ib3VuZF9jb25ucxAEIIcHChUKDm91dGJvdW5kX2Nvbm5zEAQghwcSCFNlcnZpY2VzGiQzYTM5NzczNi1mYjNmLTQzZGItOWYyNy1mOTkzZDEzNjM1Mzc=AAAABEoSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRqhCBqeCGV5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAudjI3YVI4ZGxTbEdWanVkRVZnY0tGd3FLUExTUE9wSmg4LVdwWGJqRW1fQVJGNTk3SDA4WVBPYUhETnU3cjBBNW8yLTYxamJDMERSbWgxeVhwd2tlVS11Y3RwZVRPbWlDMVVuVTBFYXMwTjFGLXZPdU1WYmRteHRwdDB4Q1I3dTBYNEUtQU1FdEhDXzNQUTdWZkdhQkw4OGlhdzQ5VEZWdklZYlBsZW1vNUx2NFd3VmNCdjlIbDJadGFVMlNCM3djNnpnVjF6UDZnbFBISlNpY1N5NFU0ckNQRmhFVVVuQlB3d2U3bW1MWFpKcFJLQk01VVJkaTYyNHo4Qm15aExIeU4yRkxNeDdDRVNqeXdzN3VNUE0weGlpRmJVYUI5MEZMbm93SkxjcEdDMmcyTWQ1NUFETzA0bktiMUNmQmM4S3UxcUZYODM1a240U0Nhb0RmcUNZRTI1R1JoU3lmaG04ZGVsQXJ3ZmI0MGl4YW5rMkRxM1poM2FNaWdOUF8wbGljMTlEZ1Vnb1JZUDNfcVVLbnMwOU1MWUJSSVkxaXlOVG9sdjNHUi1KMTRBN1RKNGQ1VUpYQ0dXZTZVNnRLd05mdE1VbEVFVk15Zk1IN054UlJfNVFuaEhUNWVyUGpwV2tTVVg3MVphVHVsSVZoYUlES3VSSExlQ0w3OVNHdUx6UnNlcW9VX0YwSjc3RlJMSXIxOF9wVjlZQXlDYUpCY3NpRVlZem1pT2lwWUw0Ry1qZzZmQlhzcGE2cWstZURTdmotQWlCV3VPcFVQMUZWT0RyVF9aV3c4MzJLNnpFanpVZzg0T1M2cDhVYnE4R1AtSmJ6T1ZZSUtxNHY5cTQyd2k3V1I1b3cyWlBiZ0pYU2E4TkpRbktmZWJiYTBjY0lWNTF5eUdNYktVbVVZQkkud2VSOThOZnhMNU96QXBvMi5RM0pOU2l2OVo4S3d5YzE4eC12dHZOX1JiVTE2WHhzdGFaWGRscHN5S1p4MnFOeHZOdUZmS0VxTTBIZ1pMZF9aOUVfTGtSUXczWDJvQmxRbWRmZVJpMHBGMVpmaW1CWXFQTWpDMTdVaG80OVBaQ2VmUHJfX2tmVHdsemV3Y0tLY09vWHZlM3hyVjFiVG5lM0Y4dXl6Wkl4cWZOdjJNcDVVeHZDekJad3lqQUNPdmU4NzRNa2lueTlIRGliNng4MU11bFozOWRlc3pNMG4yWlVHUjZFSmd4OHV4ckxjbWVBV19rWlR1b3N2azB4bm9hV1hrNUFQclBYblVQU3BSanZ0U2dDR0tnLkRZS0pLM2NaR25jMU5NbnlSSGxNZ3c=AAAAFx8SJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRr2LRrzLWV5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAuT0puekRkOWNRR0tPbXpDWDk5QmY1MlRaVzhucEgxTHBPT2twNGtvU3BxMDZNay1uUTFPYnJCemZSM0NWWklZZml2NTFuNld5NW1yRDhTNVQ0RGtVc2QtSG1LV1hhTzlnMFBXOFI2UlhsOGpIX2k0UExZNi04XzI4YnJCN2N2TDdyZkIyOF9MYW1hdnhWOENaRGZyRExYWHY3bHVFMmhxbERXeUs4NzVLZXlVaWwwcTNQdUR5ZjBiN1dVbE95RDAzMHhBQ0JIWkxxZmJQM25kcUprZUdLWHhMa2l0dFJVQnMtV3BIR0hnRHpCM25QQWRhenlEX1pRa3hzMm5LUExPZmtLMDFjNzgza1NfT2Z3TkJkOG95MjNMWk95bEowMXhrMF9JdWROX1BQaW1QbFFibUlKYzgyMkpCZGhJdG1Zdk1rWUZBS1FhY18wWHhwczd5aEE0UFVVY0x1WDZlQmdxMUFmT0FkVHF4V1lnMWZUR0xmSzMxVFB1SUxMS3RYZHFPaHJNcFhvdzJzT2x6LUNxVmVrWDJ3SklNbms0R0Uwb1RkaExqRHJ3ODAwVWc4cTc0S1pSYVpBSG9SYkt2b2V3alRKT0J2UEtSS1pMNlVWdTNDaXN5M0FqUG1QVDdjWVJzbUVxeEwwQVF1azBibF9tTVRfZ3ZhTjVncURrTmpoRy1oX2dsbzI5Ym9ER3dwYTFGWkxUUERjbGJ6QTd6RkpvbExzN01xczJnNjN0OGdUNlNYSHhaWHZpbFpVN0VJX3BZNlg2SThXdkxnMllzWTFzS213bTRvc3NDbTRxZ0VralR2UzJDWEpXeEhqaVlKeGlGSjEteXMxdTRlZFU1OUpyYTJVN09wczdodEV0bTNMRFgyVlZXNmhwczU0R0o3YXVsdVlWWG5rVlFlT28udU1RLTdJNnl3Tk1WS0ZMSS5fMTNfNlFEcFY4OFoxdU1JaDJfSjY5YTd4dERkMktpWlRYX1JrdUplOEVrNUQ2azh2aFJhV2M5S1NNR0tkOHBKN3pVTDZkQ3dFYTczMlgwUEtQRFVvempseGlBQURjaWMzUzVHZWRLRDF5bWo1bzZkN1huNDA3V2FUVG9QbEN3eGJMRW1VdzlRaW15VERBZVhNMDJ0VXNvRHYxNVo5ZUg3N2F6WVh5NkpxdEk5allRVFRaQWM1NC13WWFPNjFxc2lXVEtQRDRKR2piQ1ZlTkFrUkRocUtnanRoRkZBaDZyWlR5U19DUm5jTE1RSVFkRkV0bGZtWFNsSnc4OWhaVDdsWllkUWxVSXNsejdlY196cTIycFBnbEE5TXFMQlRQMEhKOWV0d05sNlJUdFlNR0JMV0xZbkt0RGtjOGlQRlZmdGpKVmlfeFZhc1B5UmlBT29pT1VNN19DLThVbDV6dHhOQWpBNzJ6NTVjZk9TU2ZhVGlzRjA2Q2I3SnhTWTJEWEhnN2RYYTBvOEdISnNwamU3VDMwUEoyOF9HNU5ZTUhydHpaR0dicnpabjNDMlMyZzJ4LWhrU3diN09UdGJtV0c4a3h1QVlVakp3cXFfZUNuN2VoclNhWHBBSVZkZmFqSzRGOVBKRmRhdFFMVDA4a2xnNVhBaHp4ek5XTEZ1a01CTnZCRUhTOENpQkNYNUkyVHNrM1VTQ1FySTNsMzcwa18zOFBvYi1JWkVfYjdvYUFfRjQ0djc1RlY0WGhyVlZVWkpxVURQRkNQcExmQl9Xamhwc3pKdW5YMExUVnFBaThBdFlSMHNzWHZMQ1BGTk8xcVRBSEZ4UEotaWhIMGpwX2hRUGQxakE3cUM5ZEN5MC1XSkpYbUg1N3c0d3A1UUlWOE5GaWQ4Sms1TjBXLTZnTGtsME1NQ0FVYlVuNnZjMkx5S1BEampLcVoxWUV0N3NoTzYtNy1IZXJiTWZ0bDc3dXM1RGhYT3lOdlFodV9GcHJPS0R5bWptNmZxRlMzN3drYkNYWFBFNHRpR1UwRDgxazB6Tld4RERwUHpHMUNQck9zaWs0MDNINTV3VHBWSHEta1RsbzBFSllaRVhsY3ZoSE1PUEVDY3ZvVXBSVDJPYy15Z1NNZDlpRXhvSDJ3MGxjSXpxNEhfenBYWHUwY294UmRVUDdCUFhSTFZYSlRfeVRaa0FsNnI2bW5UTUdWVjdKVjVQb1dNbDFNZXYybW1EWHg0Z0xjSTJLVG52WlZrY29qTV9qYTlHamo2WHJ4Zi1IM0lxU3VLUWlMNlVDZ21wWWJrdW1iMnRxeEZvWGR0U0U2bFJSV0ltaTFRM1dFTkJhNW4yUVpQbkp1N0ctUUlteTJrMmpfVXNESFpMQldpMjJhNXRwTzJwUTI2bGZ0b2NGSE5xOFdMM1J0Sk5TaDhsNjN1QVlyQ0d5X25pREwwaEMzQ1hQREhrMlhTenNnSjNpRUtXaVd4ZTVRSElTMXlaQk5lRXRYQ3lrR1dtTldaVmlyOXVCR2FSNG02eUVEaG02VmVEVVBRQXRjZWhrN1FDV1BGY0ZpQmZ4Sm52TVN5Zk5qMURCSWp2bFA5YnV0d0wtWlVhbzJ2MVFDVmtDeWpRVDN6M29WdlQ4Z2dNNV9fWGRxZVNzVDJtZVRDQUNyQjlKV2ZqdmlObDZOc19WN21RT2RfV2JTakF6VFdrS0JXbW5FRVdxZTh1cXZyN2FKUzFoa1NQV3ZSMFBUTkFZcFdfdDJQcFN1Wko4dTVkaFRhTWowNW9rT0hPb24tT1hkNUlfMjZhU2ljVzNtNEVzLW9kNUppZUhCdkc1Tm5aQlEzSU05clljWEUwT19MWmRXcllKR2dnY0x0ZFdqak40RW1FdS1OZmUtLU9sckNBMzlrSVZzRHB5V2RoWDFKeV9Bc3JDa3VEVGtjb1FPSVl3SDZITXE4dFcyUk80ZHNmRXdybmVZcnFDUDJndWFtZmZiMExab1B4cTlwWTJHbTNmbVJQaGFLanVQNUxqUlo3ZG81cEdWVExtbTR3OXVBOVpQbS1jRW5ONHlyVkJSRzQ1eVowMzFUOGlvTVV0dmdOeWpySTlKdm0xQTB6UGVYYVpSNHJLcThpMFZoa2NQZkZtWFFZWVRkdG1zZ1hfckRaT1l3U0k2LVJLTGhxejVrZHluSVhQdUxQemxkY19ua2N3TnRKXzUyNjNVQ3dCZHp2Z2ZrNDN6LThmX2tnMnlsOElreEluSF9nWFZabTFDTU5ZcXNvYktnazMteE1mdW9BYlRJOWRjQ3dhOFAxR1lXSldKeEVFVURPN0ltM0Q1bVZuaFFQWXRVblZPZnpwSHlueHFDdUtLc3ZZcXE5cThsWFJUbU9GOW1ZS3hPVnZqb2xMVjJGaWp5blM2YXhzSTc2ZTVSeGR3c0ppTWlXWFRYbUtOZjd0QlQxZGEzd2pHQWVVZW9PSjE3aDNtS2lRZ00xdlFHQ3J0Z0NsU3lveUJzV3ZZT1p4d0VyMEpCZ3hBNnBfM3ZKU2Y5cW1CVTN6VE9Kal9rbTlQNzhHVkVVS01pNzRYMFR5akdhT2FFLUhsWGJjcThSQWhEd1d4NzJvQ0lQVGVEall3Z3AxekR2dVZxeDFkaWUtMmd1VW43UmtSNkJRUTF5aTZlVzJ6bFFGTUR4alZzQXNUTWo5bHp2Zks2blhPMHFZaWFUOUo1LXN3REQxZFRLcmFEaENrVDZsQi03RUgtbXZiMDhRbWFodTZ6MTNIdmN2aUxRWFFYNG1qZ2JURThhQi1UOFNyVG11bjFiLXdldkh3dnBWY1dKcWF4bUNIdWdkaXBDOFhfNXYzN2xrU1E3NGxKZk5rRVg4Y2FEal93T2RLMkVuU0E0WkwyMXU1SVcxdDFkTEUwMl9RRXJxaVlLVkpBcFJWeGNoNHNMa2tHWm10TDRSUWJPaFF5TGEwZEF2WXZzRkpOVW8zUlJSQmg2eV9YZi1kam40UmMtbjJmT2swMnRURnZKd180UmlfandMbHJtaFo1V3BGNlM1dkRUcVFXWkN6UnBuMFpyREdoT1lVRVk2Y0dtRnh3Q0YyT1ppTTM0VklPZ0VWdTNKVjZjY1dQV2dIUmcxbXFfSm9aQko0TjNtUzlmREJJZVhqdG0xU1l0QnMwdlRDYTI5a09wQmV0anVsSXRCQzcwQ3R3YWdtOTFRcS14b2FlRjA0OVZOOFNseVE1by1CWmktdHBpREU1SXRfakEtSjJDYVVtclkwdVlxRWNIVDhsRkdlN0E1dUIyZUhUX1o3SVd0RGRrN1ByMEl5OWJhVUFSYzkya09QNGhPQmd6d3g0T3haNnB0Zm1uT1poYXpNM1hoaHZZN09LODA0VjFBYnRDdjdOY0pIYklDc0NHUzhvcE96MkZidTgxdHdmWmJvUmhLS3FvTWJhYnpEQllMLWNmaGFZME0xV2FIQzBYMGVoMmtlTDA3Rm9qUnFKaHNjTmRMRHRLOURnUWo5YTJ5WXJHYXpjM3lUYXlCREV1QTBCMjIxTW1lNDhSWVZDZUFPSm1XRk95ZmJUSlo2Z0toYUpZWFBRS1Z1QzhFSEJaOFE2T3BRdkdnSnFTckpNalVhcjlBTWN1UTZLNDAzR1Q0Q0NncnUzZ29xaFdFWld6TVc0QW9LNWNFbzliS0ozc01adlNLWHdQbTMwYU1nTHdsdExuYzdodDQ3b2dJcmFwdEFYMlUzeFpxWHliaVNEeHJBS3Vmdy1kUk9qWHBvR1JkOHFSdEZnZXV2eGZTNkhCcTlRbENMX1ZaZ0h6ZXdKb1ZzQnZ4U2xoSE9KTURUbHFPM0c2UHUtQmE2RnFIc2ptMHZEQ0tFaTNReDhORGZHSTExYzRuYWdRSVJxSF9ndGd3OGlOcXBfOGxHUlNuOVlOU0RuX015TDRWSTJIMVMwRU1VZHQ3ZDN6cFBPd0daMGZtOFRLb1BNT05FdnJSNlN6cnJ1YjV1bGFWUkl3QnhIY3lTbGJjNGcxMFREUjczSUFyZmZHYWszYkZJWkYwNlVpbkxMMTNMLVhZLWJsYWUzTXk5Vl9ucWhvVTBXQzhRTjdxeFJnazVKYzFMc2YxNm1ZSGQ4TTBTR0RidXl4bVFyN2ZaeWpjdlBKbEZBRXk3aXVrQnVtRDRJcmxzRlRNdWVMUVFkY0Z2YW5SeDFJelJhdkZGZUNWbHRyNEEtdnhZbC1xZENDS2M5SlQzLXpnNjRkYUNoMG9mSzVVZlBoNHh5NGVZYm1BTjhzOVUzNXF6S3lrTVktWTg1OWcxM2ZROE9KVW05MHdjWjFyU2FsOHNZS2JWdms3M3N3dFdFby0taUJyTi11amdzTTR4RXVpa3BIRHRIVDdoVndLVEpPMDRXSGQ4MlNlWUg2N0NDdlJXbGgtRFZpQmlTNGtrN3M1RGNJRHVNa2tHRDg1VGxyc3ZOd2xVckREbjZTTTlWbDc0Uk95SFV0ZHprU1p2a285bFJySHhibE5YazdQbXFsX2lfR2FUNEpYT2hpUVZ3Wnl4SU51N3I2bllkVndxX084STN1WVJVMEZiU2c0VnZuQUFqVTlBaDQ0blNCcnFla3RoS0JvQ2JzMnlySHlQSF9EcVI1QlJabE5CeVFtYnFHZ0x0STRrU2NGUWxqZmxCZDJYV1dTa0RFcWVlXzVtN1E0Q2JBcmZIdWkwQ0htcjJWTENyMEVLaElySjNydWgyOFh0STNWTXFEYU1ZMmx2OVMtTlUxSWVHeXBNUWw2Y2EwX3pmNXdZQ281UndnTXVha0lyTzJDM3l0SEh3UTljaFkydk1DZWJTam5KWDhhUXVPdmZPR0phNTNtOWZKQ1RmSHZpTmlObGV2UzdoOFVXZ0lOdjNRV0g3cFdhV3hBZ0JqM19fM0tCc0g3amlJaEF4OHlEakw3dnZ4M2YtU2tNZXJ4bVhxQkR6blhHa1lvN1htNzlDcTRoTFpHRzRpQnBNb1pBS0c2SWk5ZUNES1lmVVR4VDlPM1B3T29MV0NHazRVMThwYkw2Ui1ldkNnTW5tVEhobEtZb3FfR1FGR0Q0N1U2aHcyRkpQeW5iVzJCeEFLTnlmb1FOeXg0dFZEZEdVdlBaWFAtZXZNTzE2WWJzZkhOSFRmeVp0VXU5Tm1MQ0tOUkxCbVo2TnppUlBIRk01THFGVWpiT2ZmRUV0UFk1S2RmY3NNY19QOHlzRG1RTlpNN0VPNUVoVE9aVUFBTkVLRXlNclkwUmlmVFY5WFIzSzdnLUg1czFydzc0VFJyX1ZDaENKNk9UVzNPVkltd0FjZmRtT1hyZ3AwVWVWMDlBbHUzVEQ0emlmX040a0U3cUpCd1MwLXpNbEkxSTFrQmpOZ2dhT3JUQXZUeFloRXNuYnhDaEhqRWdkN1poWFJQcnZXSDNJMXI2RGxIZmU0c3EtYWNPWG5zeTNJUGxpUnlXNWNVa0k5dnU5UHVZNTRyYzhUQjVtTy1TdC0yVEpEeGZlWEpwaUVUM3hTSzYxSTJCcnFuQmZxYnFsakpIUnF6d0V1R0R1WWI5SVJENU5NdnJtd2NaaWVQbnppLUNvOWVyTk5WZUhPa0MtZEo2NjhnaXdnc0Nfa0pXRTFmMUhDNWJtdktMc3hlOVJVazkxalNSZEE5SXYtX2E4WnQtWDZOdDN3eUFZbC1kNTVrRThsVml0WXZtZ2FIclJ4Z3dudGc0ejhOMjk2dHAwd2ZPS2pmQTFBR3RoRDY1MTB5ckRiVklISEZhanZmOENlU0IyM3dYc3pDaVBHbUhxZUxodDU0SzBZS2FiQlV1aUxzYWNLcTZMQmJTUExzMThuNk1ZSkVPbEFweXVMdjhNeF93RHpveHZ2a2RzbklGbFB3THBXZ2FJdUdiZ19NdzJYa2F2RzY1ekVjOUxDa0g5a3ZaQTZ5cU8xdWpqSVJhZFY0TGZCbXJlblBEd3RzVjk4ZXh3c3A0aWQ2Y3loVjdSclZNZjM4Y0hEcnd5OVdTUkRjUmo2WHNRZm9NblBYT2tRYWJBNkw5QnNzdWVMMFJaYzFXaHptUG9jVm5NSmdxVjdyZlNSeUM4MXBicGRsT1VPbjgyLW82djdpanBkekRQQjExQm5IVmpQYXdlbGVULUNtR0lUdVFwYno1dWxRQUxrZXVTSDJvU3hkWWVYdFZUbUt4ZVUtZG9jNXpuS3QwSXFreHpYdXFTbzZrUVktNEVXZUQteW5lakN3SERPUkRESFo0SE44bWQ5RHRyaUxId29OaXE4Y2c3QTNPT3ZQRFpQa0VWbnMzcGtFcEZtOUtRek9GZnhKSkluZVZQdkVURU1qcDl4OXFKRGI3Q29WNlJxNjk3eHJoLWEyU0ZMRmNueEdtV2ZKcl9YNURrWl9tVWNMNENKWWJjaWZfSlkzb1UxckFOeU9BNlY5T1lxODVHMUxEZC11aTFSMHVRazJQM1pLQmhfdEZuSWRfRkN1YjFnSXJTTk9WSTNtMlpkT1VIRno1enJtUm1GZ1Vrb0kwQmNnQlVPa2RyQ1IyT2VRZGduS1RVMmdhRkx2eXRscFF2TWo4WmlhZVk1SVRjMnRzSVdNeXNEWjZ3TjBNWWJqUjNpSEg4TFZqZ0JYRUUtUzNEeENGY0wzeFBKN0Ficy1nVm9qM0RmVUREVXlkcDdVdTYzaE4wYk9CMG1vMWJwN1BWbnpJUzhxRWNaRVN2RzJfTXhWQmItc3hvSU1UOGRrb0Znd1ZIYjc1UmlCd21HakIzcnJLTHhidDVvaVVUSFdqWEcwbmJSZ29ibW1ucGFIYklBSmpoTi1kTTJBTGowV1VlRHdRLkhRcGVOLTJiajNNdXROd1J3TXVEWEE=AAAADZISJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRrpGhrmGmV5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAuU2o0OWNyMmpRVjZVVDJhUU80N2dLeHVXRmNYeS1XUndtNDhOc3RlMkJzcHZpRHVCZV91THdhX2szVEV5Wm5HelV4Y3lYRlNNOExnWmhzcU04ZjJzWGpzbmNUdFJfbmttaUI4czlLc3h5TEZmYU9EV0lucEJYV09lV1kxdWRBcFZDanZkN2JicXZUd3dXTVlBLS1LYV9Eb3NLbEFjMjhxZDR6NGJqVlFocTVCSnJWRlUxX19nYUVWWGdjQS1ycDBxZmdKbHdkajA3WTRnUTU5Z05VWjJ1OURnSHFhVmo4QXljQ0wyZjlXXzF3UmtwZGlJR3VWX01oaEUzYXF2OEJRZUJ4WnltQ2lVZVpDaC1hSUpVQk1vaUFXRmNERzJkQXFOYW9RWnAwOHRiZmxMQ0JqTkFIOVRiLUZETWtMaFpGamhOZkdmakQ1T19wTWpLMDZmV2pRUWRXS3hwVTlVRGhjS0EzYnFrak44Nl9ReE1CS081WnFJenl5Ml9nVFlJankxY2c2R0dWZk5tOUtYWFNUc0FGSFVFb2oyRTNUb3pyU2pGekRSSDQxN1oxVjFEYUp2VDJzWjNSd1hWY3hJaXk0eWR1OEFfVF9hNXZqd3RPeWdMRWNEcEh2TmJhR0l5S1Y3cnVsQk9nSW1VcTlXcVlzdlk3TlJ4bV8xV19TTF9wdUdqOXdHUmdKWlp0Z0E2QVBjeUdjdGc0SHVfWHBkTUhuSzNZUm81OWtBN2Z2UmUxYnJDUGJFMEljR3VDcVhqY2sxbWpnN0d3UXh2RE5ON1BZZGFTZ2tybzNrWlhjQW9vN21qTExHNmgwcy1aM1NKWDRLM1RIN2VCMFpYSXdDXzNDYkx2UjRBVkpYRkVqX2NPNWE1ZGZ0X2ozZm8td29oTkdQdG03TnVXX2ZqUkkudVdPX0tLT0VPWi14SlRJSS4tYXVXMzNfd0t5WXB0ZnJRUWQtSkZ4eHNpQW45RWN3ZUU5YUNJZkxFZjFpRG4zWWlWWm1xQTk2WlJoQVRpY1ZzUTlFYllXSFJoUXc4MnpjQXM4ajZDRFJDVXN1b0pZc0dyQlNhekpZbVJqQVpBTmQyVmQ4UmFBdmdPcmZwSUhYY0dTMjN1eExIRXloZm1ueWhSYTQxVE43cTZTMGJoQlNWLUVaZzcyQS02RHlXZmlEZUZSZ1ZkUW1DaUhETm9ZVDRvTy16ak5xR1FXOVV6X3lJd01aZXMxTDM3cFZPM3YzUnktMkxCT3REWUVNb0FIbDByN1FGemtmRFJocHhKOEdudEtxMnVuVXQxaGFQcnYwQktmcllKUmRWbTdleHJPVjZ5Q3BOTXo0Q2JmMW0tM0ZTeVpycXdYUGRXX0QwY1BFUUNZQldMQVlubmFfZkNyQzlQT1FUT1Q1czZZNTlnVWwwU001d3ZqaTdmd2htcGJ2eFI2MjlTazdRc1pDWlRzSmdNLTNPclRwVjNXdzhvVzZ0NmV0MkhZbVMySG82OWdVdkt1c1Z4a1ZfenBmSjdZeURLVWJoN1phZUM5dkN6cEdIT2E2QUhHYnFFY0lRQkRFcEdwclZqR2J3WURQblk5ZjJoRjVITDNwbUc4Y2xYcWhzeEE1OVhya0JBXzRpZ1IwNTVkSGRrdXdkamw3Z1B4Wm42bGQ1Y3dEOEZkc0RwSUVSQWVuMHRJMm1CanpCUEdCY3NHMjBHWTdOR2o1eUNkWEFoVmRZVnlkNTlYeVRYVWUzd3hXcnRPR0NFeDBPSDE2REZTVXRYcERwWE5YS2libUttYlZ6YzJvdGljbG0wMTVCcndLZ0xXNkoweFk0OTZEOE9UU2hqOFk0OHh3dHlQSnFpc3A4RU9EYTJaa2ZXeWhpS0ZiNUZsckZZODRNdlM4ZXZnSlYxSGs2N3NaOUxXT2Utd0E1S1JNclY3MVZzVW84Vmd4WjhROGFWdUJyWUZfcjJrdzBZbG1LY1hHVW1kNF9wbjNqdzNsWHlleVU5SXhBcHcxRnloLVppMjdtRXg3TlJuVXA0WG1ycVgxZnhjeTc5UVZRRV9EU3lNd2d2SlROQWxtMW1kWXczMk5yOGJBWkJ4RWxvQWRpRklzU3dhMEpzYTVPVXdYRHlZM3J6T2hJWmF4SGhVZnFVS0tVNjV2d0ZGNWNBU0VReDdtbUNrSk10TjFrOWwxeDZpZWs5U2x4SVJKcWdTVXJkaFpfOUVGM0Vaa20yZ245MXVlQnBVWkEybUwtM3M1QVZ0NVJ0Ym5uMHhxaHpnYVhNTHJkOGFnRlZHV1RCTU5COVgyM1FMa2ZwMlFjakszTGx4QVhfTnJtWjRoN2swQmZNWEI5WUpUY3F6U25oeHEzSm10QTh1ajkzLUNOVFRzVThFYkVqVUZRbnRJNXJHR2xpelMtcFktaHF0WlNmUTUwQWY3NnZ0Qks0UV9UeURvT1Y0YkhvSVBPM2JwVWJ6X1NidXRuNi10RWMydTVKYUVReDFzN0VuUWM1VjRJaENVdVRHdV9pQXdvNzhjTWR2TnRjZlZHRHM3OHhMc0dpQ1RjU3I5R2J6YjFQTkJ5eHRhLXV6MDdWRjZGRmZ3SHdnVGZUUmRjWW01OFpDMTNZZTFEUktDY0xnZVRKRzlGLVI5QzVCQXNUUmtMYTViWmhFZk5MNVQteEVuSWNVYi1tUXkwOUthWHQ4dEd4dUNSNHh1RmZGTHVrRm5RSGIxMEMxcTZCcHBMUUNNeFByUWh0VlJqTDVJeThDZDFzYm1naFM4QnlSaTdta2pza1BGMnVObnd5MUhESVlONEFTSzV6eW9vSHNFVE1BaGhySGtYNGpza0pnd3V4ZHYwbzlkcmR5RG00RW5fNnhRNkxtVDBkajg1VGhlU24wV3NJYWtBQTNFU25ZcnlidkVEQzVhUGU0UzQtbEhYbUpwYWxhTTZ4TjVzMmNUN1JSRzh1Z01pNXBHckNWWERZeU1oQ2ZjT0ZfY2RsemlFX2RUTTd2dFQycUpZajhoTTVkcURwVmRpMWlqZU8tUHJhdl9NblI3Sm43ZjNiT01UQU1UUGthRm93NnhYSG8yTjlsMUxISGxlZlR5UkQ4MDlPTzEzcVdJNkRWcldqVEs1V0hiOXlGdVZHOFJtQ3pyekJSN1o3VHRvclAtcUpwR190bDFJMHF3TTZpV3pOMkF0dnRmRFdzQklpeGJOZG5XcjRmbU1BMWFjNV9Wb2pwX19QenFoTHZsRVBJQ19kczJqR0dGcFVoUFdEaXVjWTlGdEpaZUFXajZ5TU5KWi1kSTNhN1NweHpnNldjMWh5dkF4T0R6b19ZQW9kZmhhS01CSDhoaGJRUnF2YTBLaHlKNmJZRWFNZTFyckxFUU5uUVBZZkpsUGI4QzlFNFAtOGdhWV9sQVlGM1BzWGczOEV1OVpkUFJaUnRHeDVxM1pXMFVtZmRIQTBiV3BtUk1KOFpTVnVWaFhWaXFZSV9lVzBwQlZYTW9ZOU5id04tMkZtWVRVc1VWanlDRlduc2ZHamlycGZFX0I4OVBxTGdGLU9RQWNzMGF2TVhKR2VtQUVkclFTQ3dlSkZzOXY4bkhQOW9hMEE4cExmRXk4VUlueldiLVVzYTY1V19HYnBUdVJwTFdpSHBGd2d2aHpTeF9TREFxZHBtb2dSTC1ncE85X0h6bUhsWW1BODdpWjdPNWZKd1k0WTBrd3NSN3lVQ2RxRUVVVG9BM3ZfRTdNcWQ5NU9HUkN6WFg1RXlVVW1zNGY5dC1Oa3RFd3Q4YjhpZTRPRE9oVFFNV25STjI0a2xqQnJNU3JyNjBMOUtwRWNaOC12Sk5nM3FoLW8zM28tR3Jwb2JNeVExOE1Id0xDN09wWmJLTlpEWkw1SUtoaDJNc1pHTGNpWU5QVGJzVkh6Q2wyeHZIbUg0SXVQaHoxLU13cUhpNGpveG5PUzRSRXlhMGRNdEl0dVlfRURTcUFXUEJBd3l3bkRBUGI4WXhpV3B3cHFCWUY3VWtJaXBCYXlzdHVwSjhPX1FuQXJLMFAzc3p3ZnN3eUFhbTE1TEdEN1U5eUhFWW1yRFM3Q29CRzE3aFlBdlRuTXMzX0lDemdJWEk4ODd4bXJuS0tOd1g2V21xVHE5TkwwU01QNmR1SHpVMTBHalV6ei1FOTZXRnBqRno1QTZ4eDI4T08tWjNvLWllcUYtZ1BmeURRMmhIV2JrV2RpQjVzRkxqbkZQWS1zRFhrNmpfRWpkU3R1ZnJQazFFbDRfLWN4Sm52clZCVVBiWXE1MWo3T2N5ZWNzVllDUVJHenBtNkVBR2RaOFg4Tk16YjNwdUdubHF1Q0JjT3d3Y1hldTIyMHpkR1MtUGJ3MEdGb3k0dndiRnNUbW5ZYlhZUV92NXpYLVYzbHpJcUxWUmhGYUdsMW1KLVRGM252SC1GSzBSTHg2ck1MSFJYWURCcmJKSkx0cHNWcWhEWmYyWmFWVE1mcjE2bkpCLUlROXVxMzNOMDNRLnh2amZVeFBxYzVNRkZNcW42SWFQRHc=AAAABBcSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRruBxrrB2V5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAuR0dGajFFdllFRWhwWkQ0Z1JmQ1NpWFEtODN6ZmxxOGZ1VGtFNUI3ZmxDSkVEVHZua2xTTWNIXzV4a1dweWw0SjZUbng0MTZXU3ItUFVOLWNLTkVmZXM5MlIyUmNWSEJ3Z1FsbnFjSTljaS1wNmRRZHp5YWdWekZRWTIycHZOQU9CUTRDMlNzOG1YX3pCVFMzR3JXbWNTNWw4VVJ1SlBkRTFqRmtPVlA1WWhfZ09aSnNpZk9kam44ZWFDNEppcUI1T2JfRFp5aWw1am9GYW9zRnliZWhiM2RMelh6WnFFRkFYWXFuOVpiTlVQWDZfU0xXSVFLUDVGTmNFdHFoaDJXMGpaWFNzeDNoSjZBV3Q1UFhuQWZIUENtdnEtS05aTXA5UmdEd08yYTVRdGR5ZlVZd1hkcWRXdHdpU3Q0b2NTOGpFWjYxU3BjTFY3aXp3WVpBYWxZYlBtWDdqU2h4Y2FVWFJXZG9pSHE5RV80M3JsbU4yVWVRMlg0dEdLNUl5U3MtX3hSTC10SGo3M2pHcWdqS3pyZExHQmJJTkwzLU5fQTFPZlBmNzRnYWQwWTU4WHRqeXltSHE4VUhsa0tzRHhVaWhHdGtualZXbmVNRFNLN0M1NUVQRUJaTFZzWHp6THQwc3N4b2ZFZkxVUFlaU242TkRUelFlYXgtZjRiTTg1T0M3ZG0yV2htUTNvZzhGcTFXeFR0SXNrOUhRVk5YaC1wN2tSbk1FeFJfemFsOThGTTZjWFlOenJfc0U5eUdBeGlWbGctOW10OW8tSm1YWDZrbzNfcUlLSnhHVkRha0FXYmhGSmJNQjdzb3Nhd0pjQ3c3RFJQbXpqa3Rfb3pFc0pJaWEyT2lmZlVzT0FMTlpCTlVra3VVZy12UEJTZVYtbGwteGdHQ0VuZ0tWeXcuX21GZ3lXTmVYbUg1Sy1EVi5ld1BxVDlReUFEdG1mc3ZLN3M0RkpnU3g1TzZGTW4xVHJ5dGs0SmpZT1Z6NzFzYzhBenBzLVJyb3ZDT0RnbTBpQ2t3VENmVklwYkhDUmhKY0dGUEItdUpBdlFfbGJ6SUp6VVNrdk1rTmdDOU9DMzE2NlVjeVpUemM5RmRsMU1qMWxEdkl6THhPWDhVYlYxeU5EdDNKMEZDLU4wblFkZ2xxeGR1cVEwaDFzSDZPNmtmVWtWZklfNDZlXzllTmgyS1Y2MkdGTHJiQ0xySERTamZyNHdzLlQtSElPbUVjWFZyb0Fkdklvc2RJeGc=AAAAIRISJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRrpQRrmQWV5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAuSnZoNnJkaGEwaDBzRHJxMFlKUUlkOWZKbGlOc3lvMWhmY3psT2RNSloyTWZlZlMyUUxaSW5ma19tLUJvV240NklxZEVCcG5WNDlPLVh5Vld4WjR3SnhuMm1sTXNTakpJRktRUVJja1JoN3Fsd2wxSzZGYzFJRWhVQkZMTFFpb3NYMnRudVJPa0xxR1M3MzZ6N0FCQmMxYVAyeTR6UVVlT1ZCR05KSXV5bDUtTm5GSDFXeF9fZE1lcDU2VDFQazIwTHROOWxzZ19sTmczME40ZVY3bnoxdTFkQ0RWVDF6T3pkVkUtZDBWaWJwdGNBUFJpZ09jRUI1MS03clRDM2Q1Y2xiOWFFY29Sd0hmYlpFb25vOS1DbU5abHVuZmloWUlKcTFxYVNJa3Ffa2VXWXI2Q005T0xZSkpEN2U3eWVXQ3QxWE4tU0RsMWNIOGRxSGE2ODg0ZklSY2hoZkhZUGJ4SmlDYlBzZEFzX0dyWlFtUk5Xc0pfUjJSRnh1aExmR1djRk9HTGdfSjdmUXZ5b0RzbkxpczlGZWtSb1o3eEtQRVZLUVJvVzJWb1VXZ0NjaC1wYmd1Nkw1ZWZqNUw4VFBhcG9YUVgxUmhkcGVQeGNoUDBkTEY5aU1xNkNOb1NwbHhyQ0RUUURBSTlQS09TelZDQUZZa1dQV2dQYUlEOXgyYi1WVzlsYTcyamthelNLcU5LNU5wbWhTVEF2MXBuMnNrOGZYbzMyWk1DVnQ2RFhXdkNLak9jTnNZOWNCTEpZMkl3amFSWU5mYWZETk9EZEs4UHJ4anplLVg0Rl94SjM3X0RlWW1LNGtGTnBvRmktNW1BMmRPYkZmVDZIdlhyRmR5Y0tsQUFyZ20xUDl2dnZpWnk5S0NnR3JWSjJDczhSX2NSZXJHRERPUzZ1YTQuT3JyWVZ3WWxSMDZ0X0JYNy5nQkNZQXlVZ2plM0ctalpMU05DMlBIZXBpVzNSa01yNkQyOGVueXc0LUdjemM2VUJqSjBFcU1rOTU5UVU1OFlUSnp6ZS1JMmdxNGhDMzdpZ3FEc25IeHh4T0JEWlpmbEdFdnBPQkJsY3phTUpuTzZHUTVVYlptRVljWjlMaGczemI2cVJJUExaRVJWU2VmY1U0QjdnU3BUMWN5ZnFYRjlxc2hjM2hOajZ6VS1KZEk4eU1XTFNWVV9tWVdJbHprbFVpRTlXRmp6cVh4ZGxabTd3cVJoWVJWWU93TTl4dFAyalRSTzhQa0ZrWk9RMmFDSndJM01veENVRVcxVGpVamhoUWF5UGx0TGtPc0NvWnM4ZGFsbUxIZ085ZWtFcXNabU9wZjNXU1NTUDU2U1Z6NUFaVkNBUDh2alBIdlZabzNROTR1M05hSlROeXZTM2VKV1l2am53bk1yRnY3ZEEyMGd5QmVwVFM2VmJMLVhELWo5blkzb09fbm9sVVZtLUZEQlVKS3ZTdGVydzdRX0xoUUlKd1dnaXdManZhWDNFNDA5dU01Z1FNMFpqMWpMMDVVM2NPMldnQUE4TEtqSWlQLU94QWFLSFg5ZE51RHljQWw5bExUMDlmd2ZCbUQxelJHZTdHZW0wSnVxMVljRGp5U2RGRWFfTEJiaHBndDl4SE1PcENtUU1BdWxLbnF6eTVXNmVOMUk5V1hmOGcyQWJNWURhMC1tRE1OZW9kUDN5enJ3elR6bW1yVFV2ODcySUhsMVRZTmZBTGJ6LXNFM19aT1FHeTJ1bHRIT09nWW5LZVNfVVdHdWNlWnFfdU1fSDBrMXc3N0tTQkUyUzFVclQ0VzBHa3J4LVBsdTJEZWVRMkJKRGVCVWFLWWlSbXFvaGUxWFk0R0F5YmZtejJ2TkRhZWtGS2IzbTBkNmxLM3JKdGVWUExudUlKLVBlOHQ1SHNMWm1NUzAyUzB0d2ZrZmRmdWJEYWg2MnN5d3h5Q0U3dmI5V2oxQlpBVGZnb2x2d2V6WUdSNWtzSVRQcDR4dnNkYVUtSzlzUndBbm9LcVp5MHUtNEVXTncyM2VCWFZkTzY5UG01M3lSLWtJS1J6bkQtMU9CSGg1cThuN0Z6UzBGc1kwY1BVR2VSMzM4SnduQjcxaHlpU1drbGJMREIzX09TdzJ2aEpXdUNQSDdBbTdXcnlIUlJreTFrb1ZfVDM4LVJVZ25idklsNXZRNVh6NHUyck5WVzBMVlYxQzNwVFJYbS1pSVJtcWFVYlhXTDZUY09JbkRsZlJ2ZmI2Y202MndmVFpPRmlZcWtrelJmU2pwYTNsdzFFN25FZ0tEb1QyM3dtUW1zRjc1NzFlZk9NM3p0Ylh2a2FuS3dSTm9sWDdHUVVBbnJpZ3R4WDZHOHZnSGtVWWpJR1ZPbXFjT0lOR1hFdmlZYTV1UGdoczR2VGxZQ0dsVlJWQzY3T2hHUlNSZlNtWFlpb3dRcElYTURvem9UUG9jYkZpRENpMldFUzdRQklBMWN3Rnk2aGR5VHgxbFF1ZlhVWDdBcUFnLUxHWUhPbHRjYl9scnpqX3RodjVmVTM2SWFzR1RfRTVqOEtQeXNKM0ROYTBwYnB0aE5Dd01NYUxPeUIxMnBYMjJ5LUswdWI0cktzMl83SVE0TTBEUEpIbUdTUHdsZFM3OGRmSHdkNjhnZEJyaDdVRkNFeUcxQTB6dzdCTmFROHg5ZTJ6M1RsM1FOaWZUWWtqM0U4b2RIXzFaazVsaG1tTERsOTdSblY1YlRpbEJIbTRqUko3dzhRR2FZMlNOTHpPc0pLcS1fbjlLWU1jVnAtajB0ZkY4dXQ0M0RFNmJfb2ZyVVdXT3g0OVp3Ym5MREFzaFlwRFYwSmRDUS02S3d2ZkNoeXFwTWttTkJDX3dpQi1vc2YyYkoxZW5oSFpkZmVfMTdEa21oNlppeFFGaGtWeXNndDR1a2RpcVdqQ25NbFgySHBybXBqMEpBTmhnbkhfQW5CaEJEdnhhdy1TRkJQQzVwc19FU2UzSlJaODdmV21KZFpPVExUOUZhZVloVnd1ZVROcU1VLW1WSVk5WXJZcXdRTXJnM1VYMEJ4bEI1Mm03Vk12RFNmRERCd2l4SkRzbjk5Z0R6QmRQS1BoaEVaWHZrRlZBNGdIcXBRUlY1a0lDX2ktS2s4MEVYWnlYWEQyLUhHRDY5R1B0V1FaVVpOT3Z5eXlPNTJQNzFnSFgtdDExLWNiUTlpRnBoWHdiTk5SZE1xZ193dE5jQjE3cWlCRHR6Z1h2ZUxwR1VKMUQ4NEllMG5zWUtBQmFDQjBnU2ZqQl85RmZNV3F0S3djSk9uUlB2SjYzcHFOeVBzOFZJNDVxblNhaVFVd2RpandRTXpRZjhqdmpldUd0S1VZckVSZzRheXdfVmM3cVRUQjc2RmpVZTFENmU1LXpEeTRJaGMzenJEOXFILWgzbFlrcjJWUi1pS1RKTnd0NGZPcGhZbzQyQ2FjWUdPc2J3dng2NFZiTG9xeEJuWFZXc2JfQlktX3Q1dEVrTEttVjFaNGpIVmF2eVloSHVHakpEemE3ekhoNW1tZzFQX0hPcXNtN2xIaG01LWNsYUNybVJOVnl2VTJEWVFRTWdscEdmRFRYOVdhM2diM3ZQNk16Z3V1V0VGSXNQQ1pLWkpUaFNwUVAwcU5lQnJsRTlMOUkwM1dVcjMyZTBkTnpZMDVaZWxaTTFENDV6VzYtd2twYzUwZ05TbTAwRV9Pcl9DeXJZNlBLSXRCcFhCaFlGN1E1WVhhWUlBVmNZaFpZQnF2T29zb01LcHcwcmJMX0p4QUNHeVdSOXhwc2xxWTItRkVlOTAtcy03UjF5MHctR2tJZTFQb1NGODcydGYxQjZkWkNZRnVTTXJqdlJhcm1ldGdyZ1dXZEJ2U0RKWjU5VlA5bm5OQl9jZjQ1WWhxRWU5djY3akZCQ1RMOUliSUZUd1RsNUV2c1pNakJsMWkzVm5CWmVKUnVVVm1fcXFJTHBYTWtKMnZ2VVotQzhQRUNzS3F2Z29uaFZGT0JURFBwWl9CVk9QMFRFaHJLTkxEelB3TGUwcWFzdVVvR3FSSmtzd2h3bDF3ajI4cEVOY3ZOTzVTMmFKOHNGbjVmNTZ1cGp6WUhGNUN1dWdvaG9UQjk3Z09acjlSMlF0ZHpxOVNUaEFLZW9QMHY3YjNrdmtJSUFsTnNJUE11em9wbkhXa05VMHg1VHh3cmV4SjkwbEs0NXdrMV9HczRZY2lOSjdPUENzbXNVSHhNVnBFN0txeFdfNDhsXzE5VlByV2JMcjl5TjV6NUdkLWlyeXNKWVNjdFFlcnQta0lrb0xnNkU5UjlVUzBWTWltMVR0WEZfMXNNT19ma3dfdlNraVQ3cEQtNE5yTHdjaldjSTNHMnRNNkNiVDB1TlpmcjVCb2Jqak5IZFFRYVczZ0xKMU5FNC1JWjFka1FUNGFkWnJWX1hZeElnQ1NRSjN3bmFFQlNqV0hXT0ltd2t0ZzJURW05ZWNFQklGVnNqM0lYenMwU0NoVW03VE9uRmgxdmRyYWRFWGx6T2lQT2lQOGZxMXFiaEJ6a2NhUGpFd2FOQUhIdWVMTVNWM21MVmVDNXVONFJ2MWlOMHlYMUcyUzNpVmdRVmMtRTFOM2pfT3RsSE12d0tfSFNCZnpFcnlmLVZCdTRGbEVYS3c2ZV9ZRmk3MkJldG9aLW5sLU5EZ3JYS2FyQlltd2ZmQ2VOVVg1eFRjTnplSFZYV25IWmswaTFGWmxHSktVc1FnRS1IdWVxdlZYd0dfbFRtNVpGOXozbjFfZ2NVdjFyLXNfWlc3Y1lKNlFLQi1DWkVUZTBKdXNnNXVVTlA5ZDkzT2FDTmtGQmtZTjZrOUdja0FXdkJhYURwWUE0N0FXcU9COGZveXEtUUtKVnBDWTFkSm56V1A5Q2k1cVNKOVV2RlZuVXJWRmJqa2l5MHFrTVBnR2NIM3pqSi1mbFpJdnhvZEtzVXBtQmdzSlktUExXT1RPaFpBWFJSR2pxNDFmdk1zdWRKdDJ6SXFSdktsNGlISnQxaFVjV2J2dm1QWUVITnNrNS1ZNnhTRG1nZkFTSUY3VGx4a0pXYUh5SGJXOEpuS2RnNGFzU0NONU5lalpnWFAxY3hWVXFubVRTVndhTEtPVlhOQ01jOGF4Vmh2cDdRZFhSR19nQmtkWTMzQ0h0d2RGSmw3S3JITWdDVDNEaElpOGkxdHNwNkM2TndaVHZLZk8xOVB0UTFCTllyTXpXSUdrbEdFTHJYcDNCemdXVnZWNU8yVDJaczNqaGFnbjB6UVhkcnY4cjN0OVhHd3k5VHF2RVYxeTVBZGtBazFtRGVEZWVLX1MtT0Zhejk4OWVUUk1UT0YzUW9uSE9OaE45LXVnV25SOV9CVW5KUXM5c1U2WFFGWEQyYVZYRmw3aHV6dFZCTUFnX0gyLWc2YVNyWGxzeEFPTkxMX1VkZS11SkN1U2lDbTdJcHZHS0dnZzByLUNZbzZzMU00SGxkeF9iVjVQM0c5RTNmaXVLd3JyZ3E2M3ViSnk2ZmRxMlM4RnM4ZGNmQzY1V29hdV84TTJpSWkxMlFvaGY5c0pPdXdXOXpJSWVHU09KNEJqM20yMXFjcjF2NDFHeW5WMU9hOXBQZm1ULXhIVktwVWQyOW40MjA1OHhDU2Jkb3VCV2ZZS1lDR0xyLU85SWUwOElfWXNFa2d3TVdJWmlZYnN4a1U1VUIwYlAybWVLU0Q0WHNXVjdjNmFNQ0c2MEwtMW81LVJKOXR4X29QaV9RUDhseHRpeVNISU5YQkVIWFZKcDNhcHRIYmdVQ3dESUtOX2l5dGNWM2JCcEZIWHVHUWJvNEdvb2ZJRHh3UkpGaW5qVUtDX2VyejVMcU5nc3c0ZUtEM0NmWEluVFVPUHB2QWlVVTJnVy1Ud1MyY2tiejN0VTE4WXpCM1ZITGJiYlN4WER5WkZzSG9ybmFWa283U3A3V09WQlVEbGJiOVI4eFpwV25VcGszd0FaY2xzSTYyREZ0S2I0c1pwSFo1VVJOdEVpRDlxZWppMWlkVDM2R2I5ODFaRzdTQlk5N1hkVW5FZ1RmR0RMQjdxV1pWU3FxeW5Pc254U3drenRya0ZPY0N5VVlQUWxacjRvQmZCOVkwemEybHNRX2MxT3Ntdjk4aE02QkRqMm9JMGJWdy1rQ0tkdTMwd0Z2ZGFsQlN3UG0zcEhBVUxkR2dMX0FYYWw1QzhCdlVVcVB3YnhtcF96ejBUQWtyVDlqRDNBamNXZVJRLTN0cElRY0NjRUNZTENReW1FT3NDLWNaVldQaUFfYk96QkNnYjBMYkdMOFFaMGIxUlNadjJTVHZabVpmSDlGbE9Yb3JtTWRVNzQ1ZEVLaDNueU1nc0JjLTZkdndpdVdvQW5DQWhFQ1dtTFFnQWtrVEZ6UFQ3TTNIOWFBRWh0SlVxMWdUTGVyQzZJelNsWnZ4dTVwcl9odGtpQXpPWDJfdU9lOHdDS24yU0NvY05nYk5Tb1Q2UHMzc3BKQWY0emdlVGR0cmhFdmw4NUVNb0d5dWhsOHRtZ1ZaZEZDU2FWMGlVTEtpYkxJRUx4X2NtdmdaU0VyTmg4bzBWNmNVR2g1VHA0LVJaZnMzTU5OeHJpdWlZZG1NOENRMTZ6Ry00LUczTG1LMDBGNHpWZi0tNDN6N3pyTHhaT3NzU3VoQVYxdXZLMjZxb0g4clJzM2E2YkJCSHYzeUEwVjExQ0tpUkpsbThqa3Jfc1M3dV9tSTNDcnlEdzJDWnNEY3Ztd2hUSjFkTnJKVkJzN3A3Rk1IVHl2YmF3bTZnTUgyS3dJT3lzUFJPU0VKUGt1QjVVOFZSQXpIY2l1TjVyUG9Kc2YyLXF0el9IckdzM1pNY0FXc0pyX1JCbHptYVdlZThYLVhpUkFwYnVrSkFVanUxSG5YRkg3Q0tWMUtDTWI3TXM4bDdMUDBrXzJmMkY2cVdzWDhBTFpKdzdPaDVHNW1kdWUtSU5xMUVzS1A1aG1YN09xVno3UlRrc2V2OFB3bk11UmJMQXVDb0w0b3IwSVlLTnpwQjhCbTZJbVA5ZWZpSC01R3dhX0FRQUxaYlVXTmNfRFVwNHdLWElUNkZMbjYtSHUySWJQVm1zTWNnWkFzYjVwRjVBT1hoM1Q4dzJuWl9jc3RacXgxbzRRZnpaZVpBRXpJUURMY1JOa3AtNnVDbHhuZjg0MnNiYnlfSjRxNzBlS3NPdmh0WDhHNjJQZm16aVZFZTRTeEFRZ2xoREg2YThocWxtRGQ5ZjBKVmZxclZwNFRtYlZ0MlppTFZiUnpnZG1xdEVPZUx0UFphem5fNFJiYnZPMmFsZTBELUU3ZmktQ1FiNk1WMERqSFlucENTc2FQR2dZR2g1TGFRUWZEaVV1cmU2OGV1M1JMWHNLNDF1cV9kWnpsaHAyNURPM1RtUnhMeVFvREtLbFZhLTRJOV96ZGFrU3hneXp4SEowTTlxaWQtNExEZElvSndJNWlwb2N4YXdKTHhEQjdHQW5jenFUX1JtSHhxNHZFZmRqSUF0eUQ0aVB4aXdja0Ezc2k2dWxaYktZWXZTOENoSkFqRE5Fb25GeXJjRlJpX3VRNk5YekdMZG1Sclp2ZFdQdGlLdGlCWnR2dWNTV1BqUkl1a2JwbHJndlI1LXNDX2RXZThPa3NZMGxoNDdKQ2wxUEdweE5fRlZtSXUwallIdlI3NDBrdTl1YjJTQ2QtVWczTlBYSjJBRzZMQ3J1cDBVZGk3Z1NaZzRHZjZMd2V3NmFrY01ySDZtd2NfaFFHRUt3WS1rR29KUlRMUHlVN2Z6ZHZ6LTFGS0c4dmVJUkZRZXRZS1VTUllYZHk3amxYV0dBLUx0NGd2UTNFVDFwZW5iU1h1a0lCSVZuN0J3WFZVQms2MHRSMUgxTUl3b0JubTIwMGJieWRKNjVjLUx3UFIxUHdVemc3azNEOXkzX2gwdEFmelR3U0o2VnBzYkpZZHZvN2NtU2xrZHloeUN2T1psLUJFd1BnQWYycDFIbnJhSlZfa2NxUlZkcVZpZk1aT0RnTkMxY29SWFJPeDFPNmIzVWZ5YkQwNElJZnE2U0Z2UWtXQUFnSzdYTUI4c1hndTRDVE5mSGs1VWlJblNUOWNkSjJKMFdsNTRGRzZiNWpHYlNwNHdFTkZkbGVtcW1nSGljVVo2UWlpLVpYYkRPdVM5d3laNnpwTEdDMkV0aUhBT1RyX00wTWtTY1BZYWNJd1o0VzZzU01XdDhfS1RDRWNwUEx2eXF2a0JHS1cycDRzSjdWVDJ6ZGJaeHlkNWxUUlMxeFlfXy1uRkZVU3Ffb3RFWDUtSWFid3ZyaXBLMjJCTnotLWFhQ1ZEbGtVaVhOckpSZEVwbWV6NUtJNUI0MURUV056V1pXaFZoMF9iNWh6Y1VBdThXNnNnVXFibno2c3FTQm5YOXY1N21STXZWTm55aHlJRm4zVUdCSzJoWDNETWFPYWtienh1T1dEN1lieXdtbHNEMDBESGRrQnAweVZNRXBHUlkwdzNFa1RNSzRCWENQc1VMMmt5Sl9uRGVuc01EdXZOZXM3elE1dTNDUTVYaG9BZHM4WDJ1eklqMEZZNnluU3dpRUtKTVN0NzdOUjBzQmp4QUJtbE5qa1dyaWFnbjBHVmRSR014SE9reEczMXlfTWYzUGJlUGxOVU1TT3FNU21fVE9Nc0hfdnFJY2NFVjV0YmRtbGdnZ2I5dGNxazhpQVVNVTc1Y2hrdlZrNVRlWUV6YlE3S0x1c2M5dWpjQkVOdDJhenFtTFdOcTNCYWFiVWZ6MHAxcDlxc2hxZm02cUg2VjRtSGZPcFliQ1pqS1k0ckxfcFk4YmYyOVRKWjR0LWRyNGFyMXJVanFraE9UQzJoQlVZVTZBa041Vmp3T0VLa3o4NUZEb0pKcE5VRmF2WVF3NGRlWDdXSUd3czJBMXNyNlQtSWxHM1RScGx0OEkyR0hvXy1GUGRSV19wdFFDRWl2dEttWFBNV3hLNkdXOHNkNlg0aTFVQU5NVi1LOTdPMEttZEF2aWlhc3ZqMVI1NUpKRElZMlpCUHpGNVQtRW1teHVlLW9LSkpseW4tZUFxMkx4eTlYYXd1MWxPRzJGMzN4VFMwVUNBcldIdGN6XzdaRjFCbW5kRnBMZW5VbUc3VFY3MEFTdTlFMkZtUXZhSExLNG1QSkJrTTl5Q2hpM2FmVWJ3Zm5HYTdaeUx0ZFdyVmhkYkZ0dmg5azY4VEpsbWU3NFJzR0xvMTdqa2VqNm5STDA2ZXkwQnlTc1p0cUExUjdZV0pha0RIYnE2NWd4dFBRM0tZZHBvMmloREtzdXQ4Z3lSV0R3Zm1PZTNUNHJfcW9JUmU0cVMtdnNiRmkxdjhYTFZJZGNUcC1hQnJNZVRfanJObEo0YUdXblJPTFEtYUdicjVTWWpBSmN2YzFDWXNQRndmR2ZwWDl5YzV2bFc2Rk1DaWlkTXRDRjQyQTA2NFdTSTFCcUpjX0dUWmN6eDVvWEw3Q3hJM0FXRWR3N2xiX1VUank1NV9fUC1sVnEybG5jbWVkZWpGS0VZMVdXbzl3VWZ1MG01dnY0Z1NQZTlaMUwxRGROc1A3ZVJRUmV1cENUa3BjMFk4ejhsa1FlYVU4SVZKNXFOVUc0ejRKcHQxMUtVYkpBbVRRWGpxYnRvbl9JblZmR1N3dWgwaFFuV1JQUHZzYmxxQl9wUTBQQkgzNEROS0UxeUpXUG50ekpUa1BnYmJKaEFTLVh4MlhoTjNjbDRWMGRLR3lUV3B0N3hVcUZueHN3bjQzRkNJaS1iMlBIN0I2NU13QWU2ZDdSSnVEUkM3OGx3XzVYTE1SdUhNNTFub1haVUlaamNGd1ZnVzdZRDVZNFBja0p0bnUtNDJsVWI4eTBXb05oWWFyV29sTVFUNkgtZG9iN2xsS25oaERQX1NDT2NoYUdYdmpCdFVLbm1GSllGaVlUYWhNb2kzTlRVNkpjTVhXZFZLZU1OV1RqQmNnQ0pXMmkwZ1lHMlpwVXNBUXp3UmQxVjlOM0pldnFkZmNUUlg5b1ZndlJQNXZMa1ZJbXRidXBsLTVBbDZyZDdTNDlMMHR3QVQ1MGlvNHU1YTk3NWN2WXR2UkpWNVBqLTV3ODFxcUtZS3hYanM5dHcxc0NHbmlVcTVCam9McGFVVG1JbENhdFAzYWUzdWw3U05GZE5NNjRxaFVnSC1kZWdLa3Z0NzRIbi0xUWY4US1DRUl3RWczTzVtdm9KYmZpanVGUUdNaHJGMkNWTmpYRlJET0dCSU14QU9SUE5mQUZnMTduQ3ZQb1hTa2pBR2lObEhVSWlpZFNKMVlWOHVmeTBwaDBvMkNfTnNfU1E3d3B4d2hFbi1hYzROSWY5Y21yRnBYTmJtZ1lhZ0Rpd3RwamlrTGFsR2x6cGR0c3c2cGE5RV9jY3N3Mmo1aU5wUVdFZFU3Z2NsYVppdFJySnUwVTBhWEY0UGNTb2Q0SzRLUnRfZ2FQSnlBQ2JrRWN4OWpiNFJtV0NwZTdKZUhtbWExdWNDdWNHdlJSck1oLU1seEVGcmVOSEVzdlNUS3JYeEFtcG5vTUJta05yeEZ4aDh5SGxXWlRnMW1yTFo3R001UmdYNWZVYWhNdzZLeUFJWFd3X0RXOGQ3cHFncHNIcl9hajZ3aF9NcU93WkxrZTh4OXNkRnMyWDEwaGlJOTZYN1p6WGN2R00tNU9qcXZuX1ZheU4xbEgzd003ams5M05GaWdjMWlLZmtOMXJlRVd2dmlUbi1xU0VQb1REXzRmTERqdE5IRWlWc1hmMGR5WHdFLVZVZTI5Z1poa2FDTjN4WlMzeFZzNUljaFJiT0hxNW5JWm9wZko2U0VYZ3JxOHFXSzVWYnJ6M0NjZE1LcjBDS3RLSEdWNGNxVWJFTHBlNkN3ZUZzTjB1RUZ2WjNPTEJDTHZIQUl2al9pQk9wZGRoOE5JSnAySHRkTjYyUHVhVEMzV2ZDZjN3S191ZDRTbmplcU5sOW81SzlpS1FRVHFOMjBLNEZfcldIUEprRFViT2tYaGtiZlFHQ3Y1bkxIcmhXal9CREk5QTRTQ3laQjZvTFBSUHVuc2JLYWlVVVRDZkRjeDBlY2ExWTh0RzI3ZS0tWnRwSnpLOXVmYjBWRlBzUW5uWE1SMGZhQ0tnaDd3LnJ1RHdoaTQ0enk1SXQ4YUhsWEhhenc=AAAABSwSJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRqDChqACmV5SmhiR2NpT2lKU1UwRXRUMEZGVUMweU5UWWlMQ0psYm1NaU9pSkJNalUyUjBOTklpd2llbWx3SWpvaVJFVkdJbjAua0g4YWdsaXZWcG9ZdDcxV3ljRDlIbDgySjhENHl6QTlxTHFEbkVWaU1YQU1WcWNJcmp3ZWdSOWd3QXRGNS12UUtsUUJyN3UxbkEtRGpRSU9ycmRZc1U4eUZYOThrYlFRNFpLWHI3MExoVGdHSW1Zc05uZ3VpSjQySE1QeGpSaG0yNnVCZURLTnJ5ZmZpRThlaHRGUUxpZFUwVmt4R3BWeHBkNFVhM2NaRkNjRTBfaHRkZ3VkNnRhYnRjM3lZdkFfVmg2eV82TUpfdVhibXM1VmFFeHVWUHptNGx3ZFBZWElSQzd3OGZ3Uy1TX3ZSZ1VDSUlxOExFallnRWN6dGdKX0F6QkFBTEtMa2ZVOXhuYWZ6elJndzdJNVdNNDNKXzhnTzVHTE1xb2l0Q0d6elM1bHdjWmdRd21ZT0xiSG1xTEk2SFVqOVlkcmpzcnU1WDlINzh5ejRzbDNWaUlsdHpLVmljNFdJMWYza2ZzTXNXQmlFOVBzTkpXNUUtdXJNUTFodmVIT1c3cU1tb3NFRGxOa3QyX01TVHNud1RqdUpWQjR0Z0dZNUFMeFNsVWVyTFNieFhzQ09IQUtJQS01MGR2Q2ZsN18zMmFoTzZ1OGFEZzJLY2p4NkplSnF5T283bE5ZUHg3ZUdhRXRaUWtDZUs0LXNLdnV5VmlHY2NJRnJjWlY4ZS1LZW01ZEo0bW1Ua1dNZ1lQSlVZaHRSRWVWUXp1c1hzYWVhUFhBV3ZydF83bTVlck1QWld1Mi1xUDFRZ3VobjE0ZnFoU2NqbmhkcHVCYUpFTi10MGNlb1BtVWFPbUFLY1hyOGdqWGJ0NEd0cXY3V2d6S0xBc2FSejVRQjk2ZVhtUGlBM3dkbzZ2UDBaZTZYSHVrbWYwVlJ2YVpCMXk4U3VEWk1SV1VjZGsuMm4wZmlFbFlMbnplcWRXTi5rWV9PX0VEaXNJVms1RG9tUEhGNzZVemE0RkxNT19qN1Y2VEc4WGVFSWUxZ0l3ak9VY1p3QjJtLWhSaG1ZdlRYeWd1dGgyU3UxWTFNYXo0NVhSUmlPczBDNGRYbTl5TVZJdWpQWC10b3BTWWFrUkczV2NYZXgwSmQ1aGpIQ0R2WlE2Qy1BalBhLWdSUnlpcmxnX2Y4VHNQV2JQVXJKSWl0cmduVmxSdlVrVW9HVTNtUEpRaTZZNVRqbVJDRS1vZ3FUYXYtUkxERUtveng1V1dCQnAzOHZQeW8ySkFjaDdGeEZxRW9qUGJaSHpySFQ5Y3dhX2ZYWlVOcmNIaFhHVUI0cEp6X0VuMHF1UmRsU3BhVUVyWFVXV0FIS1JmQ3gzaVF6c3k2VDRsNzd0N1hvWXFEQnNKc191MHE0b0t4SWR2TG15bUlLXzItWS00bFQwY2hlejdadVpHX3g2THJnUFZVN3pWdFZELVFJdmd5ejc2WEFGNl9wN2NZRFl6cERZZjJjUVZBbW1zc0RwTUg4eEU4RlQxNFNMODhheUxld2VKZlBRQVU1RzZUel8xVDZ3cjBOWlY0allOVk9sVDVDbFlhV1pGZkxRTEs2ajNOamQxUW5wNUVzU3NYajZIaTJuWENlYTFjNkxKYS5DY1plTDZRLXFqTThzUzJSdDA2RzZ3AAAAAEASJDlmZTEyZmMwLTQ3NTYtNDI0ZC05MzU0LWIzNGMyODUwZTdiYRoYEhYKCwiws4yuBBCu2ocbEIiOkwcYwaMNgAAAAA9ncnBjLXN0YXR1czowDQo=';

export const ExecuteScriptResponseJson = [
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'data': undefined,
    'mutationInfo': undefined,
    'metaData': {
      'relation': {
        'columnsList': [
          {
            'columnName': 'responder_pod',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 400,
          },
          {
            'columnName': 'requestor_pod',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 400,
          },
          {
            'columnName': 'responder_service',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 300,
          },
          {
            'columnName': 'requestor_service',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 300,
          },
          {
            'columnName': 'responder_ip',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'requestor_ip',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'latency_p50',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 901,
          },
          {
            'columnName': 'latency_p90',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 901,
          },
          {
            'columnName': 'latency_p99',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 901,
          },
          {
            'columnName': 'request_throughput',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 902,
          },
          {
            'columnName': 'error_rate',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 900,
          },
          {
            'columnName': 'inbound_throughput',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
          {
            'columnName': 'outbound_throughput',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
          {
            'columnName': 'throughput_total',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
        ],
      },
      'name': 'HTTP Service Map',
      'id': 'd8c0d2eb-cf90-400a-882f-2087ffe8c901',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'data': undefined,
    'mutationInfo': undefined,
    'metaData': {
      'relation': {
        'columnsList': [
          {
            'columnName': 'node',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 500,
          },
          {
            'columnName': 'cpu_usage',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 900,
          },
          {
            'columnName': 'pod_count',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
        ],
      },
      'name': 'Nodes',
      'id': '898c212c-2214-445e-ba0b-7d658d8ea922',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'data': undefined,
    'mutationInfo': undefined,
    'metaData': {
      'relation': {
        'columnsList': [
          {
            'columnName': 'namespace',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 700,
          },
          {
            'columnName': 'pod_count',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'service_count',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'avg_vsize',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 800,
          },
          {
            'columnName': 'avg_rss',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 800,
          },
        ],
      },
      'name': 'Namespaces',
      'id': '31a18598-7da7-434a-8142-8dce86563340',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'data': undefined,
    'mutationInfo': undefined,
    'metaData': {
      'relation': {
        'columnsList': [
          {
            'columnName': 'pod',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 400,
          },
          {
            'columnName': 'cpu_usage',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 900,
          },
          {
            'columnName': 'total_disk_read_throughput',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
          {
            'columnName': 'total_disk_write_throughput',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
          {
            'columnName': 'container_count',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'node',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 500,
          },
          {
            'columnName': 'start_time',
            'columnType': 6,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'status',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 402,
          },
        ],
      },
      'name': 'Pods',
      'id': '873ecbc4-3ca5-4a1c-947c-434ecf3a7865',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'data': undefined,
    'mutationInfo': undefined,
    'metaData': {
      'relation': {
        'columnsList': [
          {
            'columnName': 'service',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 300,
          },
          {
            'columnName': 'pod_count',
            'columnType': 2,
            'columnDesc': '',
            'columnSemanticType': 1,
          },
          {
            'columnName': 'http_latency_in',
            'columnType': 5,
            'columnDesc': '',
            'columnSemanticType': 1001,
          },
          {
            'columnName': 'http_req_throughput_in',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 902,
          },
          {
            'columnName': 'http_error_rate_in',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 900,
          },
          {
            'columnName': 'inbound_conns',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
          {
            'columnName': 'outbound_conns',
            'columnType': 4,
            'columnDesc': '',
            'columnSemanticType': 903,
          },
        ],
      },
      'name': 'Services',
      'id': '3a397736-fb3f-43db-9f27-f993d1363537',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC52MjdhUjhkbFNsR1ZqdWRFVmdjS0Z3cUtQTFNQT3BKaDgtV3BYYmpFbV9BUkY1OTdIMDhZUE9hSEROdTdyMEE1bzItNjFqYkMwRFJtaDF5WHB3a2VVLXVjdHBlVE9taUMxVW5VMEVhczBOMUYtdk91TVZiZG14dHB0MHhDUjd1MFg0RS1BTUV0SENfM1BRN1ZmR2FCTDg4aWF3NDlURlZ2SVliUGxlbW81THY0V3dWY0J2OUhsMlp0YVUyU0Izd2M2emdWMXpQNmdsUEhKU2ljU3k0VTRyQ1BGaEVVVW5CUHd3ZTdtbUxYWkpwUktCTTVVUmRpNjI0ejhCbXloTEh5TjJGTE14N0NFU2p5d3M3dU1QTTB4aWlGYlVhQjkwRkxub3dKTGNwR0MyZzJNZDU1QURPMDRuS2IxQ2ZCYzhLdTFxRlg4MzVrbjRTQ2FvRGZxQ1lFMjVHUmhTeWZobThkZWxBcndmYjQwaXhhbmsyRHEzWmgzYU1pZ05QXzBsaWMxOURnVWdvUllQM19xVUtuczA5TUxZQlJJWTFpeU5Ub2x2M0dSLUoxNEE3VEo0ZDVVSlhDR1dlNlU2dEt3TmZ0TVVsRUVWTXlmTUg3TnhSUl81UW5oSFQ1ZXJQanBXa1NVWDcxWmFUdWxJVmhhSURLdVJITGVDTDc5U0d1THpSc2Vxb1VfRjBKNzdGUkxJcjE4X3BWOVlBeUNhSkJjc2lFWVl6bWlPaXBZTDRHLWpnNmZCWHNwYTZxay1lRFN2ai1BaUJXdU9wVVAxRlZPRHJUX1pXdzgzMks2ekVqelVnODRPUzZwOFVicThHUC1KYnpPVllJS3E0djlxNDJ3aTdXUjVvdzJaUGJnSlhTYThOSlFuS2ZlYmJhMGNjSVY1MXl5R01iS1VtVVlCSS53ZVI5OE5meEw1T3pBcG8yLlEzSk5TaXY5WjhLd3ljMTh4LXZ0dk5fUmJVMTZYeHN0YVpYZGxwc3lLWngycU54dk51RmZLRXFNMEhnWkxkX1o5RV9Ma1JRdzNYMm9CbFFtZGZlUmkwcEYxWmZpbUJZcVBNakMxN1VobzQ5UFpDZWZQcl9fa2ZUd2x6ZXdjS0tjT29YdmUzeHJWMWJUbmUzRjh1eXpaSXhxZk52Mk1wNVV4dkN6Qlp3eWpBQ092ZTg3NE1raW55OUhEaWI2eDgxTXVsWjM5ZGVzek0wbjJaVUdSNkVKZ3g4dXhyTGNtZUFXX2taVHVvc3ZrMHhub2FXWGs1QVByUFhuVVBTcFJqdnRTZ0NHS2cuRFlLSkszY1pHbmMxTk1ueVJIbE1ndw==',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC5PSm56RGQ5Y1FHS09tekNYOTlCZjUyVFpXOG5wSDFMcE9Pa3A0a29TcHEwNk1rLW5RMU9ickJ6ZlIzQ1ZaSVlmaXY1MW42V3k1bXJEOFM1VDREa1VzZC1IbUtXWGFPOWcwUFc4UjZSWGw4akhfaTRQTFk2LThfMjhickI3Y3ZMN3JmQjI4X0xhbWF2eFY4Q1pEZnJETFhYdjdsdUUyaHFsRFd5Szg3NUtleVVpbDBxM1B1RHlmMGI3V1VsT3lEMDMweEFDQkhaTHFmYlAzbmRxSmtlR0tYeExraXR0UlVCcy1XcEhHSGdEekIzblBBZGF6eURfWlFreHMybktQTE9ma0swMWM3ODNrU19PZndOQmQ4b3kyM0xaT3lsSjAxeGswX0l1ZE5fUFBpbVBsUWJtSUpjODIySkJkaEl0bVl2TWtZRkFLUWFjXzBYeHBzN3loQTRQVVVjTHVYNmVCZ3ExQWZPQWRUcXhXWWcxZlRHTGZLMzFUUHVJTExLdFhkcU9ock1wWG93MnNPbHotQ3FWZWtYMndKSU1uazRHRTBvVGRoTGpEcnc4MDBVZzhxNzRLWlJhWkFIb1JiS3ZvZXdqVEpPQnZQS1JLWkw2VVZ1M0Npc3kzQWpQbVBUN2NZUnNtRXF4TDBBUXVrMGJsX21NVF9ndmFONWdxRGtOamhHLWhfZ2xvMjlib0RHd3BhMUZaTFRQRGNsYnpBN3pGSm9sTHM3TXFzMmc2M3Q4Z1Q2U1hIeFpYdmlsWlU3RUlfcFk2WDZJOFd2TGcyWXNZMXNLbXdtNG9zc0NtNHFnRWtqVHZTMkNYSld4SGppWUp4aUZKMS15czF1NGVkVTU5SnJhMlU3T3BzN2h0RXRtM0xEWDJWVlc2aHBzNTRHSjdhdWx1WVZYbmtWUWVPby51TVEtN0k2eXdOTVZLRkxJLl8xM182UURwVjg4WjF1TUloMl9KNjlhN3h0RGQyS2laVFhfUmt1SmU4RWs1RDZrOHZoUmFXYzlLU01HS2Q4cEo3elVMNmRDd0VhNzMyWDBQS1BEVW96amx4aUFBRGNpYzNTNUdlZEtEMXltajVvNmQ3WG40MDdXYVRUb1BsQ3d4YkxFbVV3OVFpbXlUREFlWE0wMnRVc29EdjE1WjllSDc3YXpZWHk2SnF0STlqWVFUVFpBYzU0LXdZYU82MXFzaVdUS1BENEpHamJDVmVOQWtSRGhxS2dqdGhGRkFoNnJaVHlTX0NSbmNMTVFJUWRGRXRsZm1YU2xKdzg5aFpUN2xaWWRRbFVJc2x6N2VjX3pxMjJwUGdsQTlNcUxCVFAwSEo5ZXR3Tmw2UlR0WU1HQkxXTFluS3REa2M4aVBGVmZ0akpWaV94VmFzUHlSaUFPb2lPVU03X0MtOFVsNXp0eE5BakE3Mno1NWNmT1NTZmFUaXNGMDZDYjdKeFNZMkRYSGc3ZFhhMG84R0hKc3BqZTdUMzBQSjI4X0c1TllNSHJ0elpHR2JyelpuM0MyUzJnMngtaGtTd2I3T1R0Ym1XRzhreHVBWVVqSndxcV9lQ243ZWhyU2FYcEFJVmRmYWpLNEY5UEpGZGF0UUxUMDhrbGc1WEFoenh6TldMRnVrTUJOdkJFSFM4Q2lCQ1g1STJUc2szVVNDUXJJM2wzNzBrXzM4UG9iLUlaRV9iN29hQV9GNDR2NzVGVjRYaHJWVlVaSnFVRFBGQ1BwTGZCX1dqaHBzekp1blgwTFRWcUFpOEF0WVIwc3NYdkxDUEZOTzFxVEFIRnhQSi1paEgwanBfaFFQZDFqQTdxQzlkQ3kwLVdKSlhtSDU3dzR3cDVRSVY4TkZpZDhKazVOMFctNmdMa2wwTU1DQVViVW42dmMyTHlLUERqaktxWjFZRXQ3c2hPNi03LUhlcmJNZnRsNzd1czVEaFhPeU52UWh1X0Zwck9LRHltam02ZnFGUzM3d2tiQ1hYUEU0dGlHVTBEODFrMHpOV3hERHBQekcxQ1ByT3NpazQwM0g1NXdUcFZIcS1rVGxvMEVKWVpFWGxjdmhITU9QRUNjdm9VcFJUMk9jLXlnU01kOWlFeG9IMncwbGNJenE0SF96cFhYdTBjb3hSZFVQN0JQWFJMVlhKVF95VFprQWw2cjZtblRNR1ZWN0pWNVBvV01sMU1ldjJtbURYeDRnTGNJMktUbnZaVmtjb2pNX2phOUdqajZYcnhmLUgzSXFTdUtRaUw2VUNnbXBZYmt1bWIydHF4Rm9YZHRTRTZsUlJXSW1pMVEzV0VOQmE1bjJRWlBuSnU3Ry1RSW15Mmsyal9Vc0RIWkxCV2kyMmE1dHBPMnBRMjZsZnRvY0ZITnE4V0wzUnRKTlNoOGw2M3VBWXJDR3lfbmlETDBoQzNDWFBESGsyWFN6c2dKM2lFS1dpV3hlNVFISVMxeVpCTmVFdFhDeWtHV21OV1pWaXI5dUJHYVI0bTZ5RURobTZWZURVUFFBdGNlaGs3UUNXUEZjRmlCZnhKbnZNU3lmTmoxREJJanZsUDlidXR3TC1aVWFvMnYxUUNWa0N5alFUM3ozb1Z2VDhnZ001X19YZHFlU3NUMm1lVENBQ3JCOUpXZmp2aU5sNk5zX1Y3bVFPZF9XYlNqQXpUV2tLQldtbkVFV3FlOHVxdnI3YUpTMWhrU1BXdlIwUFROQVlwV190MlBwU3VaSjh1NWRoVGFNajA1b2tPSE9vbi1PWGQ1SV8yNmFTaWNXM200RXMtb2Q1SmllSEJ2RzVOblpCUTNJTTlyWWNYRTBPX0xaZFdyWUpHZ2djTHRkV2pqTjRFbUV1LU5mZS0tT2xyQ0EzOWtJVnNEcHlXZGhYMUp5X0FzckNrdURUa2NvUU9JWXdINkhNcTh0VzJSTzRkc2ZFd3JuZVlycUNQMmd1YW1mZmIwTFpvUHhxOXBZMkdtM2ZtUlBoYUtqdVA1TGpSWjdkbzVwR1ZUTG1tNHc5dUE5WlBtLWNFbk40eXJWQlJHNDV5WjAzMVQ4aW9NVXR2Z055anJJOUp2bTFBMHpQZVhhWlI0cktxOGkwVmhrY1BmRm1YUVlZVGR0bXNnWF9yRFpPWXdTSTYtUktMaHF6NWtkeW5JWFB1TFB6bGRjX25rY3dOdEpfNTI2M1VDd0JkenZnZms0M3otOGZfa2cyeWw4SWt4SW5IX2dYVlptMUNNTllxc29iS2drMy14TWZ1b0FiVEk5ZGNDd2E4UDFHWVdKV0p4RUVVRE83SW0zRDVtVm5oUVBZdFVuVk9menBIeW54cUN1S0tzdllxcTlxOGxYUlRtT0Y5bVlLeE9WdmpvbExWMkZpanluUzZheHNJNzZlNVJ4ZHdzSmlNaVdYVFhtS05mN3RCVDFkYTN3akdBZVVlb09KMTdoM21LaVFnTTF2UUdDcnRnQ2xTeW95QnNXdllPWnh3RXIwSkJneEE2cF8zdkpTZjlxbUJVM3pUT0pqX2ttOVA3OEdWRVVLTWk3NFgwVHlqR2FPYUUtSGxYYmNxOFJBaER3V3g3Mm9DSVBUZURqWXdncDF6RHZ1VnF4MWRpZS0yZ3VVbjdSa1I2QlFRMXlpNmVXMnpsUUZNRHhqVnNBc1RNajlsenZmSzZuWE8wcVlpYVQ5SjUtc3dERDFkVEtyYURoQ2tUNmxCLTdFSC1tdmIwOFFtYWh1NnoxM0h2Y3ZpTFFYUVg0bWpnYlRFOGFCLVQ4U3JUbXVuMWItd2V2SHd2cFZjV0pxYXhtQ0h1Z2RpcEM4WF81djM3bGtTUTc0bEpmTmtFWDhjYURqX3dPZEsyRW5TQTRaTDIxdTVJVzF0MWRMRTAyX1FFcnFpWUtWSkFwUlZ4Y2g0c0xra0dabXRMNFJRYk9oUXlMYTBkQXZZdnNGSk5VbzNSUlJCaDZ5X1hmLWRqbjRSYy1uMmZPazAydFRGdkp3XzRSaV9qd0xscm1oWjVXcEY2UzV2RFRxUVdaQ3pScG4wWnJER2hPWVVFWTZjR21GeHdDRjJPWmlNMzRWSU9nRVZ1M0pWNmNjV1BXZ0hSZzFtcV9Kb1pCSjROM21TOWZEQkllWGp0bTFTWXRCczB2VENhMjlrT3BCZXRqdWxJdEJDNzBDdHdhZ205MVFxLXhvYWVGMDQ5Vk44U2x5UTVvLUJaaS10cGlERTVJdF9qQS1KMkNhVW1yWTB1WXFFY0hUOGxGR2U3QTV1QjJlSFRfWjdJV3REZGs3UHIwSXk5YmFVQVJjOTJrT1A0aE9CZ3p3eDRPeFo2cHRmbW5PWmhhek0zWGhodlk3T0s4MDRWMUFidEN2N05jSkhiSUNzQ0dTOG9wT3oyRmJ1ODF0d2ZaYm9SaEtLcW9NYmFiekRCWUwtY2ZoYVkwTTFXYUhDMFgwZWgya2VMMDdGb2pScUpoc2NOZExEdEs5RGdRajlhMnlZckdhemMzeVRheUJERXVBMEIyMjFNbWU0OFJZVkNlQU9KbVdGT3lmYlRKWjZnS2hhSllYUFFLVnVDOEVIQlo4UTZPcFF2R2dKcVNySk1qVWFyOUFNY3VRNks0MDNHVDRDQ2dydTNnb3FoV0VaV3pNVzRBb0s1Y0VvOWJLSjNzTVp2U0tYd1BtMzBhTWdMd2x0TG5jN2h0NDdvZ0lyYXB0QVgyVTN4WnFYeWJpU0R4ckFLdWZ3LWRST2pYcG9HUmQ4cVJ0RmdldXZ4ZlM2SEJxOVFsQ0xfVlpnSHpld0pvVnNCdnhTbGhIT0pNRFRscU8zRzZQdS1CYTZGcUhzam0wdkRDS0VpM1F4OE5EZkdJMTFjNG5hZ1FJUnFIX2d0Z3c4aU5xcF84bEdSU245WU5TRG5fTXlMNFZJMkgxUzBFTVVkdDdkM3pwUE93R1owZm04VEtvUE1PTkV2clI2U3pycnViNXVsYVZSSXdCeEhjeVNsYmM0ZzEwVERSNzNJQXJmZkdhazNiRklaRjA2VWluTEwxM0wtWFktYmxhZTNNeTlWX25xaG9VMFdDOFFON3F4UmdrNUpjMUxzZjE2bVlIZDhNMFNHRGJ1eXhtUXI3Zlp5amN2UEpsRkFFeTdpdWtCdW1ENElybHNGVE11ZUxRUWRjRnZhblJ4MUl6UmF2RkZlQ1ZsdHI0QS12eFlsLXFkQ0NLYzlKVDMtemc2NGRhQ2gwb2ZLNVVmUGg0eHk0ZVlibUFOOHM5VTM1cXpLeWtNWS1ZODU5ZzEzZlE4T0pVbTkwd2NaMXJTYWw4c1lLYlZ2azczc3d0V0VvLS1pQnJOLXVqZ3NNNHhFdWlrcEhEdEhUN2hWd0tUSk8wNFdIZDgyU2VZSDY3Q0N2UldsaC1EVmlCaVM0a2s3czVEY0lEdU1ra0dEODVUbHJzdk53bFVyRERuNlNNOVZsNzRST3lIVXRkemtTWnZrbzlsUnJIeGJsTlhrN1BtcWxfaV9HYVQ0SlhPaGlRVndaeXhJTnU3cjZuWWRWd3FfTzhJM3VZUlUwRmJTZzRWdm5BQWpVOUFoNDRuU0JycWVrdGhLQm9DYnMyeXJIeVBIX0RxUjVCUlpsTkJ5UW1icUdnTHRJNGtTY0ZRbGpmbEJkMlhXV1NrREVxZWVfNW03UTRDYkFyZkh1aTBDSG1yMlZMQ3IwRUtoSXJKM3J1aDI4WHRJM1ZNcURhTVkybHY5Uy1OVTFJZUd5cE1RbDZjYTBfemY1d1lDbzVSd2dNdWFrSXJPMkMzeXRISHdROWNoWTJ2TUNlYlNqbkpYOGFRdU92Zk9HSmE1M205ZkpDVGZIdmlOaU5sZXZTN2g4VVdnSU52M1FXSDdwV2FXeEFnQmozX18zS0JzSDdqaUloQXg4eURqTDd2dngzZi1Ta01lcnhtWHFCRHpuWEdrWW83WG03OUNxNGhMWkdHNGlCcE1vWkFLRzZJaTllQ0RLWWZVVHhUOU8zUHdPb0xXQ0drNFUxOHBiTDZSLWV2Q2dNbm1USGhsS1lvcV9HUUZHRDQ3VTZodzJGSlB5bmJXMkJ4QUtOeWZvUU55eDR0VkRkR1V2UFpYUC1ldk1PMTZZYnNmSE5IVGZ5WnRVdTlObUxDS05STEJtWjZOemlSUEhGTTVMcUZVamJPZmZFRXRQWTVLZGZjc01jX1A4eXNEbVFOWk03RU81RWhUT1pVQUFORUtFeU1yWTBSaWZUVjlYUjNLN2ctSDVzMXJ3NzRUUnJfVkNoQ0o2T1RXM09WSW13QWNmZG1PWHJncDBVZVYwOUFsdTNURDR6aWZfTjRrRTdxSkJ3UzAtek1sSTFJMWtCak5nZ2FPclRBdlR4WWhFc25ieENoSGpFZ2Q3WmhYUlBydldIM0kxcjZEbEhmZTRzcS1hY09YbnN5M0lQbGlSeVc1Y1VrSTl2dTlQdVk1NHJjOFRCNW1PLVN0LTJUSkR4ZmVYSnBpRVQzeFNLNjFJMkJycW5CZnFicWxqSkhScXp3RXVHRHVZYjlJUkQ1Tk12cm13Y1ppZVBuemktQ285ZXJOTlZlSE9rQy1kSjY2OGdpd2dzQ19rSldFMWYxSEM1Ym12S0xzeGU5UlVrOTFqU1JkQTlJdi1fYThadC1YNk50M3d5QVlsLWQ1NWtFOGxWaXRZdm1nYUhyUnhnd250ZzR6OE4yOTZ0cDB3Zk9LamZBMUFHdGhENjUxMHlyRGJWSUhIRmFqdmY4Q2VTQjIzd1hzekNpUEdtSHFlTGh0NTRLMFlLYWJCVXVpTHNhY0txNkxCYlNQTHMxOG42TVlKRU9sQXB5dUx2OE14X3dEem94dnZrZHNuSUZsUHdMcFdnYUl1R2JnX013MlhrYXZHNjV6RWM5TENrSDlrdlpBNnlxTzF1ampJUmFkVjRMZkJtcmVuUER3dHNWOThleHdzcDRpZDZjeWhWN1JyVk1mMzhjSERyd3k5V1NSRGNSajZYc1Fmb01uUFhPa1FhYkE2TDlCc3N1ZUwwUlpjMVdoem1Qb2NWbk1KZ3FWN3JmU1J5QzgxcGJwZGxPVU9uODItbzZ2N2lqcGR6RFBCMTFCbkhWalBhd2VsZVQtQ21HSVR1UXBiejV1bFFBTGtldVNIMm9TeGRZZVh0VlRtS3hlVS1kb2M1em5LdDBJcWt4elh1cVNvNmtRWS00RVdlRC15bmVqQ3dIRE9SRERIWjRITjhtZDlEdHJpTEh3b05pcThjZzdBM09PdlBEWlBrRVZuczNwa0VwRm05S1F6T0ZmeEpKSW5lVlB2RVRFTWpwOXg5cUpEYjdDb1Y2UnE2OTd4cmgtYTJTRkxGY254R21XZkpyX1g1RGtaX21VY0w0Q0pZYmNpZl9KWTNvVTFyQU55T0E2VjlPWXE4NUcxTERkLXVpMVIwdVFrMlAzWktCaF90Rm5JZF9GQ3ViMWdJclNOT1ZJM20yWmRPVUhGejV6cm1SbUZnVWtvSTBCY2dCVU9rZHJDUjJPZVFkZ25LVFUyZ2FGTHZ5dGxwUXZNajhaaWFlWTVJVGMydHNJV015c0RaNndOME1ZYmpSM2lISDhMVmpnQlhFRS1TM0R4Q0ZjTDN4UEo3QWJzLWdWb2ozRGZVRERVeWRwN1V1NjNoTjBiT0IwbW8xYnA3UFZueklTOHFFY1pFU3ZHMl9NeFZCYi1zeG9JTVQ4ZGtvRmd3VkhiNzVSaUJ3bUdqQjNycktMeGJ0NW9pVVRIV2pYRzBuYlJnb2JtbW5wYUhiSUFKamhOLWRNMkFMajBXVWVEd1EuSFFwZU4tMmJqM011dE53UndNdURYQQ==',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC5TajQ5Y3IyalFWNlVUMmFRTzQ3Z0t4dVdGY1h5LVdSd200OE5zdGUyQnNwdmlEdUJlX3VMd2FfazNURXlabkd6VXhjeVhGU004TGdaaHNxTThmMnNYanNuY1R0Ul9ua21pQjhzOUtzeHlMRmZhT0RXSW5wQlhXT2VXWTF1ZEFwVkNqdmQ3YmJxdlR3d1dNWUEtLUthX0Rvc0tsQWMyOHFkNHo0YmpWUWhxNUJKclZGVTFfX2dhRVZYZ2NBLXJwMHFmZ0psd2RqMDdZNGdRNTlnTlVaMnU5RGdIcWFWajhBeWNDTDJmOVdfMXdSa3BkaUlHdVZfTWhoRTNhcXY4QlFlQnhaeW1DaVVlWkNoLWFJSlVCTW9pQVdGY0RHMmRBcU5hb1FacDA4dGJmbExDQmpOQUg5VGItRkRNa0xoWkZqaE5mR2ZqRDVPX3BNakswNmZXalFRZFdLeHBVOVVEaGNLQTNicWtqTjg2X1F4TUJLTzVacUl6eXkyX2dUWUlqeTFjZzZHR1ZmTm05S1hYU1RzQUZIVUVvajJFM1RvenJTakZ6RFJINDE3WjFWMURhSnZUMnNaM1J3WFZjeElpeTR5ZHU4QV9UX2E1dmp3dE95Z0xFY0RwSHZOYmFHSXlLVjdydWxCT2dJbVVxOVdxWXN2WTdOUnhtXzFXX1NMX3B1R2o5d0dSZ0paWnRnQTZBUGN5R2N0ZzRIdV9YcGRNSG5LM1lSbzU5a0E3ZnZSZTFickNQYkUwSWNHdUNxWGpjazFtamc3R3dReHZETk43UFlkYVNna3JvM2taWGNBb283bWpMTEc2aDBzLVozU0pYNEszVEg3ZUIwWlhJd0NfM0NiTHZSNEFWSlhGRWpfY081YTVkZnRfajNmby13b2hOR1B0bTdOdVdfZmpSSS51V09fS0tPRU9aLXhKVElJLi1hdVczM193S3lZcHRmclFRZC1KRnh4c2lBbjlFY3dlRTlhQ0lmTEVmMWlEbjNZaVZabXFBOTZaUmhBVGljVnNROUViWVdIUmhRdzgyemNBczhqNkNEUkNVc3VvSllzR3JCU2F6SlltUmpBWkFOZDJWZDhSYUF2Z09yZnBJSFhjR1MyM3V4TEhFeWhmbW55aFJhNDFUTjdxNlMwYmhCU1YtRVpnNzJBLTZEeVdmaURlRlJnVmRRbUNpSEROb1lUNG9PLXpqTnFHUVc5VXpfeUl3TVplczFMMzdwVk8zdjNSeS0yTEJPdERZRU1vQUhsMHI3UUZ6a2ZEUmhweEo4R250S3EydW5VdDFoYVBydjBCS2ZyWUpSZFZtN2V4ck9WNnlDcE5NejRDYmYxbS0zRlN5WnJxd1hQZFdfRDBjUEVRQ1lCV0xBWW5uYV9mQ3JDOVBPUVRPVDVzNlk1OWdVbDBTTTV3dmppN2Z3aG1wYnZ4UjYyOVNrN1FzWkNaVHNKZ00tM09yVHBWM1d3OG9XNnQ2ZXQySFltUzJIbzY5Z1V2S3VzVnhrVl96cGZKN1l5REtVYmg3WmFlQzl2Q3pwR0hPYTZBSEdicUVjSVFCREVwR3ByVmpHYndZRFBuWTlmMmhGNUhMM3BtRzhjbFhxaHN4QTU5WHJrQkFfNGlnUjA1NWRIZGt1d2RqbDdnUHhabjZsZDVjd0Q4RmRzRHBJRVJBZW4wdEkybUJqekJQR0Jjc0cyMEdZN05HajV5Q2RYQWhWZFlWeWQ1OVh5VFhVZTN3eFdydE9HQ0V4ME9IMTZERlNVdFhwRHBYTlhLaWJtS21iVnpjMm90aWNsbTAxNUJyd0tnTFc2SjB4WTQ5NkQ4T1RTaGo4WTQ4eHd0eVBKcWlzcDhFT0RhMlprZld5aGlLRmI1RmxyRlk4NE12UzhldmdKVjFIazY3c1o5TFdPZS13QTVLUk1yVjcxVnNVbzhWZ3haOFE4YVZ1QnJZRl9yMmt3MFlsbUtjWEdVbWQ0X3BuM2p3M2xYeWV5VTlJeEFwdzFGeWgtWmkyN21FeDdOUm5VcDRYbXJxWDFmeGN5NzlRVlFFX0RTeU13Z3ZKVE5BbG0xbWRZdzMyTnI4YkFaQnhFbG9BZGlGSXNTd2EwSnNhNU9Vd1hEeVkzcnpPaElaYXhIaFVmcVVLS1U2NXZ3RkY1Y0FTRVF4N21tQ2tKTXROMWs5bDF4NmllazlTbHhJUkpxZ1NVcmRoWl85RUYzRVprbTJnbjkxdWVCcFVaQTJtTC0zczVBVnQ1UnRibm4weHFoemdhWE1McmQ4YWdGVkdXVEJNTkI5WDIzUUxrZnAyUWNqSzNMbHhBWF9Ocm1aNGg3azBCZk1YQjlZSlRjcXpTbmh4cTNKbXRBOHVqOTMtQ05UVHNVOEViRWpVRlFudEk1ckdHbGl6Uy1wWS1ocXRaU2ZRNTBBZjc2dnRCSzRRX1R5RG9PVjRiSG9JUE8zYnBVYnpfU2J1dG42LXRFYzJ1NUphRVF4MXM3RW5RYzVWNEloQ1V1VEd1X2lBd283OGNNZHZOdGNmVkdEczc4eExzR2lDVGNTcjlHYnpiMVBOQnl4dGEtdXowN1ZGNkZGZndId2dUZlRSZGNZbTU4WkMxM1llMURSS0NjTGdlVEpHOUYtUjlDNUJBc1RSa0xhNWJaaEVmTkw1VC14RW5JY1ViLW1ReTA5S2FYdDh0R3h1Q1I0eHVGZkZMdWtGblFIYjEwQzFxNkJwcExRQ014UHJRaHRWUmpMNUl5OENkMXNibWdoUzhCeVJpN21ranNrUEYydU5ud3kxSERJWU40QVNLNXp5b29Ic0VUTUFoaHJIa1g0anNrSmd3dXhkdjBvOWRyZHlEbTRFbl82eFE2TG1UMGRqODVUaGVTbjBXc0lha0FBM0VTbllyeWJ2RURDNWFQZTRTNC1sSFhtSnBhbGFNNnhONXMyY1Q3UlJHOHVnTWk1cEdyQ1ZYRFl5TWhDZmNPRl9jZGx6aUVfZFRNN3Z0VDJxSllqOGhNNWRxRHBWZGkxaWplTy1QcmF2X01uUjdKbjdmM2JPTVRBTVRQa2FGb3c2eFhIbzJOOWwxTEhIbGVmVHlSRDgwOU9PMTNxV0k2RFZyV2pUSzVXSGI5eUZ1Vkc4Um1DenJ6QlI3WjdUdG9yUC1xSnBHX3RsMUkwcXdNNmlXek4yQXR2dGZEV3NCSWl4Yk5kbldyNGZtTUExYWM1X1ZvanBfX1B6cWhMdmxFUElDX2RzMmpHR0ZwVWhQV0RpdWNZOUZ0SlplQVdqNnlNTkpaLWRJM2E3U3B4emc2V2MxaHl2QXhPRHpvX1lBb2RmaGFLTUJIOGhoYlFScXZhMEtoeUo2YllFYU1lMXJyTEVRTm5RUFlmSmxQYjhDOUU0UC04Z2FZX2xBWUYzUHNYZzM4RXU5WmRQUlpSdEd4NXEzWlcwVW1mZEhBMGJXcG1STUo4WlNWdVZoWFZpcVlJX2VXMHBCVlhNb1k5TmJ3Ti0yRm1ZVFVzVVZqeUNGV25zZkdqaXJwZkVfQjg5UHFMZ0YtT1FBY3MwYXZNWEpHZW1BRWRyUVNDd2VKRnM5djhuSFA5b2EwQThwTGZFeThVSW56V2ItVXNhNjVXX0dicFR1UnBMV2lIcEZ3Z3ZoelN4X1NEQXFkcG1vZ1JMLWdwTzlfSHptSGxZbUE4N2laN081Zkp3WTRZMGt3c1I3eVVDZHFFRVVUb0Ezdl9FN01xZDk1T0dSQ3pYWDVFeVVVbXM0Zjl0LU5rdEV3dDhiOGllNE9ET2hUUU1XblJOMjRrbGpCck1TcnI2MEw5S3BFY1o4LXZKTmczcWgtbzMzby1HcnBvYk15UTE4TUh3TEM3T3BaYktOWkRaTDVJS2hoMk1zWkdMY2lZTlBUYnNWSHpDbDJ4dkhtSDRJdVBoejEtTXdxSGk0am94bk9TNFJFeWEwZE10SXR1WV9FRFNxQVdQQkF3eXduREFQYjhZeGlXcHdwcUJZRjdVa0lpcEJheXN0dXBKOE9fUW5BckswUDNzendmc3d5QWFtMTVMR0Q3VTl5SEVZbXJEUzdDb0JHMTdoWUF2VG5NczNfSUN6Z0lYSTg4N3htcm5LS053WDZXbXFUcTlOTDBTTVA2ZHVIelUxMEdqVXp6LUU5NldGcGpGejVBNnh4MjhPTy1aM28taWVxRi1nUGZ5RFEyaEhXYmtXZGlCNXNGTGpuRlBZLXNEWGs2al9FamRTdHVmclBrMUVsNF8tY3hKbnZyVkJVUGJZcTUxajdPY3llY3NWWUNRUkd6cG02RUFHZFo4WDhOTXpiM3B1R25scXVDQmNPd3djWGV1MjIwemRHUy1QYncwR0ZveTR2d2JGc1RtblliWFlRX3Y1elgtVjNseklxTFZSaEZhR2wxbUotVEYzbnZILUZLMFJMeDZyTUxIUlhZREJyYkpKTHRwc1ZxaERaZjJaYVZUTWZyMTZuSkItSVE5dXEzM04wM1EueHZqZlV4UHFjNU1GRk1xbjZJYVBEdw==',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC5HR0ZqMUV2WUVFaHBaRDRnUmZDU2lYUS04M3pmbHE4ZnVUa0U1QjdmbENKRURUdm5rbFNNY0hfNXhrV3B5bDRKNlRueDQxNldTci1QVU4tY0tORWZlczkyUjJSY1ZIQndnUWxucWNJOWNpLXA2ZFFkenlhZ1Z6RlFZMjJwdk5BT0JRNEMyU3M4bVhfekJUUzNHcldtY1M1bDhVUnVKUGRFMWpGa09WUDVZaF9nT1pKc2lmT2RqbjhlYUM0SmlxQjVPYl9EWnlpbDVqb0Zhb3NGeWJlaGIzZEx6WHpacUVGQVhZcW45WmJOVVBYNl9TTFdJUUtQNUZOY0V0cWhoMlcwalpYU3N4M2hKNkFXdDVQWG5BZkhQQ212cS1LTlpNcDlSZ0R3TzJhNVF0ZHlmVVl3WGRxZFd0d2lTdDRvY1M4akVaNjFTcGNMVjdpendZWkFhbFliUG1YN2pTaHhjYVVYUldkb2lIcTlFXzQzcmxtTjJVZVEyWDR0R0s1SXlTcy1feFJMLXRIajczakdxZ2pLenJkTEdCYklOTDMtTl9BMU9mUGY3NGdhZDBZNThYdGp5eW1IcThVSGxrS3NEeFVpaEd0a25qVlduZU1EU0s3QzU1RVBFQlpMVnNYenpMdDBzc3hvZkVmTFVQWVpTbjZORFR6UWVheC1mNGJNODVPQzdkbTJXaG1RM29nOEZxMVd4VHRJc2s5SFFWTlhoLXA3a1JuTUV4Ul96YWw5OEZNNmNYWU56cl9zRTl5R0F4aVZsZy05bXQ5by1KbVhYNmtvM19xSUtKeEdWRGFrQVdiaEZKYk1CN3Nvc2F3SmNDdzdEUlBtemprdF9vekVzSklpYTJPaWZmVXNPQUxOWkJOVWtrdVVnLXZQQlNlVi1sbC14Z0dDRW5nS1Z5dy5fbUZneVdOZVhtSDVLLURWLmV3UHFUOVF5QUR0bWZzdks3czRGSmdTeDVPNkZNbjFUcnl0azRKallPVno3MXNjOEF6cHMtUnJvdkNPRGdtMGlDa3dUQ2ZWSXBiSENSaEpjR0ZQQi11SkF2UV9sYnpJSnpVU2t2TWtOZ0M5T0MzMTY2VWN5WlR6YzlGZGwxTWoxbER2SXpMeE9YOFViVjF5TkR0M0owRkMtTjBuUWRnbHF4ZHVxUTBoMXNINk82a2ZVa1ZmSV80NmVfOWVOaDJLVjYyR0ZMcmJDTHJIRFNqZnI0d3MuVC1ISU9tRWNYVnJvQWR2SW9zZEl4Zw==',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC5Kdmg2cmRoYTBoMHNEcnEwWUpRSWQ5ZkpsaU5zeW8xaGZjemxPZE1KWjJNZmVmUzJRTFpJbmZrX20tQm9XbjQ2SXFkRUJwblY0OU8tWHlWV3haNHdKeG4ybWxNc1NqSklGS1FRUmNrUmg3cWx3bDFLNkZjMUlFaFVCRkxMUWlvc1gydG51Uk9rTHFHUzczNno3QUJCYzFhUDJ5NHpRVWVPVkJHTkpJdXlsNS1ObkZIMVd4X19kTWVwNTZUMVBrMjBMdE45bHNnX2xOZzMwTjRlVjduejF1MWRDRFZUMXpPemRWRS1kMFZpYnB0Y0FQUmlnT2NFQjUxLTdyVEMzZDVjbGI5YUVjb1J3SGZiWkVvbm85LUNtTlpsdW5maWhZSUpxMXFhU0lrcV9rZVdZcjZDTTlPTFlKSkQ3ZTd5ZVdDdDFYTi1TRGwxY0g4ZHFIYTY4ODRmSVJjaGhmSFlQYnhKaUNiUHNkQXNfR3JaUW1STldzSl9SMlJGeHVoTGZHV2NGT0dMZ19KN2ZRdnlvRHNuTGlzOUZla1JvWjd4S1BFVktRUm9XMlZvVVdnQ2NoLXBiZ3U2TDVlZmo1TDhUUGFwb1hRWDFSaGRwZVB4Y2hQMGRMRjlpTXE2Q05vU3BseHJDRFRRREFJOVBLT1N6VkNBRllrV1BXZ1BhSUQ5eDJiLVZXOWxhNzJqa2F6U0txTks1TnBtaFNUQXYxcG4yc2s4ZlhvMzJaTUNWdDZEWFd2Q0tqT2NOc1k5Y0JMSlkySXdqYVJZTmZhZkROT0RkSzhQcnhqemUtWDRGX3hKMzdfRGVZbUs0a0ZOcG9GaS01bUEyZE9iRmZUNkh2WHJGZHljS2xBQXJnbTFQOXZ2dmlaeTlLQ2dHclZKMkNzOFJfY1JlckdERE9TNnVhNC5PcnJZVndZbFIwNnRfQlg3LmdCQ1lBeVVnamUzRy1qWkxTTkMyUEhlcGlXM1JrTXI2RDI4ZW55dzQtR2N6YzZVQmpKMEVxTWs5NTlRVTU4WVRKenplLUkyZ3E0aEMzN2lncURzbkh4eHhPQkRaWmZsR0V2cE9CQmxjemFNSm5PNkdRNVViWm1FWWNaOUxoZzN6YjZxUklQTFpFUlZTZWZjVTRCN2dTcFQxY3lmcVhGOXFzaGMzaE5qNnpVLUpkSTh5TVdMU1ZVX21ZV0lsemtsVWlFOVdGanpxWHhkbFptN3dxUmhZUlZZT3dNOXh0UDJqVFJPOFBrRmtaT1EyYUNKd0kzTW94Q1VFVzFUalVqaGhRYXlQbHRMa09zQ29aczhkYWxtTEhnTzlla0Vxc1ptT3BmM1dTU1NQNTZTVno1QVpWQ0FQOHZqUEh2VlpvM1E5NHUzTmFKVE55dlMzZUpXWXZqbnduTXJGdjdkQTIwZ3lCZXBUUzZWYkwtWEQtajluWTNvT19ub2xVVm0tRkRCVUpLdlN0ZXJ3N1FfTGhRSUp3V2dpd0xqdmFYM0U0MDl1TTVnUU0wWmoxakwwNVUzY08yV2dBQThMS2pJaVAtT3hBYUtIWDlkTnVEeWNBbDlsTFQwOWZ3ZkJtRDF6UkdlN0dlbTBKdXExWWNEanlTZEZFYV9MQmJocGd0OXhITU9wQ21RTUF1bEtucXp5NVc2ZU4xSTlXWGY4ZzJBYk1ZRGEwLW1ETU5lb2RQM3l6cnd6VHptbXJUVXY4NzJJSGwxVFlOZkFMYnotc0UzX1pPUUd5MnVsdEhPT2dZbktlU19VV0d1Y2VacV91TV9IMGsxdzc3S1NCRTJTMVVyVDRXMEdrcngtUGx1MkRlZVEyQkpEZUJVYUtZaVJtcW9oZTFYWTRHQXliZm16MnZORGFla0ZLYjNtMGQ2bEszckp0ZVZQTG51SUotUGU4dDVIc0xabU1TMDJTMHR3ZmtmZGZ1YkRhaDYyc3l3eHlDRTd2YjlXajFCWkFUZmdvbHZ3ZXpZR1I1a3NJVFBwNHh2c2RhVS1LOXNSd0Fub0txWnkwdS00RVdOdzIzZUJYVmRPNjlQbTUzeVIta0lLUnpuRC0xT0JIaDVxOG43RnpTMEZzWTBjUFVHZVIzMzhKd25CNzFoeWlTV2tsYkxEQjNfT1N3MnZoSld1Q1BIN0FtN1dyeUhSUmt5MWtvVl9UMzgtUlVnbmJ2SWw1dlE1WHo0dTJyTlZXMExWVjFDM3BUUlhtLWlJUm1xYVViWFdMNlRjT0luRGxmUnZmYjZjbTYyd2ZUWk9GaVlxa2t6UmZTanBhM2x3MUU3bkVnS0RvVDIzd21RbXNGNzU3MWVmT00zenRiWHZrYW5Ld1JOb2xYN0dRVUFucmlndHhYNkc4dmdIa1VZaklHVk9tcWNPSU5HWEV2aVlhNXVQZ2hzNHZUbFlDR2xWUlZDNjdPaEdSU1JmU21YWWlvd1FwSVhNRG96b1RQb2NiRmlEQ2kyV0VTN1FCSUExY3dGeTZoZHlUeDFsUXVmWFVYN0FxQWctTEdZSE9sdGNiX2xyempfdGh2NWZVMzZJYXNHVF9FNWo4S1B5c0ozRE5hMHBicHRoTkN3TU1hTE95QjEycFgyMnktSzB1YjRyS3MyXzdJUTRNMERQSkhtR1NQd2xkUzc4ZGZId2Q2OGdkQnJoN1VGQ0V5RzFBMHp3N0JOYVE4eDllMnozVGwzUU5pZlRZa2ozRThvZEhfMVprNWxobW1MRGw5N1JuVjViVGlsQkhtNGpSSjd3OFFHYVkyU05Mek9zSktxLV9uOUtZTWNWcC1qMHRmRjh1dDQzREU2Yl9vZnJVV1dPeDQ5WndibkxEQXNoWXBEVjBKZENRLTZLd3ZmQ2h5cXBNa21OQkNfd2lCLW9zZjJiSjFlbmhIWmRmZV8xN0RrbWg2Wml4UUZoa1Z5c2d0NHVrZGlxV2pDbk1sWDJIcHJtcGowSkFOaGduSF9BbkJoQkR2eGF3LVNGQlBDNXBzX0VTZTNKUlo4N2ZXbUpkWk9UTFQ5RmFlWWhWd3VlVE5xTVUtbVZJWTlZcllxd1FNcmczVVgwQnhsQjUybTdWTXZEU2ZEREJ3aXhKRHNuOTlnRHpCZFBLUGhoRVpYdmtGVkE0Z0hxcFFSVjVrSUNfaS1LazgwRVhaeVhYRDItSEdENjlHUHRXUVpVWk5Pdnl5eU81MlA3MWdIWC10MTEtY2JROWlGcGhYd2JOTlJkTXFnX3d0TmNCMTdxaUJEdHpnWHZlTHBHVUoxRDg0SWUwbnNZS0FCYUNCMGdTZmpCXzlGZk1XcXRLd2NKT25SUHZKNjNwcU55UHM4Vkk0NXFuU2FpUVV3ZGlqd1FNelFmOGp2amV1R3RLVVlyRVJnNGF5d19WYzdxVFRCNzZGalVlMUQ2ZTUtekR5NEloYzN6ckQ5cUgtaDNsWWtyMlZSLWlLVEpOd3Q0Zk9waFlvNDJDYWNZR09zYnd2eDY0VmJMb3F4Qm5YVldzYl9CWS1fdDV0RWtMS21WMVo0akhWYXZ5WWhIdUdqSkR6YTd6SGg1bW1nMVBfSE9xc203bEhobTUtY2xhQ3JtUk5WeXZVMkRZUVFNZ2xwR2ZEVFg5V2EzZ2IzdlA2TXpndXVXRUZJc1BDWktaSlRoU3BRUDBxTmVCcmxFOUw5STAzV1VyMzJlMGROelkwNVplbFpNMUQ0NXpXNi13a3BjNTBnTlNtMDBFX09yX0N5clk2UEtJdEJwWEJoWUY3UTVZWGFZSUFWY1loWllCcXZPb3NvTUtwdzByYkxfSnhBQ0d5V1I5eHBzbHFZMi1GRWU5MC1zLTdSMXkwdy1Ha0llMVBvU0Y4NzJ0ZjFCNmRaQ1lGdVNNcmp2UmFybWV0Z3JnV1dkQnZTREpaNTlWUDlubk5CX2NmNDVZaHFFZTl2NjdqRkJDVEw5SWJJRlR3VGw1RXZzWk1qQmwxaTNWbkJaZUpSdVVWbV9xcUlMcFhNa0oydnZVWi1DOFBFQ3NLcXZnb25oVkZPQlREUHBaX0JWT1AwVEVocktOTER6UHdMZTBxYXN1VW9HcVJKa3N3aHdsMXdqMjhwRU5jdk5PNVMyYUo4c0ZuNWY1NnVwanpZSEY1Q3V1Z29ob1RCOTdnT1pyOVIyUXRkenE5U1RoQUtlb1AwdjdiM2t2a0lJQWxOc0lQTXV6b3BuSFdrTlUweDVUeHdyZXhKOTBsSzQ1d2sxX0dzNFljaU5KN09QQ3Ntc1VIeE1WcEU3S3F4V180OGxfMTlWUHJXYkxyOXlONXo1R2QtaXJ5c0pZU2N0UWVydC1rSWtvTGc2RTlSOVVTMFZNaW0xVHRYRl8xc01PX2Zrd192U2tpVDdwRC00TnJMd2NqV2NJM0cydE02Q2JUMHVOWmZyNUJvYmpqTkhkUVFhVzNnTEoxTkU0LUlaMWRrUVQ0YWRaclZfWFl4SWdDU1FKM3duYUVCU2pXSFdPSW13a3RnMlRFbTllY0VCSUZWc2ozSVh6czBTQ2hVbTdUT25GaDF2ZHJhZEVYbHpPaVBPaVA4ZnExcWJoQnprY2FQakV3YU5BSEh1ZUxNU1YzbUxWZUM1dU40UnYxaU4weVgxRzJTM2lWZ1FWYy1FMU4zal9PdGxITXZ3S19IU0JmekVyeWYtVkJ1NEZsRVhLdzZlX1lGaTcyQmV0b1otbmwtTkRnclhLYXJCWW13ZmZDZU5VWDV4VGNOemVIVlhXbkhaazBpMUZabEdKS1VzUWdFLUh1ZXF2Vlh3R19sVG01WkY5ejNuMV9nY1V2MXItc19aVzdjWUo2UUtCLUNaRVRlMEp1c2c1dVVOUDlkOTNPYUNOa0ZCa1lONms5R2NrQVd2QmFhRHBZQTQ3QVdxT0I4Zm95cS1RS0pWcENZMWRKbnpXUDlDaTVxU0o5VXZGVm5VclZGYmpraXkwcWtNUGdHY0gzempKLWZsWkl2eG9kS3NVcG1CZ3NKWS1QTFdPVE9oWkFYUlJHanE0MWZ2TXN1ZEp0MnpJcVJ2S2w0aUhKdDFoVWNXYnZ2bVBZRUhOc2s1LVk2eFNEbWdmQVNJRjdUbHhrSldhSHlIYlc4Sm5LZGc0YXNTQ041TmVqWmdYUDFjeFZVcW5tVFNWd2FMS09WWE5DTWM4YXhWaHZwN1FkWFJHX2dCa2RZMzNDSHR3ZEZKbDdLckhNZ0NUM0RoSWk4aTF0c3A2QzZOd1pUdktmTzE5UHRRMUJOWXJNeldJR2tsR0VMclhwM0J6Z1dWdlY1TzJUMlpzM2poYWduMHpRWGRydjhyM3Q5WEd3eTlUcXZFVjF5NUFka0FrMW1EZURlZUtfUy1PRmF6OTg5ZVRSTVRPRjNRb25IT05oTjktdWdXblI5X0JVbkpRczlzVTZYUUZYRDJhVlhGbDdodXp0VkJNQWdfSDItZzZhU3JYbHN4QU9OTExfVWRlLXVKQ3VTaUNtN0lwdkdLR2dnMHItQ1lvNnMxTTRIbGR4X2JWNVAzRzlFM2ZpdUt3cnJncTYzdWJKeTZmZHEyUzhGczhkY2ZDNjVXb2F1XzhNMmlJaTEyUW9oZjlzSk91d1c5eklJZUdTT0o0QmozbTIxcWNyMXY0MUd5blYxT2E5cFBmbVQteEhWS3BVZDI5bjQyMDU4eENTYmRvdUJXZllLWUNHTHItTzlJZTA4SV9Zc0VrZ3dNV0laaVlic3hrVTVVQjBiUDJtZUtTRDRYc1dWN2M2YU1DRzYwTC0xbzUtUko5dHhfb1BpX1FQOGx4dGl5U0hJTlhCRUhYVkpwM2FwdEhiZ1VDd0RJS05faXl0Y1YzYkJwRkhYdUdRYm80R29vZklEeHdSSkZpbmpVS0NfZXJ6NUxxTmdzdzRlS0QzQ2ZYSW5UVU9QcHZBaVVVMmdXLVR3UzJja2J6M3RVMThZekIzVkhMYmJiU3hYRHlaRnNIb3JuYVZrbzdTcDdXT1ZCVURsYmI5Ujh4WnBXblVwazN3QVpjbHNJNjJERnRLYjRzWnBIWjVVUk50RWlEOXFlamkxaWRUMzZHYjk4MVpHN1NCWTk3WGRVbkVnVGZHRExCN3FXWlZTcXF5bk9zbnhTd2t6dHJrRk9jQ3lVWVBRbFpyNG9CZkI5WTB6YTJsc1FfYzFPc212OThoTTZCRGoyb0kwYlZ3LWtDS2R1MzB3RnZkYWxCU3dQbTNwSEFVTGRHZ0xfQVhhbDVDOEJ2VVVxUHdieG1wX3p6MFRBa3JUOWpEM0FqY1dlUlEtM3RwSVFjQ2NFQ1lMQ1F5bUVPc0MtY1pWV1BpQV9iT3pCQ2diMExiR0w4UVowYjFSU1p2MlNUdlptWmZIOUZsT1hvcm1NZFU3NDVkRUtoM255TWdzQmMtNmR2d2l1V29BbkNBaEVDV21MUWdBa2tURnpQVDdNM0g5YUFFaHRKVXExZ1RMZXJDNkl6U2xadnh1NXByX2h0a2lBek9YMl91T2U4d0NLbjJTQ29jTmdiTlNvVDZQczNzcEpBZjR6Z2VUZHRyaEV2bDg1RU1vR3l1aGw4dG1nVlpkRkNTYVYwaVVMS2liTElFTHhfY212Z1pTRXJOaDhvMFY2Y1VHaDVUcDQtUlpmczNNTk54cml1aVlkbU04Q1ExNnpHLTQtRzNMbUswMEY0elZmLS00M3o3enJMeFpPc3NTdWhBVjF1dksyNnFvSDhyUnMzYTZiQkJIdjN5QTBWMTFDS2lSSmxtOGprcl9zUzd1X21JM0NyeUR3MkNac0Rjdm13aFRKMWROckpWQnM3cDdGTUhUeXZiYXdtNmdNSDJLd0lPeXNQUk9TRUpQa3VCNVU4VlJBekhjaXVONXJQb0pzZjItcXR6X0hyR3MzWk1jQVdzSnJfUkJsem1hV2VlOFgtWGlSQXBidWtKQVVqdTFIblhGSDdDS1YxS0NNYjdNczhsN0xQMGtfMmYyRjZxV3NYOEFMWkp3N09oNUc1bWR1ZS1JTnExRXNLUDVobVg3T3FWejdSVGtzZXY4UHduTXVSYkxBdUNvTDRvcjBJWUtOenBCOEJtNkltUDllZmlILTVHd2FfQVFBTFpiVVdOY19EVXA0d0tYSVQ2RkxuNi1IdTJJYlBWbXNNY2daQXNiNXBGNUFPWGgzVDh3Mm5aX2NzdFpxeDFvNFFmelplWkFFeklRRExjUk5rcC02dUNseG5mODQyc2JieV9KNHE3MGVLc092aHRYOEc2MlBmbXppVkVlNFN4QVFnbGhESDZhOGhxbG1EZDlmMEpWZnFyVnA0VG1iVnQyWmlMVmJSemdkbXF0RU9lTHRQWmF6bl80UmJidk8yYWxlMEQtRTdmaS1DUWI2TVYwRGpIWW5wQ1NzYVBHZ1lHaDVMYVFRZkRpVXVyZTY4ZXUzUkxYc0s0MXVxX2RaemxocDI1RE8zVG1SeEx5UW9ES0tsVmEtNEk5X3pkYWtTeGd5enhISjBNOXFpZC00TERkSW9Kd0k1aXBvY3hhd0pMeERCN0dBbmN6cVRfUm1IeHE0dkVmZGpJQXR5RDRpUHhpd2NrQTNzaTZ1bFpiS1lZdlM4Q2hKQWpETkVvbkZ5cmNGUmlfdVE2Tlh6R0xkbVJyWnZkV1B0aUt0aUJadHZ1Y1NXUGpSSXVrYnBscmd2UjUtc0NfZFdlOE9rc1kwbGg0N0pDbDFQR3B4Tl9GVm1JdTBqWUh2Ujc0MGt1OXViMlNDZC1VZzNOUFhKMkFHNkxDcnVwMFVkaTdnU1pnNEdmNkx3ZXc2YWtjTXJINm13Y19oUUdFS3dZLWtHb0pSVExQeVU3ZnpkdnotMUZLRzh2ZUlSRlFldFlLVVNSWVhkeTdqbFhXR0EtTHQ0Z3ZRM0VUMXBlbmJTWHVrSUJJVm43QndYVlVCazYwdFIxSDFNSXdvQm5tMjAwYmJ5ZEo2NWMtTHdQUjFQd1V6ZzdrM0Q5eTNfaDB0QWZ6VHdTSjZWcHNiSllkdm83Y21TbGtkeWh5Q3ZPWmwtQkV3UGdBZjJwMUhucmFKVl9rY3FSVmRxVmlmTVpPRGdOQzFjb1JYUk94MU82YjNVZnliRDA0SUlmcTZTRnZRa1dBQWdLN1hNQjhzWGd1NENUTmZIazVVaUluU1Q5Y2RKMkowV2w1NEZHNmI1akdiU3A0d0VORmRsZW1xbWdIaWNVWjZRaWktWlhiRE91Uzl3eVo2enBMR0MyRXRpSEFPVHJfTTBNa1NjUFlhY0l3WjRXNnNTTVd0OF9LVENFY3BQTHZ5cXZrQkdLVzJwNHNKN1ZUMnpkYlp4eWQ1bFRSUzF4WV9fLW5GRlVTcV9vdEVYNS1JYWJ3dnJpcEsyMkJOei0tYWFDVkRsa1VpWE5ySlJkRXBtZXo1S0k1QjQxRFRXTnpXWldoVmgwX2I1aHpjVUF1OFc2c2dVcWJuejZzcVNCblg5djU3bVJNdlZObnloeUlGbjNVR0JLMmhYM0RNYU9ha2J6eHVPV0Q3WWJ5d21sc0QwMERIZGtCcDB5Vk1FcEdSWTB3M0VrVE1LNEJYQ1BzVUwya3lKX25EZW5zTUR1dk5lczd6UTV1M0NRNVhob0FkczhYMnV6SWowRlk2eW5Td2lFS0pNU3Q3N05SMHNCanhBQm1sTmprV3JpYWduMEdWZFJHTXhIT2t4RzMxeV9NZjNQYmVQbE5VTVNPcU1TbV9UT01zSF92cUljY0VWNXRiZG1sZ2dnYjl0Y3FrOGlBVU1VNzVjaGt2Vms1VGVZRXpiUTdLTHVzYzl1amNCRU50MmF6cW1MV05xM0JhYWJVZnowcDFwOXFzaHFmbTZxSDZWNG1IZk9wWWJDWmpLWTRyTF9wWThiZjI5VEpaNHQtZHI0YXIxclVqcWtoT1RDMmhCVVlVNkFrTjVWandPRUtrejg1RkRvSkpwTlVGYXZZUXc0ZGVYN1dJR3dzMkExc3I2VC1JbEczVFJwbHQ4STJHSG9fLUZQZFJXX3B0UUNFaXZ0S21YUE1XeEs2R1c4c2Q2WDRpMVVBTk1WLUs5N08wS21kQXZpaWFzdmoxUjU1SkpESVkyWkJQekY1VC1FbW14dWUtb0tKSmx5bi1lQXEyTHh5OVhhd3UxbE9HMkYzM3hUUzBVQ0FyV0h0Y3pfN1pGMUJtbmRGcExlblVtRzdUVjcwQVN1OUUyRm1RdmFITEs0bVBKQmtNOXlDaGkzYWZVYndmbkdhN1p5THRkV3JWaGRiRnR2aDlrNjhUSmxtZTc0UnNHTG8xN2prZWo2blJMMDZleTBCeVNzWnRxQTFSN1lXSmFrREhicTY1Z3h0UFEzS1lkcG8yaWhES3N1dDhneVJXRHdmbU9lM1Q0cl9xb0lSZTRxUy12c2JGaTF2OFhMVklkY1RwLWFCck1lVF9qck5sSjRhR1duUk9MUS1hR2JyNVNZakFKY3ZjMUNZc1BGd2ZHZnBYOXljNXZsVzZGTUNpaWRNdENGNDJBMDY0V1NJMUJxSmNfR1RaY3p4NW9YTDdDeEkzQVdFZHc3bGJfVVRqeTU1X19QLWxWcTJsbmNtZWRlakZLRVkxV1dvOXdVZnUwbTV2djRnU1BlOVoxTDFEZE5zUDdlUlFSZXVwQ1RrcGMwWTh6OGxrUWVhVThJVko1cU5VRzR6NEpwdDExS1ViSkFtVFFYanFidG9uX0luVmZHU3d1aDBoUW5XUlBQdnNibHFCX3BRMFBCSDM0RE5LRTF5SldQbnR6SlRrUGdiYkpoQVMtWHgyWGhOM2NsNFYwZEtHeVRXcHQ3eFVxRm54c3duNDNGQ0lpLWIyUEg3QjY1TXdBZTZkN1JKdURSQzc4bHdfNVhMTVJ1SE01MW5vWFpVSVpqY0Z3VmdXN1lENVk0UGNrSnRudS00MmxVYjh5MFdvTmhZYXJXb2xNUVQ2SC1kb2I3bGxLbmhoRFBfU0NPY2hhR1h2akJ0VUtubUZKWUZpWVRhaE1vaTNOVFU2SmNNWFdkVktlTU5XVGpCY2dDSlcyaTBnWUcyWnBVc0FRendSZDFWOU4zSmV2cWRmY1RSWDlvVmd2UlA1dkxrVkltdGJ1cGwtNUFsNnJkN1M0OUwwdHdBVDUwaW80dTVhOTc1Y3ZZdHZSSlY1UGotNXc4MXFxS1lLeFhqczl0dzFzQ0duaVVxNUJqb0xwYVVUbUlsQ2F0UDNhZTN1bDdTTkZkTk02NHFoVWdILWRlZ0trdnQ3NEhuLTFRZjhRLUNFSXdFZzNPNW12b0piZmlqdUZRR01ockYyQ1ZOalhGUkRPR0JJTXhBT1JQTmZBRmcxN25DdlBvWFNrakFHaU5sSFVJaWlkU0oxWVY4dWZ5MHBoMG8yQ19Oc19TUTd3cHh3aEVuLWFjNE5JZjljbXJGcFhOYm1nWWFnRGl3dHBqaWtMYWxHbHpwZHRzdzZwYTlFX2Njc3cyajVpTnBRV0VkVTdnY2xhWml0UnJKdTBVMGFYRjRQY1NvZDRLNEtSdF9nYVBKeUFDYmtFY3g5amI0Um1XQ3BlN0plSG1tYTF1Y0N1Y0d2UlJyTWgtTWx4RUZyZU5IRXN2U1RLclh4QW1wbm9NQm1rTnJ4RnhoOHlIbFdaVGcxbXJMWjdHTTVSZ1g1ZlVhaE13Nkt5QUlYV3dfRFc4ZDdwcWdwc0hyX2FqNndoX01xT3daTGtlOHg5c2RGczJYMTBoaUk5Nlg3WnpYY3ZHTS01T2pxdm5fVmF5TjFsSDN3TTdqazkzTkZpZ2MxaUtma04xcmVFV3Z2aVRuLXFTRVBvVERfNGZMRGp0TkhFaVZzWGYwZHlYd0UtVlVlMjlnWmhrYUNOM3haUzN4VnM1SWNoUmJPSHE1bklab3BmSjZTRVhncnE4cVdLNVZicnozQ2NkTUtyMENLdEtIR1Y0Y3FVYkVMcGU2Q3dlRnNOMHVFRnZaM09MQkNMdkhBSXZqX2lCT3BkZGg4TklKcDJIdGRONjJQdWFUQzNXZkNmM3dLX3VkNFNuamVxTmw5bzVLOWlLUVFUcU4yMEs0Rl9yV0hQSmtEVWJPa1hoa2JmUUdDdjVuTEhyaFdqX0JESTlBNFNDeVpCNm9MUFJQdW5zYkthaVVVVENmRGN4MGVjYTFZOHRHMjdlLS1adHBKeks5dWZiMFZGUHNRbm5YTVIwZmFDS2doN3cucnVEd2hpNDR6eTVJdDhhSGxYSGF6dw==',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'executionStats': undefined,
      'batch': undefined,
      'encryptedBatch': 'ZXlKaGJHY2lPaUpTVTBFdFQwRkZVQzB5TlRZaUxDSmxibU1pT2lKQk1qVTJSME5OSWl3aWVtbHdJam9pUkVWR0luMC5rSDhhZ2xpdlZwb1l0NzFXeWNEOUhsODJKOEQ0eXpBOXFMcURuRVZpTVhBTVZxY0lyandlZ1I5Z3dBdEY1LXZRS2xRQnI3dTFuQS1EalFJT3JyZFlzVTh5Rlg5OGtiUVE0WktYcjcwTGhUZ0dJbVlzTm5ndWlKNDJITVB4alJobTI2dUJlREtOcnlmZmlFOGVodEZRTGlkVTBWa3hHcFZ4cGQ0VWEzY1pGQ2NFMF9odGRndWQ2dGFidGMzeVl2QV9WaDZ5XzZNSl91WGJtczVWYUV4dVZQem00bHdkUFlYSVJDN3c4ZndTLVNfdlJnVUNJSXE4TEVqWWdFY3p0Z0pfQXpCQUFMS0xrZlU5eG5hZnp6Umd3N0k1V000M0pfOGdPNUdMTXFvaXRDR3p6UzVsd2NaZ1F3bVlPTGJIbXFMSTZIVWo5WWRyanNydTVYOUg3OHl6NHNsM1ZpSWx0ektWaWM0V0kxZjNrZnNNc1dCaUU5UHNOSlc1RS11ck1RMWh2ZUhPVzdxTW1vc0VEbE5rdDJfTVNUc253VGp1SlZCNHRnR1k1QUx4U2xVZXJMU2J4WHNDT0hBS0lBLTUwZHZDZmw3XzMyYWhPNnU4YURnMktjang2SmVKcXlPbzdsTllQeDdlR2FFdFpRa0NlSzQtc0t2dXlWaUdjY0lGcmNaVjhlLUtlbTVkSjRtbVRrV01nWVBKVVlodFJFZVZRenVzWHNhZWFQWEFXdnJ0XzdtNWVyTVBaV3UyLXFQMVFndWhuMTRmcWhTY2puaGRwdUJhSkVOLXQwY2VvUG1VYU9tQUtjWHI4Z2pYYnQ0R3RxdjdXZ3pLTEFzYVJ6NVFCOTZlWG1QaUEzd2RvNnZQMFplNlhIdWttZjBWUnZhWkIxeThTdURaTVJXVWNkay4ybjBmaUVsWUxuemVxZFdOLmtZX09fRURpc0lWazVEb21QSEY3NlV6YTRGTE1PX2o3VjZURzhYZUVJZTFnSXdqT1VjWndCMm0taFJobVl2VFh5Z3V0aDJTdTFZMU1hejQ1WFJSaU9zMEM0ZFhtOXlNVkl1alBYLXRvcFNZYWtSRzNXY1hleDBKZDVoakhDRHZaUTZDLUFqUGEtZ1JSeWlybGdfZjhUc1BXYlBVckpJaXRyZ25WbFJ2VWtVb0dVM21QSlFpNlk1VGptUkNFLW9ncVRhdi1STERFS296eDVXV0JCcDM4dlB5bzJKQWNoN0Z4RnFFb2pQYlpIenJIVDljd2FfZlhaVU5yY0hoWEdVQjRwSnpfRW4wcXVSZGxTcGFVRXJYVVdXQUhLUmZDeDNpUXpzeTZUNGw3N3Q3WG9ZcURCc0pzX3UwcTRvS3hJZHZMbXltSUtfMi1ZLTRsVDBjaGV6N1p1WkdfeDZMcmdQVlU3elZ0VkQtUUl2Z3l6NzZYQUY2X3A3Y1lEWXpwRFlmMmNRVkFtbXNzRHBNSDh4RThGVDE0U0w4OGF5TGV3ZUpmUFFBVTVHNlR6XzFUNndyME5aVjRqWU5WT2xUNUNsWWFXWkZmTFFMSzZqM05qZDFRbnA1RXNTc1hqNkhpMm5YQ2VhMWM2TEphLkNjWmVMNlEtcWpNOHNTMlJ0MDZHNnc=',
    },
  },
  {
    'queryId': '9fe12fc0-4756-424d-9354-b34c2850e7ba',
    'status': undefined,
    'metaData': undefined,
    'mutationInfo': undefined,
    'data': {
      'batch': undefined,
      'encryptedBatch': '',
      'executionStats': {
        'timing': {
          'executionTimeNs': 1170414000,
          'compilationTimeNs': 56749358,
        },
        'bytesProcessed': 14993160,
        'recordsProcessed': 217537,
      },
    },
  },
];
