syntax = "proto3";

package pl.vispb;

import "google/protobuf/any.proto";

// PXType represents the data type of an argument that a pxl script can take.
// For example, with a func like def my_func(arg1: px.Service, arg2: int),
// the PXType of arg1 would be PX_SERVICE and the PXType of arg2 would be PX_INT64.
enum PXType {
  PX_UNKNOWN = 0;
  // 0-999 are reserved for "non-semantic" types.
  PX_BOOLEAN = 1;
  PX_INT64 = 2;
  PX_FLOAT64 = 3;
  PX_STRING = 4;
  // 1000+ are reserved for semantic types.
  // Note: PX_POD and PX_SERVICE are both expressed with the namespace prepended.
  // For example, a pod called orders-123 in namespace pl should be written like "pl/orders-123".
  PX_SERVICE = 1000;
  PX_POD = 1001;
  PX_CONTAINER = 1002;
  PX_NAMESPACE = 1003;
  PX_NODE = 1004;
}

// Vis is the protobuf form of vis.json which describes the configuration of a Live View.
// It is used to define both the functions to execute from pxl as well as the way to render
// the charts and other widgets on the screen.
message Vis {
  // A Variable is a placeholder that allows the Vis message to be parametrized.
  // FuncArgs (below) can be bound to one of these named variables. Then, when the Vis is executed,
  // a mapping of the variable names to their values will be passed alongside the Vis message.
  // Those mappings do not exist here so that the same Vis message can be run multiple times with
  // different values for those variables. Multiple FuncArgs can be bound to the same Variable.
  message Variable {
    // name is the name of the variable, which is the identifier that a FuncArg in a Widget can be bound to.
    string name = 1;
    // type is the type of the value that the variable belongs to. It can be a semantic type like PX_SERVICE,
    // which maps to the pxl type px.Service, or it can be a basic type like INT64.
    PXType type = 2;
    // default_value is the default value for the variable if it isn't specified elsewhere.
    // It is always represented as a string, but it will be parsed by the pxl script based on the type field.
    // so for type=PX_STRING, default_value could be "foo", and for type=PX_INT64, default_value could be "123".
    string default_value = 3;
    // description provides a description of the variable to help the user fill it in.
    string description = 4;
  }
  // variables defines the set of input variables that Widgets in this Live View can bind to.
  repeated Variable variables = 1;
  // widgets defines the set of Widgets that will be displayed by the Live View in the shared grid.
  // These can be charts, tables, or other visualizations that display the output of a pxl function.
  repeated Widget widgets = 2;

  // Global functions are function calls that can be referenced by widgets as an
  // alternative to writing a function in-line. Using global functions instead
  // of a locally defined function means you can safely re-use and update a
  // definition of a function without much issue and also has a slight
  // performance benefit because you reduce the necessary data transfer.
  message GlobalFunc {
    // The name to assign the result of the function call.
    string output_name = 1;
    // The function to call and store in output_name.
    Widget.Func func = 2;
  }
  // The list of global functions available to the widgets.
  repeated GlobalFunc global_funcs = 3;
}

// Widget A Widget is a visual element in a Live View. It can be a chart, a map, a table,
// other and other component like that. The data produced by a Widget comes from a single pxl
// function invocation, which is specified (with arguments) in the Widget message.
// That function invocation produces one or more output DataFrames which can be consumed by
// the display portion of the widget.
message Widget {
  // name is an optional field for Widget. If it isn't specified, names for the outputs
  // associated with its calling func will be generated by either the UI or the CLI.
  // name must be unique across all Widgets in a given Vis.
  string name = 1;

  // Position The location in the Live View grid that this Widget resides in, as well as its size.
  // While this is persisted, it is subject to change by the UI when loaded into the UI if the values collide.
  message Position {
    // x is the x position in grid coordinates of the Widget.
    int32 x = 1;
    // x is the y position in grid coordinates of the Widget.
    int32 y = 2;
    // width of the Widget
    int32 w = 3;
    // height of the Widget
    int32 h = 4;
  }
  Position position = 2;

  // Func the pxl function to invoke in order to produce the desired output table(s) for the Widget.
  // May include a script name or not. (my_func vs my_script.my_func).
  message Func {
    // name represents the name of the function to be invoked by this Vis.
    // It may include a path to a global or imported pxl script, or it may just be the name of the function
    // when a single pxl script is used in a Vis.
    string name = 1;
    // FuncArg the args passed to the func when it is invoked. Func args are passed by keyword, and their
    // type is inferred from the keyword argument type annotation in the pxl func.
    message FuncArg {
      // name is the name of the argument, which will be passed by keyword to the invoked pxl script function.
      string name = 1;
      oneof input {
        // Arg values are always represented as strings in the serialized form of the Vis, and then
        // undergo type-specific interpretation in the compiler.
        string value = 2;
        // A variable name from the 'variables' field of the Vis message.
        string variable = 3;
      }
    }
    // args is the keyword args and their values with which to call the func specified in 'name' (above).
    repeated FuncArg args = 2;
  }

  oneof func_or_ref {
    Func func = 3;
    string global_func_output_name = 5;
  }

  // This field represents the display of the Widget.
  // See BarChart and TimeseriesChart below for example displays.
  google.protobuf.Any display_spec = 4;
}

// Display protos
// General note: For both VegaChart and other kinds of charts, here is the protocol
// for how to reference output column names, taking the column name 'service' as an example:
// 1) For cases where the Widget func produces a single output table, as well as cases where
//    the Widget func produces multiple output tables but only one of those tables contains a
//    column called "service": just use the string "service".
// 2) For cases where the Widget func produces multiple tables, multiple of which have a column
//    called "service": use "outputs[0].service" for table 1, "outputs[1].service" for table 2,
//    and so on. the word "outputs" does not vary by widget.

// Axis the representation of an axis, could be x, y, y2.
// Note that the configuration of axes and other display properties of charts is intentionally
// left very limited. This is to ensure a consistent visual style in output charts.
message Axis {
  // label refers to the title that should be placed on the axis.
  string label = 1;
}

// BarChart The visual spec for a bar chart. Supports stacking and grouping of a single value column.
message BarChart {
  // Bar contains the logical specification of the Bar chart.
  message Bar {
    // Value denotes the value to plot, for example "request count".
    string value = 1;
    // Label denotes the label on the bars that are plotted by value, for example "service".
    string label = 2;
    // Stack columns When stack_by is set, stack by the provided column, for example "pod".
    // (visual ex: https://vega.github.io/vega-lite/examples/stacked_bar_weather.html)
    string stack_by = 3;
    // Group columns When group_by is set, group by the provided column, for example "cluster".
    // (visual ex: https://vega.github.io/vega-lite/examples/bar_grouped.html)
    string group_by = 4;
  }
  Bar bar = 1;
  // title is the title string for the chart.
  string title = 2;
  // x_axis defines configuration for the x axis of the chart.
  Axis x_axis = 3;
  // y_axis defines configuration for the y axis of the chart.
  Axis y_axis = 4;
}

// TimeseriesChart the visual spec for a timeseries chart. There is variety in the possible visual
// style for these charts, but they always occur over time. They automatically use the time_ column
// of the input table(s) as the x-axis.
message TimeseriesChart {
  // Timeseries is the logical specification of the timeseries.
  message Timeseries {
      // value is the value to plot, such as 'latency'.
      string value = 1;
      // series, if provided, is the series to create for the timeseries, such as 'service'.
      string series = 2;

      // If series is set, stack_by_series causes the series to be stacked on top of each other
      // rather than all from the offset of y=0.
      bool stack_by_series = 3;

      // Mode represents the visual display mode for this timeseries.
      enum Mode {
        MODE_UNKNOWN = 0;
        MODE_BAR = 1;
        MODE_LINE = 2;
        MODE_POINT = 3;
      }
      Mode mode = 4;
  }

  // timeseries contains the specification for each timeseries in this chart.
  // This field being repeated supports multiple timeseries on the same chart.
  repeated Timeseries timeseries = 1;
  // title is the title string for the chart.
  string title = 2;
  // x_axis defines configuration for the x axis of the chart.
  Axis x_axis = 3;
  // y_axis defines configuration for the y axis of the chart.
  Axis y_axis = 4;
}

// VegaChart the spec for providing a vega or vega lite spec directly to the UI.
message VegaChart {
  // spec is the serialized JSON form of the Vega/Vega Lite spec.
  string spec = 1;
}

// Table the spec for displaying the output as a table.
message Table {
  // LatencyBoxPlot tells the UI to display the latencies as a box whisker plot.
  message LatencyBoxPlot {
    float p50_column = 1;
    float p90_column = 2;
    float p99_column = 3;
  }
  // ColumnDisplay gives the display options for a given column.
  message ColumnDisplay {
    oneof column {
      // name refers to the name of an output column.
      string name = 1;
      // display_spec provides a display spec that does special visualization on top of a normal column.
      // It can use multiple columns. LatencyBoxPlot is one such example of a field that could go here.
      google.protobuf.Any display_spec = 2;
    }
    // display_title provides a pretty name to give the column in the UI.
    string display_title = 3;
  }
  // display_columns, when provided, gives a list of columns and their display options.
  // When not provided, all columns of the output table are displayed noramlly.
  repeated ColumnDisplay display_columns = 1;
}

// Graph the spec for displaying the output as a graph.
message Graph {
  message AdjacencyList {
    // The column containing the source nodes in the graph.
    string from_column = 1;
    // The column containing the destination nodes in the graph.
    string to_column = 2;
  }
  oneof input {
    // The column which contains the dot-formatted graph file to render.
    string dot_column = 1;
    AdjacencyList adjacency_list = 2;
  }
}
