syntax = "proto3";

package pl.stirling.dynamictracingpb;

option go_package = "dynamictracingpb";

enum BPFHelper {
  GOID = 0;
  TGID = 1;
  TGID_PID = 2;
}

enum ScalarType {
  INT32 = 0;
  INT64 = 1;
  DOUBLE = 2;
  // Same as char pointer.
  STRING = 3;
  VOID_POINTER = 4;
}

enum Register {
  SP = 0;
}

message ValueType {
  oneof type_oneof {
    ScalarType scalar = 2;
    string struct_type = 3;
  }
}

// Describe a BPF map.
// Corresponds to px.Map().
message Map {
  string name = 1;

  ValueType key_type = 2; // Exclusive to physical IR.
  ValueType value_type = 3; // Exclusive to physical IR.
}

// Describes a perf buffer to hold output data from BPF.
// Corresponds to px.Output().
message Output {
  string name = 1;

  ValueType type = 2;  // Exclusive to physical IR.
}

// Corresponds to inserting value(s) with key to a map.
// Multiple values are grouped together.
message StashMapAction {
  string map_name = 1;
  oneof key_oneof {
    string str = 2;
    BPFHelper builtin = 3;
  }
  repeated string value_ids = 4;
}

message OutputAction {
  // The name of the output sink.
  string output_name = 1;

  // The IDs of the values to be submitted to output sink specified by the name.
  repeated string value_ids = 2;
}

message Argument {
  // Used to reference to this argument, and as the name of the column to hold the values of this
  // argument when this is exported to a table.
  string id = 1;

  // An expression that accesses a subfield of this argument.
  // For example, "foo" refers to an argument named "foo".
  // And "foo.bar" refers to the "bar" field of argument named "foo".
  //
  // NOTE: This should only be a accessor expression started with the name of an argument.
  string expr = 2;
}

message ReturnValue {
  // Used to reference to this return value, and as the name of the column to hold the values of
  // this argument when this is exported to a table.
  string id = 1;

  // The index to this return value. This is only meaningful for languages that support multiple
  // return values, like Go.
  uint32 index = 2;
}

message FunctionLatency {
  string id = 1;
}

// Describes where to attach a probe.
message TracePoint {
  string binary_path = 1;
  string function_symbol = 2;
}

// Describes a C struct. This is directly converted to a C struct in BCC code.
message Struct {
  // The name of this struct.
  string name = 1;

  message Field {
    string name = 1;
    ValueType type = 2;
  }

  repeated Field fields = 2;
}

// Describes how to access variable in memory from inside BCC code.
message Variable {
  string id = 1;
  ScalarType type = 2;

  oneof base_addr_oneof {
    Register register = 3;
    string variable = 4;
  }

  uint32 offset = 5;
}

// Corresponds to a logical probe.
message Probe {
  enum Type {
    // Exclusively used by logical IR.
    LOGICAL = 0;

    // ENTRY and RETURN are for intermediate and physical IR.
    ENTRY = 1;
    RETURN = 2;
  }

  Type type = 1;  // Common to logical, intermediate, and physical IRs.

  // Where to attach this probe.
  TracePoint trace_point = 2;  // Common to logical, intermediate, and physical IRs.

  // Input arguments of a function.
  repeated Argument args = 3;

  // Return values of a function.
  repeated ReturnValue ret_vals = 4;

  // Latency of a function.
  FunctionLatency function_latency = 5;

  // C data structures used by BCC code, for example, as perf buffer's output type.
  repeated Struct structs = 6;  // Exclusive to physical IR.

  // Defines how to access variables from inside BCC code..
  repeated Variable vars = 7; // Exclusive to physical IR.

  // Inserts key and value into a map.
  repeated StashMapAction stash_map_actions = 8;

  // Writes a value to perf buffer.
  repeated OutputAction output_actions = 9;
}
