#pragma once

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#include "src/common/status.h"
#include "src/common/types/types.pb.h"
#include "src/stirling/info_class_schema.h"
#include "src/stirling/proto/collector_config.pb.h"

using pl::Status;

namespace pl {
namespace stirling {

class PubSubManager {
 public:
  /**
   * @brief Construct a new PubSubManager object.
   *
   * @param info_class_mgrs References to info class managers that are generated by various
   * SourceConnectors.
   */
  explicit PubSubManager(const std::vector<std::unique_ptr<InfoClassManager>>& info_class_mgrs)
      : info_class_mgrs_(info_class_mgrs) {}
  virtual ~PubSubManager() = default;

  /**
   * @brief Create a proto message from InfoClassManagers (which each have a schema).
   *
   * @return stirlingpb::PubSub Initial publish message to be sent to agent
   */
  stirlingpb::Publish GeneratePublishProto();

  /**
   * @brief Update the ElementState for each InfoElement in the InfoClassManager
   * in info_class_mgrs_ from a subscription message and notify the data collector
   * about the update to schemas. The data collector can then proceed to configure
   * SourceConnectors and DataTable with the subscribed information.
   *
   * @param subscribe_proto
   * @return Status
   */
  Status UpdateSchemaFromSubscribe(const stirlingpb::Subscribe& subscribe_proto);

  const std::vector<std::unique_ptr<InfoClassManager>>& info_class_managers() {
    return info_class_mgrs_;
  }

 private:
  const std::vector<std::unique_ptr<InfoClassManager>>& info_class_mgrs_;
};

}  // namespace stirling
}  // namespace pl
