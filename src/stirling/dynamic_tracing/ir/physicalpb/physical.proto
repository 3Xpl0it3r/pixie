syntax = "proto3";

package pl.stirling.dynamic_tracing.ir.physical;

import "src/stirling/dynamic_tracing/ir/sharedpb/shared.proto";

enum Register {
  SP = 0;
  // Return value or pointer for C/C++ calling convention.
  RC = 1;
}

// Describes a C struct. This is directly converted to a C struct in BCC code.
message Struct {
  // The name of this struct.
  string name = 1;

  message Field {
    string name = 1;
    shared.ScalarType type = 2;
  }

  repeated Field fields = 2;
}

// Describes how to access variable in register or memory from inside BCC code.
message ScalarVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // Describes type of the value held by this ScalarVariable.
  //
  // When this is VOID_POINTER, this ScalarVariable describes an intermediate variable used to access
  // a scalar variable.
  shared.ScalarType type = 2;

  // Describes a variable that resides in memory, in comparison to a Register variable.
  message MemoryVariable {
    // This must points to a ScalarVariable with VOID_POINTER type, which specifies the base address
    // to access this variable.
    string base = 1;

    // The offset off the base address.
    uint32 offset = 2;
  }

  // Describes a variable that is calculated from 2 other previously-defined variables.
  message BinaryExpression {
    enum Op {
      // TODO(yzhao): Today only support subtraction for function latency calculated.
      SUB = 0;
    }

    Op op = 1;

    string lhs = 2;
    string rhs = 3;
  }

  // TODO(yzhao): address_oneof probably should be renamed to expr, which indicates that it
  // describes how to compute this variable.
  oneof address_oneof {
    // Address is stored in a register.
    // NOTE: 'reg' is used to avoid name collision with C++ keyword 'register'.
    Register reg = 3;

    // Address is in memory (either stack or heap).
    MemoryVariable memory = 4;

    // Return value from one of the BPF helper functions.
    shared.BPFHelper builtin = 5;

    // This is directly assigned to the variable.
    string constant = 6;

    // Calculated from another 2 variables.
    BinaryExpression binary_expr = 7;
  }
}

// Describes a variable returned from reading a map.
// The variable is a pointer to the type held by the map.
message MapVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // The type of the struct returned by the map.
  string type = 2;

  // The name of the BPF map to retrieve the value.
  string map_name = 3;

  // The builtin to generate the key value to access the map.
  string key_variable_name = 4;
}

// Describes a variable returned from reading a member of a struct pointer.
// NOTE: Could consider embedding this into MapVariable.
//       The benefit is that the struct base would no longer be required.
//       The downside is it breaks the model of ScalarVariable, StructVariable, etc.
//       each mapping to a single variable declaration in the generated code.
message MemberVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // Describes type of the value held by this ScalarVariable.
  shared.ScalarType type = 2;

  // The name of the StructVariable that contains the field.
  string struct_base = 3;

  // Indicate if the struct_base is a pointer.
  bool is_struct_base_pointer = 4;

  // The builtin to generate the key value to access the map.
  string field = 5;
}

// Describes a struct variable whose fields are assigned values from other scalar variables.
// A struct variable therefore cannot have nested struct variables.
message StructVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // The struct that holds all values defined below.
  string type = 2;

  // Describe an expression to assign variable_name to the specified field.
  message FieldAssignment {
    string field_name = 1;
    string variable_name = 2;
  }

  // The names of the variables that are assigned to the fields in the above struct.
  // The variable count must be equal to the field count of the above struct.
  // If unset, the corresponding field is default constructed.
  repeated FieldAssignment field_assignments = 3;
}

// A container of different types of variables. Defines how to access them from inside BCC code..
// Variable names must be unique.
message Variable {
  oneof var_oneof {
    ScalarVariable scalar_var = 1;
    StructVariable struct_var = 2;
    MapVariable map_var = 3;
    MemberVariable member_var = 4;
  }
}

// Corresponds to inserting value(s) with key to a map.
// Multiple values are grouped together.
message MapStashAction {
  string map_name = 1;

  // The builtin to generate the key value.
  string key_variable_name = 2;

  // The name of the variable to be inserted into this map.
  string value_variable_name = 3;

  // If set, this decide the condition which this map stash should be executed.
  shared.Condition cond = 4;
}

message PerfBufferOutputAction {
  // The name of the perf buffer..
  string perf_buffer_name = 1;

  // The names of the variables to be submitted to the perf buffer.
  string variable_name = 2;
}

message MapDeleteAction {
  string map_name = 1;

  // The builtin to generate the key value.
  string key_variable_name = 2;
}

// Corresponds to a logical probe.
message Probe {
  // The name of the BCC probe function.
  string name = 1;

  // Where to attach this probe.
  shared.TracePoint trace_point = 2;

  // All variables defined inside this probe.
  repeated Variable vars = 3;

  // Latency of a function.
  oneof function_latency_oneof {
    shared.FunctionLatency function_latency = 8;
  }

  // Inserts key and value into a map.
  //
  // The variable to be inserted into the map must be one of the above vars.
  repeated MapStashAction map_stash_actions = 5;

  // Deletes a BPF map entry.
  repeated MapDeleteAction map_delete_actions = 9;

  // Writes a value to perf buffer.
  repeated PerfBufferOutputAction output_actions = 6;

  // Printk text.
  repeated shared.Printk printks = 7;
}

message PerfBufferOutput {
  string name = 1;

  repeated string fields = 2;

  // Describe the name of the struct that holds the output variables.
  string struct_type = 3;
}

// This describes a complete BPF program.
message Program {
  shared.DeploymentSpec deployment_spec = 1;

  // What language is used by the target binary.
  shared.Language language = 6;

  // Describes the global structs.
  repeated Struct structs = 2;

  // Describes BPF maps.
  repeated shared.Map maps = 3;

  // Describes perf buffers.
  repeated PerfBufferOutput outputs = 4;

  // Describes probe functions.
  repeated Probe probes = 5;
}
