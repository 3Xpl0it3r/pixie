syntax = "proto3";

package pl.stirling.dynamic_tracing.ir.physical;

import "src/stirling/dynamic_tracing/ir/shared.proto";

// TODO(yzhao): It seems we might need to encode other registers in addition to SP, for example,
// X86 calling convention uses registers as function argument addresses.
enum Register {
  SP = 0;
}

// Describes a C struct. This is directly converted to a C struct in BCC code.
message Struct {
  // The name of this struct.
  string name = 1;

  message Field {
    string name = 1;
    shared.VariableType type = 2;
  }

  repeated Field fields = 2;
}

// Describes how to access variable in register or memory from inside BCC code.
message ScalarVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // Describes type of the value held by this ScalarVariable.
  //
  // When this is VOID_POINTER, this ScalarVariable describes an intermediate variable used to access
  // a scalar variable.
  shared.ScalarType type = 2;

  // Describes a variable that resides in memory, in comparison to a Register variable.
  message MemoryVariable {
    // This must points to a ScalarVariable with VOID_POINTER type, which specifies the base address
    // to access this variable.
    string base = 1;

    // The offset off the base address.
    uint32 offset = 2;
  }

  oneof address_oneof {
    // Address is stored in a register.
    // NOTE: 'reg' is used to avoid name collision with C++ keyword 'register'.
    Register reg = 3;

    // Address is in memory (either stack or heap).
    MemoryVariable memory = 4;

    // Return value from one of the BPF helper functions.
    shared.BPFHelper builtin = 5;
  }
}

// Describes a struct variable whose fields are assigned values from other scalar variables.
// A struct variable therefore cannot have nested struct variables.
message StructVariable {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // The struct that holds all values defined below.
  string type = 2;

  message VariableName {
    oneof name_oneof {
      string name = 1;
    }
  }

  // The names of the variables that are assigned to the fields in the above struct.
  // The variable count must be equal to the field count of the above struct.
  // If unset, the corresponding field is default constructed.
  repeated VariableName variable_names = 3;
}

// Corresponds to a logical probe.
message PhysicalProbe {
  // The name of the BCC probe function.
  string name = 1;

  // Where to attach this probe.
  shared.TracePoint trace_point = 2;

  // Defines how to access variables from inside BCC code..
  //
  // StructVariable names must be unique, as BCC codegen does not modify them.
  //
  // StructVariables are for instances of Struct, which are custom defined, and are not based on
  // variables in DWARF. So ScalarVariable should not need to reference based off
  // any StructVariables.
  repeated ScalarVariable vars = 3;

  // Defines how to create struct variables from the above scalar variables from inside BCC code.
  //
  // StructVariable names must be unique, as BCC codegen does not modify them.
  repeated StructVariable st_vars = 4;

  // Inserts key and value into a map.
  //
  // The variable to be inserted into the map must be one of the above vars.
  repeated shared.MapStashAction map_stash_actions = 5;

  // Writes a value to perf buffer.
  repeated shared.OutputAction output_actions = 6;
}

// This describes a complete BPF program.
message Program {
  // Describes the global structs.
  repeated Struct structs = 1;

  // Describes BPF maps.
  repeated shared.Map maps = 2;

  // Describes perf buffers.
  repeated shared.Output outputs = 3;

  // Describes probe functions.
  repeated PhysicalProbe probes = 4;
}
