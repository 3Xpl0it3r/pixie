syntax = "proto3";

package pl.stirling.dynamic_tracing.ir.shared;

option go_package = "pixielabs.ai/pixielabs/src/stirling/dynamic_tracing/ir/sharedpb";

enum Language {
  // Automatically infer the language (default).
  AUTO = 0;
  C = 1;
  CPP = 2;
  GOLANG = 3;
}

// All enum values must be consecutive, as they are used as array index in codegen.
enum BPFHelper {
  GOID = 0;
  TGID = 1;
  TGID_PID = 2;
  TGID_START_TIME = 3;

  // Return the kernel time in nanoseconds.
  KTIME = 4;
}

// This scalar type encompasses basic types across all supported languages.
// For Golang, refer to: https://golang.org/pkg/go/types/#pkg-variables
// For C++, refer to: https://en.cppreference.com/w/cpp/language/types
// TODO(oazizi): Move to physical.proto once last use in logical form is removed.
enum ScalarType {
  UNKNOWN = 0;

  // Boolean.
  BOOL = 100;

  // Integer types (relative definitions).
  // The widths of these types may change depending on the hardware.
  // Note that C++ absolute width types (e.g. uint32_t) map to these types,
  // with the mapping recorded in the DWARF information.
  SHORT = 200;
  USHORT = 201;
  INT = 202;
  UINT = 203;
  LONG = 204;
  ULONG = 205;
  LONGLONG = 206;
  ULONGLONG = 207;

  // Integer types (absolute widths).
  // Used by Golang only (see note about C++ above).
  INT8 = 300;
  INT16 = 301;
  INT32 = 302;
  INT64 = 303;
  UINT8 = 304;
  UINT16 = 305;
  UINT32 = 306;
  UINT64 = 307;

  // Character types.
  CHAR = 400;
  UCHAR = 401;

  // Floating point types.
  FLOAT = 500;
  DOUBLE = 501;

  VOID_POINTER = 900;

  STRING = 1000;
  BYTE_ARRAY = 1001;

  // A struct represented as a blob of bytes.
  STRUCT_BLOB = 1100;
}

// Describes where to attach a probe.
message Tracepoint {
  message Function {
    // The name of the function. The format varies between languages.
    // In C++, it includes the fully qualified name of the function, including namespaces.
    // For example:
    // namespace pl {
    //   struct Foo {
    //     void Bar(int i) { ... }
    //     template <typename T> void Bar(T t) { ... }
    //   };
    // }  // namespace pl
    //
    // pl::Foo::Bar points to the only member function of struct Foo.
    string name = 1;

    // The types of the parameters.
    // This only applies to C++ (or any languages that support function overloading).
    // Use string to represent the type, instead of ScalarType, for greater flexibility to describe
    // scalar types and composite types.
    //
    // Use the example above, these types are described in the function signature:
    // pl::Foo::Bar(int)
    repeated string param_types = 2;
  }

  // Describes the target function to attach a Tracepoint.
  Function function = 3;

  // TODO(yzhao): Remove this field.
  string symbol = 1;

  enum Type {
    // Only for logical IR.
    LOGICAL = 0;

    // Intermediate and physical IR uses this to specify a BPF entry probe.
    ENTRY = 1;

    // Intermediate and physical IR uses this to specify a BPF return probe.
    RETURN = 2;
  }

  // This has to be LOGICAL for logical IR.
  Type type = 2;
}

// This cannot replace class UPID in src/shared/metadata/base_types.h, because the C++ UPID is
// created to be compatible with Arrow and uses uint128 for efficient processing.
message UPID {
  // A unique ID for a particular agent.
  uint32 asid = 1;

  // The PID of the running process on a particular node.
  uint32 pid = 2;

  // The start time stamp of the process, used to distinguish between processes having the same
  // PID across different time frame.
  uint64 ts_ns = 3;
}

// TODO(yzhao): This replaces BinarySpec.
// Describes the target of attaching a Tracepoint.
message DeploymentSpec {
  // TODO(yzhao): Remove this field, replaced by path_regexp, selector_oneof, and selected_upids.
  oneof target_oneof {
    // The path of the executable file.
    string path = 1;

    // The UPID of a running process.
    UPID upid = 3;
  }

  // Processes with exe path that matches this pattern are the target of this deployment.
  // The exe path is the one recorded in the process's exe path as seen inside the container,
  // not the one resolved through overlay FS.
  string path_regexp = 4;

  // Selector is used to select the target processes. All selected processes are subject to
  // filtering with path_regexp.
  oneof selector_oneof {
      // All processes running inside the pod are target processes.
      string pod_name = 5;

      // A specific upid.
      // TODO(yzhao): Rename to upid, after removing target_oneof.
      UPID upid1 = 6;
  }

  // The finalized process list for attachment. PEM/Stirling only uses this field.
  repeated UPID selected_upids = 7;
}

// Wraps an oneof field which can be either scalar or struct.
message VariableType {
  oneof type_oneof {
    ScalarType scalar = 2;
    string struct_type = 3;
  }
}

// Describe a BPF map.
// Corresponds to px.Map().
message Map {
  string name = 1;

  // TODO(yzhao): Remove the following 2 lines and create PerfBuffer in physical.proto with them.
  VariableType key_type = 2; // Exclusive to physical IR.
  VariableType value_type = 3; // Exclusive to physical IR.
}

// Describes a condition to be checked.
message Condition {
  enum Op {
    // NIL means this condition should be ignored.
    NIL = 0;
    EQUAL = 1;
  }

  // Describes the operation performed on the variables listed below.
  Op op = 1;

  // List variables used in the operation.
  repeated string vars = 2;
}

// bpf_trace_printk() on a text.
message Printk {
  oneof content_oneof {
    // A piece of hardcoded text.
    string text = 1;

    // Another ScalarVariable, cannot be StructVariable.
    string scalar = 2;
  }
}

// Indicates a variable named 'id' should be generated, and represents the latency from function
// entry to return.
message FunctionLatency { string id = 1; }
