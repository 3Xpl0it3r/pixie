syntax = "proto3";

package pl.stirling.dynamic_tracing.ir.logical;

import "src/stirling/dynamic_tracing/ir/shared.proto";

message Constant {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // Describes type of the constant.
  shared.ScalarType type = 2;

  // This is directly assigned to the variable.
  string constant = 3;
}

message Argument {
  // Used to reference this argument.
  string id = 1;

  // An expression that accesses a subfield of this argument.
  // For example, "foo" refers to an argument named "foo".
  // And "foo.bar" refers to the "bar" field of argument named "foo".
  //
  // NOTE: This should only be a accessor expression started with the name of an argument.
  string expr = 2;
}

message ReturnValue {
  // Used to reference this return value.
  string id = 1;

  // The index to this return value. This is only meaningful for languages that support multiple
  // return values, like Go.
  uint32 index = 2;
}

message MapValue {
  string map_name = 1;

  // The builtin to generate the key value.
  string key_expr = 2;

  repeated string value_ids = 3;
}

message FunctionLatency {
  string id = 1;
}

message MapStashAction {
  string map_name = 1;

  shared.BPFHelper key = 2;

  // The name of the variable to be inserted into this map.
  repeated string value_variable_name = 3;

  // If set, this decide the condition which this map stash should be executed.
  shared.Condition cond = 4;
}

message OutputAction {
  string output_name = 1;

  // The name of the variables to be output.
  repeated string variable_name = 3;
}

// Corresponds to a logical probe.
message Probe {
  string name = 1;

  // Where to attach this probe.
  shared.TracePoint trace_point = 2;

  // This is only used by intermediate IR to implement if condition that compares with a constant.
  repeated Constant consts = 3;

  // Input arguments of a function.
  repeated Argument args = 4;

  // Return values of a function.
  repeated ReturnValue ret_vals = 5;

  // Map variables to unstash.
  repeated MapValue map_vals = 6;

  // Latency of a function.
  FunctionLatency function_latency = 7;

  // Inserts key and value into a map.
  //
  // The variable to be inserted into the map must be one of the above args, ret_vals, and function_latency.
  repeated MapStashAction map_stash_actions = 8;

  // Writes a value to the output table.
  //
  // The variable to be inserted into the output table must be one of the above args, ret_vals, and function_latency.
  repeated OutputAction output_actions = 9;

  // Used for debugging to print variable defined above.
  repeated shared.Printk printks = 10;
}

// A logical program.
// Represents a fully logical program, or one in intermediate state.
// Example: The simplest logical program will have only a single probe (no outputs, no maps),
// which will then get transformed into a program with multiple probes, maps and outputs.
message Program {
  shared.BinarySpec binary_spec = 1;

  // The programs outputs to a table.
  repeated shared.Output outputs = 2;

  // Maps holding shared state across probes.
  repeated shared.Map maps = 3;

  // All the probes of the program.
  repeated Probe probes = 4;
}
