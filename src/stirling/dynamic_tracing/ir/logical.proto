syntax = "proto3";

package pl.stirling.dynamic_tracing.ir.logical;

import "src/stirling/dynamic_tracing/ir/shared.proto";

message Constant {
  // Name must be unique in the scope of a Probe.
  string name = 1;

  // Describes type of the constant.
  shared.ScalarType type = 2;

  // This is directly assigned to the variable.
  string constant = 3;
}

message Argument {
  // Used to reference to this argument, and as the name of the column to hold the values of this
  // argument when this is exported to a table.
  string id = 1;

  // An expression that accesses a subfield of this argument.
  // For example, "foo" refers to an argument named "foo".
  // And "foo.bar" refers to the "bar" field of argument named "foo".
  //
  // NOTE: This should only be a accessor expression started with the name of an argument.
  string expr = 2;
}

message ReturnValue {
  // Used to reference to this return value, and as the name of the column to hold the values of
  // this argument when this is exported to a table.
  string id = 1;

  // The index to this return value. This is only meaningful for languages that support multiple
  // return values, like Go.
  uint32 index = 2;
}

message FunctionLatency {
  string id = 1;
}

message MapStashAction {
  string map_name = 1;

  shared.BPFHelper key = 2;

  // The name of the variable to be inserted into this map.
  repeated string value_variable_name = 3;

  // If set, this decide the condition which this map stash should be executed.
  shared.Condition cond = 4;
}

message OutputAction {
  string output_name = 1;

  // The name of the variables to be output.
  repeated string variable_name = 3;
}

// Corresponds to a logical probe.
message Probe {
  string name = 1;

  // Where to attach this probe.
  shared.TracePoint trace_point = 2;

  // This is only used by intermediate IR to implement if condition that compares with a constant.
  repeated Constant consts = 3;

  // Input arguments of a function.
  repeated Argument args = 4;

  // Return values of a function.
  repeated ReturnValue ret_vals = 5;

  // Latency of a function.
  FunctionLatency function_latency = 6;

  // Inserts key and value into a map.
  //
  // The variable to be inserted into the map must be one of the above args, ret_vals, and function_latency.
  repeated MapStashAction map_stash_actions = 7;

  // Writes a value to the output table.
  //
  // The variable to be inserted into the output table must be one of the above args, ret_vals, and function_latency.
  repeated OutputAction output_actions = 8;
}

// A logical program.
// Represents a fully logical program, or one in intermediate state.
// Example: The simplest logical program will have only a single probe (no outputs, no maps),
// which will then get transformed into a program with multiple probes, maps and outputs.
message Program {
  // The programs outputs to a table.
  repeated shared.Output outputs = 1;

  // Maps holding shared state across probes.
  repeated shared.Map maps = 2;

  // All the probes of the program.
  repeated Probe probes = 3;
}
