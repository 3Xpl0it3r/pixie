#include <google/protobuf/text_format.h>
#include <google/protobuf/util/message_differencer.h>
#include <gtest/gtest.h>

#include <cstring>
#include <vector>

#include "src/stirling/bcc_connector.h"
#include "src/stirling/info_class_manager.h"
#include "src/stirling/pub_sub_manager.h"
#include "src/stirling/source_connector.h"

namespace pl {
namespace stirling {

using google::protobuf::TextFormat;
using google::protobuf::util::MessageDifferencer;
using stirlingpb::Element_State;
using stirlingpb::InfoClass;
using types::DataType;

const char* kInfoClassManager = R"(
  name : "cpu_usage",
  elements {
    name: "user_percentage",
    type: FLOAT64,
    state: SUBSCRIBED,
  }
  elements {
    name: "system_percentage",
    type: FLOAT64,
    state: SUBSCRIBED,
  }
  elements {
    name: "io_percentage",
    type: FLOAT64,
    state: SUBSCRIBED,
  }
  metadata {
    key: "source"
    value: "cpu_usage"
  }
  subscribed: false
)";

class PubSubManagerTest : public ::testing::Test {
 protected:
  PubSubManagerTest()
      : element_1("user_percentage", DataType::FLOAT64, Element_State::Element_State_SUBSCRIBED),
        element_2("system_percentage", DataType::FLOAT64, Element_State::Element_State_SUBSCRIBED),
        element_3("io_percentage", DataType::FLOAT64, Element_State::Element_State_SUBSCRIBED) {}
  void SetUp() override {
    std::string name = "cpu_usage";
    source_ = BCCCPUMetricsConnector::Create(name);
    info_class_mgrs_.push_back(std::make_unique<InfoClassManager>(name));
    info_class_mgrs_[0]->SetSourceConnector(source_.get());

    info_class_mgrs_[0]->Schema().push_back(element_1);
    info_class_mgrs_[0]->Schema().push_back(element_2);
    info_class_mgrs_[0]->Schema().push_back(element_3);

    pub_sub_manager_ = std::make_unique<PubSubManager>();
  }

  std::unique_ptr<SourceConnector> source_;
  std::unique_ptr<PubSubManager> pub_sub_manager_;
  InfoClassManagerVec info_class_mgrs_;
  InfoClassElement element_1, element_2, element_3;
};

// This test validates that the Publish proto generated by the PubSubManager
// matches the expected Publish proto message (based on kInfoClassManager proto
// and with some fields added in the test).
TEST_F(PubSubManagerTest, publish_test) {
  // Publish info classes using proto message.
  stirlingpb::Publish actual_publish_pb;
  pub_sub_manager_->GeneratePublishProto(&actual_publish_pb, info_class_mgrs_);

  // Set expectations for the publish message.
  stirlingpb::Publish expected_publish_pb;
  auto expected_info_class = expected_publish_pb.add_published_info_classes();
  EXPECT_TRUE(TextFormat::MergeFromString(kInfoClassManager, expected_info_class));
  expected_info_class->set_id(0);

  EXPECT_FALSE(actual_publish_pb.published_info_classes(0).subscribed());
  EXPECT_EQ(1, expected_publish_pb.published_info_classes_size());
  EXPECT_EQ(0, actual_publish_pb.published_info_classes(0).id());

  EXPECT_TRUE(MessageDifferencer::Equals(actual_publish_pb, expected_publish_pb));
}

// This test validates that the InfoClassManager objects have their subscriptions
// updated after the PubSubManager reads a subscribe message (from an agent). The
// subscribe message is created using kInfoClassManager proto message and with fields from
// a Publish proto message.
TEST_F(PubSubManagerTest, subscribe_test) {
  // Do the publish.
  stirlingpb::Publish publish_pb;
  pub_sub_manager_->GeneratePublishProto(&publish_pb, info_class_mgrs_);

  // Get a subscription from an upstream agent.
  stirlingpb::Subscribe subscribe_pb;
  auto info_class = subscribe_pb.add_subscribed_info_classes();
  EXPECT_TRUE(TextFormat::MergeFromString(kInfoClassManager, info_class));

  // The subscribe message needs ids from the publish message and also
  // update the subscription.
  size_t id = publish_pb.published_info_classes(0).id();
  info_class->set_id(id);
  info_class->set_subscribed(true);

  // Update the InfoClassManager objects with the subscribe message.
  EXPECT_EQ(Status::OK(),
            pub_sub_manager_->UpdateSchemaFromSubscribe(subscribe_pb, info_class_mgrs_));
  // Verify updated subscriptions.
  for (auto& info_class_mgr : info_class_mgrs_) {
    EXPECT_TRUE(info_class_mgr->subscribed());
  }
}

}  // namespace stirling
}  // namespace pl
