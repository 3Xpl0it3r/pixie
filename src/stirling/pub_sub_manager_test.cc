#include <google/protobuf/text_format.h>
#include <google/protobuf/util/message_differencer.h>
#include <gtest/gtest.h>

#include <cstring>
#include <vector>

#include "src/stirling/bcc_connector.h"
#include "src/stirling/info_class_schema.h"
#include "src/stirling/pub_sub_manager.h"
#include "src/stirling/source_connector.h"

namespace pl {
namespace stirling {

using google::protobuf::TextFormat;
using google::protobuf::util::MessageDifferencer;
using stirlingpb::Element_State;
using stirlingpb::InfoClass;
using types::DataType;

const char* kInfoClassManager = R"(
  name : "cpu_usage",
  elements {
    name: "user_percentage",
    type: FLOAT64,
  }
  elements {
    name: "system_percentage",
    type: FLOAT64,
  }
  elements {
    name: "io_percentage",
    type: FLOAT64,
  }
  metadata {
    key: "source"
    value: "cpu_usage"
  }
)";

class PubSubManagerTest : public ::testing::Test {
 protected:
  PubSubManagerTest()
      : element_1("user_percentage", DataType::FLOAT64,
                  Element_State::Element_State_NOT_SUBSCRIBED),
        element_2("system_percentage", DataType::FLOAT64,
                  Element_State::Element_State_NOT_SUBSCRIBED),
        element_3("io_percentage", DataType::FLOAT64, Element_State::Element_State_NOT_SUBSCRIBED) {
  }
  void SetUp() override {
    std::string name = "cpu_usage";
    source_ = BCCCPUMetricsConnector::Create(name);
    pub_sub_manager_info_classes_.push_back(std::make_unique<InfoClassManager>(name));
    pub_sub_manager_info_classes_[0]->SetSourceConnector(source_.get());

    pub_sub_manager_info_classes_[0]->Schema().push_back(element_1);
    pub_sub_manager_info_classes_[0]->Schema().push_back(element_2);
    pub_sub_manager_info_classes_[0]->Schema().push_back(element_3);

    pub_sub_manager_ = std::make_unique<PubSubManager>(pub_sub_manager_info_classes_);
  }

  std::unique_ptr<SourceConnector> source_;
  std::unique_ptr<PubSubManager> pub_sub_manager_;
  std::vector<std::unique_ptr<InfoClassManager>> pub_sub_manager_info_classes_;
  InfoClassElement element_1, element_2, element_3;
};

// This test validates that the Publish proto generated by the PubSubManager
// matches the expected Publish proto message (based on kInfoClassManager proto
// and with some fields added in the test).
TEST_F(PubSubManagerTest, publish_test) {
  // Publish info classes using proto message.
  stirlingpb::Publish actual_publish_pb;
  pub_sub_manager_->GeneratePublishProto(&actual_publish_pb);

  // Set expectations for the publish message.
  stirlingpb::Publish expected_publish_pb;
  auto expected_info_class = expected_publish_pb.add_published_info_classes();
  EXPECT_TRUE(TextFormat::MergeFromString(kInfoClassManager, expected_info_class));
  expected_info_class->set_id(0);
  for (int element_idx = 0; element_idx < expected_info_class->elements_size(); ++element_idx) {
    expected_info_class->mutable_elements(element_idx)
        ->set_state(Element_State::Element_State_NOT_SUBSCRIBED);
  }

  EXPECT_EQ(1, expected_publish_pb.published_info_classes_size());
  EXPECT_EQ(0, actual_publish_pb.published_info_classes(0).id());
  EXPECT_TRUE(MessageDifferencer::Equals(actual_publish_pb, expected_publish_pb));
}

// This test validates that the InfoClassManager objects have their subscriptions
// updated after the PubSubManager reads a subscribe message (from an agent). The
// subscribe message is created using kInfoClassManager proto message and with fields from
// a Publish proto message.
TEST_F(PubSubManagerTest, subscribe_test) {
  // Do the publish.
  stirlingpb::Publish publish_pb;
  pub_sub_manager_->GeneratePublishProto(&publish_pb);

  // Get a subscription from an upstream agent.
  stirlingpb::Subscribe subscribe_pb;
  auto info_class = subscribe_pb.add_subscribed_info_classes();
  EXPECT_TRUE(TextFormat::MergeFromString(kInfoClassManager, info_class));

  // The subscribe message needs ids from the publish message and also
  // update the subscriptions for elements.
  size_t id = publish_pb.published_info_classes(0).id();
  info_class->set_id(id);
  for (int element_idx = 0; element_idx < info_class->elements_size(); ++element_idx) {
    info_class->mutable_elements(element_idx)->set_state(Element_State::Element_State_SUBSCRIBED);
  }

  // Update the InfoClassManager objects with the subscribe message.
  EXPECT_EQ(Status::OK(), pub_sub_manager_->UpdateSchemaFromSubscribe(subscribe_pb));
  // Verify updated subscriptions.
  for (auto& info_class_mgr : pub_sub_manager_->info_class_managers()) {
    for (size_t idx = 0; idx < info_class_mgr->Schema().size(); ++idx) {
      auto element = info_class_mgr->GetElement(idx);
      EXPECT_EQ(element.state(), Element_State::Element_State_SUBSCRIBED);
    }
  }
}

}  // namespace stirling
}  // namespace pl
