syntax = "proto3";

package pl.vizier.services.metadata;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "src/common/uuid/proto/uuid.proto";
import "src/table_store/proto/schema.proto";
import "src/carnot/planner/distributedpb/distributed_plan.proto";
import "src/vizier/messages/messagespb/messages.proto";
import "src/vizier/services/shared/agentpb/agent.proto";
import "src/stirling/dynamic_tracing/ir/logicalpb/logical.proto";
import "src/common/base/proto/status.proto";
import "google/protobuf/duration.proto";

option go_package = "pixielabs.ai/pixielabs/src/vizier/services/metadata/metadatapb;metadatapb";

service MetadataService {
  // An endpoint used by the query broker which is responsible for streaming the state of the agents.
  // It first sends the full initial state of the agents, and then it sends state updates after that.
  rpc GetAgentUpdates(AgentUpdatesRequest) returns (stream AgentUpdatesResponse) {}
  // These RPC calls are used by UDTFs to fetch metadata.
  rpc GetSchemas(SchemaRequest) returns (SchemaResponse) {}
  rpc GetAgentInfo(AgentInfoRequest) returns (AgentInfoResponse) {}
  // GetSchemaByAgent is currently inimplemented but would be used to fetch the schema for a given agent.
  rpc GetSchemaByAgent(SchemaByAgentRequest) returns (SchemaByAgentResponse) {}
}

service MetadataTracepointService {
  rpc RegisterTracepoint(RegisterTracepointRequest) returns (RegisterTracepointResponse) {}
  rpc GetTracepointInfo(GetTracepointInfoRequest) returns (GetTracepointInfoResponse) {}
  rpc RemoveTracepoint(RemoveTracepointRequest) returns (RemoveTracepointResponse) {}
}

// The schema request for each agent's schema.
message SchemaByAgentRequest {
  // IDs of the agents to get schemas from. If no IDs are specified,
  // it is assumed that schemas for all agents are requested.
  repeated uuidpb.UUID agent_ids = 1;
}

// The schema response from the metadata service.
message SchemaByAgentResponse {
  message SchemaByAgent {
    uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
    pl.table_store.schemapb.Schema schema = 2;
  }
  repeated SchemaByAgent schema_by_agent = 1;
}

message SchemaRequest {}

// The schema response from the metadata service containing the schema that all
// agents serve.
message SchemaResponse { pl.table_store.schemapb.Schema schema = 2; }

message AgentInfoRequest {}

message AgentInfoResponse {
  // Contains AgentMetadata for each of the agents currently registered with
  // Vizier.
  repeated AgentMetadata info = 1;
}

message AgentMetadata {
  pl.vizier.services.shared.agent.Agent agent = 1;
  pl.vizier.services.shared.agent.AgentStatus status = 2;
  // Info that describes the carnot instance for the agent.
  pl.carnot.planner.distributedpb.CarnotInfo carnot_info = 3;
}

message AgentUpdatesRequest {
  // The maximum amount of time to wait between updates.
  // Note that since a given update may be streamed across multiple AgentUpdatesResponses,
  // it's possible that the duration between responses will be less than `update_interval`.
  google.protobuf.Duration max_update_interval = 1;
  // The max number of agent updates per response.
  int32 max_updates_per_response = 2;
}

// AgentUpdate contains an update about a particular agent.
message AgentUpdate {
  uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
  oneof update {
    // True if the agent has been deleted.
    bool deleted = 2;
    // Updates to the agent's basic information.
    pl.vizier.services.shared.agent.Agent agent = 3;
    // Updates to the agent's table data info.
    pl.vizier.messages.AgentDataInfo data_info = 4;
  }
}

message AgentUpdatesResponse {
  // A list of agent updates, in the order in which they occurred.
  repeated AgentUpdate agent_updates = 1;
  // The latest version of the agent schemas, if they have changed since the last message.
  // For a given batch of AgentUpdates, the AgentSchemas will always be sent last so that they don't
  // refer to an agent ID that the client hasn't heard about yet.
  // Also note the schema will always be sent in its entirety, so it will not be paginated.
  repeated pl.carnot.planner.distributedpb.SchemaInfo agent_schemas = 2;
  // Whether or not the agent schemas have been updated. This is to differentiate between the case where
  // there are truly no AgentSchemas present and when there is no update to those agent schemas.
  bool agent_schemas_updated = 3;
}

// The request to register tracepoints on all PEMs.
message RegisterTracepointRequest {
    message TracepointRequest {
      pl.stirling.dynamic_tracing.ir.logical.TracepointDeployment tracepoint_deployment = 1;
      // The user-specified name for the tracepoint.
      string name = 2;
      // The TTL, in seconds, for how long we want the tracepoint to live.
      google.protobuf.Duration ttl = 3 [ (gogoproto.customname) = "TTL" ];
    }
    repeated TracepointRequest requests = 1;
}

// The response to a RegisterTracepointRequest.
message RegisterTracepointResponse {
  message TracepointStatus {
      pl.statuspb.Status status = 1;
      // The ID of the tracepoint. This should be the user-specified name for the tracepoint.
      uuidpb.UUID id = 2 [ (gogoproto.customname) = "ID" ];
      string name = 3;
  }
  repeated TracepointStatus tracepoints = 1;
  // Overall status of whether tracepoint registration requests were initiated with/without errors.
  pl.statuspb.Status status = 2;
}

// The request to check the status for a tracepoint with the given names.
message GetTracepointInfoRequest {
  // The tracepoint IDs to get the info for. If empty, fetches the info for all known tracepoints.
  repeated uuidpb.UUID ids = 1 [ (gogoproto.customname) = "IDs" ];
}

// The status of whether the tracepoint has successfully registered or not.
message GetTracepointInfoResponse {
    message TracepointState {
        // The tracepoint ID.
        uuidpb.UUID id = 1 [ (gogoproto.customname) = "ID" ];
        // The state of the tracepoint.
        pl.statuspb.LifeCycleState state = 2;
        // The status of the tracepoint, specified if the state of the tracepoint is not healthy.
        pl.statuspb.Status status = 3;
        string name = 4;
        // The desired state for the tracepoint. This can be used to determine whether
        // the tracepoint is just starting up or in the process of terminating.
        pl.statuspb.LifeCycleState expected_state = 5;
        repeated string schema_names = 6;
    }
    // List of tracepoint states.
    repeated TracepointState tracepoints = 1;
}

// The request to evict a tracepoint. This will normally happen via the tracepoint's TTL, but can be
// initiated via request as well.
message RemoveTracepointRequest {
    // The name of the tracepoint to remove.
    repeated string names = 1;
}

// The response to the tracepoint removal.
message RemoveTracepointResponse {
  // Status of whether the tracepoint removal request was initiated with/without errors.
  pl.statuspb.Status status = 1;
}
