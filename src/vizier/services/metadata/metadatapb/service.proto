syntax = "proto3";

package pl.vizier.services.metadata;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "src/common/uuid/proto/uuid.proto";
import "src/table_store/proto/schema.proto";
import "src/carnot/planner/distributedpb/distributed_plan.proto";
import "src/vizier/messages/messagespb/messages.proto";
import "src/vizier/services/shared/agentpb/agent.proto";
import "src/stirling/dynamic_tracing/ir/logical.proto";
import "src/common/base/proto/status.proto";
import "google/protobuf/duration.proto";

option go_package = "pixielabs.ai/pixielabs/src/vizier/services/metadata/metadatapb;metadatapb";

service MetadataService {
  /**
   * These RPC calls are used by the query broker and CLI to fetch metadata.
   */

  rpc GetSchemas(SchemaRequest) returns (SchemaResponse) {}
  rpc GetSchemaByAgent(SchemaByAgentRequest) returns (SchemaByAgentResponse) {}
  rpc GetAgentInfo(AgentInfoRequest) returns (AgentInfoResponse) {}
  rpc GetAgentTableMetadata(AgentTableMetadataRequest) returns (AgentTableMetadataResponse) {}
  rpc GetAgentUpdates(AgentUpdatesRequest) returns (stream AgentUpdatesResponse) {}
}

service MetadataTracepointService {
  rpc RegisterTracepoint(RegisterTracepointRequest) returns (RegisterTracepointResponse) {}
  rpc GetTracepointInfo(GetTracepointInfoRequest) returns (GetTracepointInfoResponse) {}
  rpc RemoveTracepoint(RemoveTracepointRequest) returns (RemoveTracepointResponse) {}
}

// The schema request for each agent's schema.
message SchemaByAgentRequest {
  // IDs of the agents to get schemas from. If no IDs are specified,
  // it is assumed that schemas for all agents are requested.
  repeated uuidpb.UUID agent_ids = 1;
}

// The schema response from the metadata service.
message SchemaByAgentResponse {
  message SchemaByAgent {
    uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
    pl.table_store.schemapb.Schema schema = 2;
  }
  repeated SchemaByAgent schema_by_agent = 1;
}

message SchemaRequest {}

// The schema response from the metadata service containing the schema that all
// agents serve.
message SchemaResponse { pl.table_store.schemapb.Schema schema = 2; }

message AgentInfoRequest {}

message AgentInfoResponse {
  // Contains AgentMetadata for each of the agents currently registered with
  // Vizier.
  repeated AgentMetadata info = 1;
}

message AgentMetadata {
  pl.vizier.services.shared.agent.Agent agent = 1;
  pl.vizier.services.shared.agent.AgentStatus status = 2;
  // Info that describes the carnot instance for the agent.
  pl.carnot.planner.distributedpb.CarnotInfo carnot_info = 3;
}

message AgentTableMetadataRequest {}

message AgentTableMetadata {
  uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
  pl.table_store.schemapb.Schema schema = 2;
  pl.vizier.messages.AgentDataInfo data_info = 3;
}

message AgentTableMetadataResponse {
  repeated AgentTableMetadata metadata_by_agent = 1;
}

message AgentUpdatesRequest {}

message AgentUpdatesResponse {
  // List of agents that have been deleted.
  repeated uuidpb.UUID deleted_agents = 1;
  // For all agents that have had updated metadata since the previous message in this stream,
  // this field contains their latest state. Contains a maximum of 100 agents in this list,
  // any additional agents should be sent in another response message in this stream.
  repeated AgentMetadata agent_metadata_updates = 2;
  // For all agents that have had updated table metadata since the previous message in this
  // stream, this field contains their latest state. Contains a maximum of 100 agents in this list,
  // any additional agents should be sent in another response message in this stream.
  repeated AgentTableMetadata agent_table_metadata_updates = 3;
}

// The request to register tracepoints on all PEMs.
message RegisterTracepointRequest {
  pl.stirling.dynamic_tracing.ir.logical.Program program = 1;
  // The user-specified name for the tracepoint.
  string tracepoint_name = 2;
  // The TTL, in seconds, for how long we want the tracepoint to live.
  google.protobuf.Duration ttl = 3 [ (gogoproto.customname) = "TTL" ];
}

// The response to a RegisterTracepointRequest.
message RegisterTracepointResponse {
  // Status of whether the tracepoint registration request was initiated with/without errors.
  pl.statuspb.Status status = 1;
  // The ID of the tracepoint. This should be the user-specified name for the tracepoint.
  uuidpb.UUID tracepoint_id = 2 [ (gogoproto.customname) = "TracepointID" ];
}

// The request to check the status for a tracepoint with the given names.
message GetTracepointInfoRequest {
  repeated uuidpb.UUID tracepoint_ids = 1 [ (gogoproto.customname) = "TracepointIDs" ];
}

// The status of whether the tracepoint has successfully registered or not.
message GetTracepointInfoResponse {
    message TracepointState {
        // The tracepoint ID.
        uuidpb.UUID tracepoint_id = 1 [ (gogoproto.customname) = "TracepointID" ];
        // The state of the tracepoint.
        pl.statuspb.LifeCycleState state = 2;
        // The status of the tracepoint, specified if the state of the tracepoint is not healthy.
        pl.statuspb.Status status = 3;
        string tracepoint_name = 4;
        // The desired state for the tracepoint. This can be used to determine whether
        // the tracepoint is just starting up or in the process of terminating.
        pl.statuspb.LifeCycleState expected_state = 5;
    }
    // List of tracepoint states.
    repeated TracepointState tracepoints = 1;
}

// The request to evict a tracepoint. This will normally happen via the tracepoint's TTL, but can be
// initiated via request as well.
message RemoveTracepointRequest {
    // The ID of the tracepoint to remove.
    uuidpb.UUID tracepoint_id = 1 [ (gogoproto.customname) = "TracepointID" ];
}

// The response to the tracepoint removal.
message RemoveTracepointResponse {
  // Status of whether the tracepoint removal request was initiated with/without errors.
  pl.statuspb.Status status = 1;
}
