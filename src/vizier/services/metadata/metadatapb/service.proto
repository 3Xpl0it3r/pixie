syntax = "proto3";

package pl.vizier.services.metadata;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "src/common/uuid/proto/uuid.proto";
import "src/table_store/proto/schema.proto";
import "src/carnot/planner/distributedpb/distributed_plan.proto";
import "src/vizier/messages/messagespb/messages.proto";
import "src/vizier/services/shared/agentpb/agent.proto";
import "src/stirling/dynamic_tracing/ir/logical.proto";
import "src/common/base/proto/status.proto";

option go_package = "pixielabs.ai/pixielabs/src/vizier/services/metadata/metadatapb;metadatapb";

service MetadataService {
  /**
   * These RPC calls are used by the query broker and CLI to fetch metadata.
   */

  rpc GetSchemas(SchemaRequest) returns (SchemaResponse) {}
  rpc GetSchemaByAgent(SchemaByAgentRequest) returns (SchemaByAgentResponse) {}
  rpc GetAgentInfo(AgentInfoRequest) returns (AgentInfoResponse) {}
  rpc GetAgentTableMetadata(AgentTableMetadataRequest) returns (AgentTableMetadataResponse) {}
  rpc GetAgentUpdates(AgentUpdatesRequest) returns (stream AgentUpdatesResponse) {}
  rpc RegisterProbe(RegisterProbeRequest) returns (RegisterProbeResponse) {}
  rpc GetProbeInfo(GetProbeInfoRequest) returns (GetProbeInfoResponse) {}
  rpc EvictProbe(EvictProbeRequest) returns (EvictProbeResponse) {}
}

// The schema request for each agent's schema.
message SchemaByAgentRequest {
  // IDs of the agents to get schemas from. If no IDs are specified,
  // it is assumed that schemas for all agents are requested.
  repeated uuidpb.UUID agent_ids = 1;
}

// The schema response from the metadata service.
message SchemaByAgentResponse {
  message SchemaByAgent {
    uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
    pl.table_store.schemapb.Schema schema = 2;
  }
  repeated SchemaByAgent schema_by_agent = 1;
}

message SchemaRequest {}

// The schema response from the metadata service containing the schema that all
// agents serve.
message SchemaResponse { pl.table_store.schemapb.Schema schema = 2; }

message AgentInfoRequest {}

message AgentInfoResponse {
  // Contains AgentMetadata for each of the agents currently registered with
  // Vizier.
  repeated AgentMetadata info = 1;
}

message AgentMetadata {
  pl.vizier.services.shared.agent.Agent agent = 1;
  pl.vizier.services.shared.agent.AgentStatus status = 2;
  // Info that describes the carnot instance for the agent.
  pl.carnot.planner.distributedpb.CarnotInfo carnot_info = 3;
}

message AgentTableMetadataRequest {}

message AgentTableMetadata {
  uuidpb.UUID agent_id = 1 [ (gogoproto.customname) = "AgentID" ];
  pl.table_store.schemapb.Schema schema = 2;
  pl.vizier.messages.AgentDataInfo data_info = 3;
}

message AgentTableMetadataResponse {
  repeated AgentTableMetadata metadata_by_agent = 1;
}

message AgentUpdatesRequest {}

message AgentUpdatesResponse {
  // List of agents that have been deleted.
  repeated uuidpb.UUID deleted_agents = 1;
  // For all agents that have had updated metadata since the previous message in this stream,
  // this field contains their latest state. Contains a maximum of 100 agents in this list,
  // any additional agents should be sent in another response message in this stream.
  repeated AgentMetadata agent_metadata_updates = 2;
  // For all agents that have had updated table metadata since the previous message in this
  // stream, this field contains their latest state. Contains a maximum of 100 agents in this list,
  // any additional agents should be sent in another response message in this stream.
  repeated AgentTableMetadata agent_table_metadata_updates = 3;
}

// The request to register probes on all PEMs.
message RegisterProbeRequest {
  pl.stirling.dynamic_tracing.ir.logical.Program program = 1;
  // The user-specified name for the probe.
  string probe_name = 2;
}

// The response to a RegisterProbeRequest.
message RegisterProbeResponse {
  // Status of whether the probe registration request was initiated with/without errors.
  pl.statuspb.Status status = 1;
  // The ID of the probe. This should be the user-specified name for the probe.
  string probe_id = 2 [ (gogoproto.customname) = "ProbeID" ];
}

// The request to check the status for a probe with the given IDs.
message GetProbeInfoRequest {
  repeated string probe_ids = 1 [ (gogoproto.customname) = "ProbeIDs" ];
}

// The status of whether the probe has successfully registered or not.
message GetProbeInfoResponse {
    message ProbeState {
        // The probe ID.
        string probe_id = 1 [ (gogoproto.customname) = "ProbeID" ];
        // The state of the probe.
        pl.statuspb.LifeCycleState state = 2;
        // The status of the probe, specified if the state of the probe is not healthy.
        pl.statuspb.Status status = 3;
    }
    // List of probe states.
    repeated ProbeState probes = 1;
}

// The request to evict a probe. This will normally happen via the probe's TTL, but can be
// initiated via request as well.
message EvictProbeRequest {
    // The ID of the probe to evict.
    string probe_id = 1 [ (gogoproto.customname) = "ProbeID" ];
}

// The response to the probe eviction.
message EvictProbeResponse {
  // Status of whether the probe eviction request was initiated with/without errors.
  pl.statuspb.Status status = 1;
}
